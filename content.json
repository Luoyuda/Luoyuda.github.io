{"meta":{"title":"落雨不落雨","subtitle":"角落","description":"保持耐心","author":"xiayuchen","url":"https://luoyuda.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-04-15T06:06:33.728Z","updated":"2022-04-15T06:06:33.728Z","comments":false,"path":"about/index.html","permalink":"https://luoyuda.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617181920&#123; &quot;name&quot;: &quot;陈夏雨&quot;, &quot;age&quot;: 25, &quot;gender&quot;: &quot;男&quot;, &quot;profession&quot;: &quot;前端开发&quot;, &quot;experience&quot;: &quot;5年&quot;, &quot;address&quot;: &quot;广东深圳&quot;, &quot;education&quot;: &quot;本科&quot;, &quot;github&quot;: &quot;https://github.com/luoyuda&quot;, &quot;blog&quot;: &quot;https://luoyuda.github.io/&quot;, &quot;juejin&quot;: &quot;https://juejin.cn/user/2770425032224814&quot; &quot;email&quot;: &quot;562958029@qq.com&quot;, &quot;description&quot;: &quot;我永远喜欢Javascript&quot;, &quot;skills&quot;: [ [&quot;Html&quot;, &quot;Javascript&quot;, &quot;jQuery&quot;, &quot;CSS&quot;, &quot;ES6&quot;, &quot;Node&quot;], [&quot;Vue&quot;, &quot;React&quot;], [&quot;Webpack&quot;, &quot;Vite&quot;], [&quot;Less&quot;,&quot;Sass&quot;], ]&#125;"},{"title":"书单","date":"2022-04-15T06:06:33.728Z","updated":"2022-04-15T06:06:33.728Z","comments":false,"path":"books/index.html","permalink":"https://luoyuda.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-15T06:06:33.728Z","updated":"2022-04-15T06:06:33.728Z","comments":false,"path":"categories/index.html","permalink":"https://luoyuda.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-15T06:06:33.740Z","updated":"2022-04-15T06:06:33.740Z","comments":false,"path":"repository/index.html","permalink":"https://luoyuda.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-15T06:06:33.740Z","updated":"2022-04-15T06:06:33.740Z","comments":false,"path":"tags/index.html","permalink":"https://luoyuda.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LFU 缓存算法 （JavaScript实现）","slug":"data-structures/LFU","date":"2022-04-15T13:23:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/15/data-structures/LFU/","link":"","permalink":"https://luoyuda.github.io/2022/04/15/data-structures/LFU/","excerpt":"","text":"是什么最不经常使用算法（LFU）： 这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。leetcode真题地址 方法 LFUCache(capacity) - 用数据结构的容量 capacity 初始化对象 get(key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 put(key, value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 流程拆解我们需要 map 和双向链表的结构以达到 get 和 put 的时间复杂度为 O(1) nodeMap：用于存储节点信息 freqMap：按使用频率存储双向链表结构，方便定位 当我们调用 put(1,1) 方法时是这样的，将其作为插入到 key = 1 双向链表中的第一个元素，然后更新 minFreq 为 1 put(2,2)：将其作为插入到 key = 1 双向链表中的第一个元素，然后更新 minFreq 为 1 get(1)：此时通过 nodeMap 中获取值，然后更新 freqMap 中的 key = 2 双向链表 put(3,3)：此时因为个数已经满了，需要删除最不经常使用的元素，通过 minFreq 去定位找到目标链表，并取出最后一个元素 将 node-2 删除后，将 node-3 插入，并更新 minFreq 为 1 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * @param &#123;number&#125; k * @param &#123;number&#125; v * @param &#123;number&#125; c * @param &#123;Node&#125; l * @param &#123;Node&#125; r */function ListNode(k, v, c, l, r) &#123; this.k = k this.v = v this.c = c || 1 this.l = l this.r = r&#125;/** * 双向链表类 */function Linklist() &#123; this.head = new ListNode(-1, &#x27;head&#x27;) this.tail = new ListNode(-1, &#x27;tail&#x27;) this.head.r = this.tail this.tail.l = this.head this.length = 0&#125;/** * 往头部插入元素 * @param &#123;Node&#125; node */Linklist.prototype.add = function (node) &#123; let r = this.head.r node.r = r node.l = this.head r.l = node this.head.r = node this.length++&#125;/** * 删除某个节点 * @param &#123;Node&#125; node */Linklist.prototype.delete = function (node) &#123; if (node.l) &#123; let l = node.l l.r = node.r node.r.l = l &#125; this.length--&#125;/** * @param &#123;number&#125; capacity */var LFUCache = function (capacity) &#123; this.capacity = capacity // 当前最小的使用次数的链表位置 this.minFreq = 1 // 存储节点 this.nodeMap = new Map() // 存储次数跟链表映射关系 this.freqMap = new Map()&#125;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LFUCache.prototype.get = function (key) &#123; if (this.capacity === 0) return -1 const node = this.nodeMap.get(key) if (!node) return -1 // 更新位置 this.update(node) return node.v&#125;/** * @param &#123;Node&#125; node */LFUCache.prototype.update = function (node) &#123; // 从旧链表中删除节点 let last = this.freqMap.get(node.c) last.delete(node) if (!last.length &amp;&amp; node.c === this.minFreq) &#123; // 如果链表为空，且当前次数是最低次数的链表值，最低次数的指针 + 1 this.minFreq++ &#125; // 从新链表头部插入 let now = this.freqMap.get(++node.c) if (!now) &#123; now = new Linklist() this.freqMap.set(node.c, now) &#125; now.add(node)&#125;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LFUCache.prototype.put = function (key, value) &#123; if (this.capacity === 0) return let node = this.nodeMap.get(key) if (!node) &#123; // 不存在节点，创建 node = new ListNode(key, value) if (!this.freqMap.get(node.c)) &#123; this.freqMap.set(node.c, new Linklist()) &#125; const nodes = this.freqMap.get(node.c) if (this.nodeMap.size &gt;= this.capacity) &#123; // 个数超过时，从最低使用次数的链表中的尾部移除元素 let minNodes = this.freqMap.get(this.minFreq) let minNode = minNodes.tail.l this.nodeMap.delete(minNode.k) minNodes.delete(minNode) &#125; // 因为新增，必然使用此时最低，回归到1 this.minFreq = 1 this.nodeMap.set(key, node) nodes.add(node) &#125; else &#123; node.v = value this.update(node) &#125;&#125; 缺点存在历史数据影响将来数据的”缓存污染”问题，累计的数据越多，对新加的数据可能起不到缓存的作用。比如历史记录中前 9 条数据都是 100+ 的次数，后面新数据上来，使用次数赶不上历史数据时会优先被淘汰。 无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LFU","slug":"LFU","permalink":"https://luoyuda.github.io/tags/LFU/"}]},{"title":"LRU 缓存算法 （JavaScript实现）","slug":"data-structures/LRU","date":"2022-04-14T13:23:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/14/data-structures/LRU/","link":"","permalink":"https://luoyuda.github.io/2022/04/14/data-structures/LRU/","excerpt":"","text":"是什么LRU（Least Recently Used），即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。 方法 LRUCache(capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 get(key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 put(key, value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 leetcode 习题 用于验证 array + hash 版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @param &#123;number&#125; capacity */var LRUCache = function (capacity) &#123; this.capacity = capacity this.keys = [] this.values = &#123;&#125;&#125;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function (key) &#123; const value = this.values[key] // 如果不存在，返回 -1 if (value === undefined) return -1 // 更新 key 的位置 this.update(key) return value&#125;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.update = function (key) &#123; for (let i = 0; i &lt; this.keys.length; i++) &#123; if (key === this.keys[i]) &#123; // 找到 key 的位置，把前面的元素往后移动一位 for (let j = i; j &gt;= 1; j--) &#123; this.keys[j] = this.keys[j - 1] &#125; // 将 key 移动到首位 this.keys[0] = key break &#125; &#125;&#125;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function (key, value) &#123; const val = this.values[key] // 更新值 this.values[key] = value if (val !== undefined) &#123; // 如果之前存在值，更新位置 this.update(key) &#125; else &#123; // 超出先删除 if (this.keys.length &gt;= this.capacity) &#123; delete this.values[this.keys.pop()] &#125; // 往第一个位置插入 this.keys.unshift(key) &#125;&#125; 虽然通过，但是效率并不高 采用双向链表优化更新过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @param &#123;number&#125; k * @param &#123;number&#125; v * @param &#123;Node&#125; l * @param &#123;Node&#125; r */function Node(k, v, l, r) &#123; this.l = l this.r = r this.k = k this.v = v&#125;/** * @param &#123;number&#125; capacity */var LRUCache = function (capacity) &#123; this.size = capacity this.map = new Map() this.head = new Node(-1, -1) this.tail = new Node(-1, -1) this.head.r = this.tail this.tail.l = this.head&#125;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function (key) &#123; const node = this.map.get(key) if (!node) return -1 this.update(node) return node.v&#125;/** * @param &#123;Node&#125; node * @return &#123;void&#125; */LRUCache.prototype.update = function (node) &#123; // 先从链表中提取出来 this.delete(node) // 在头节点位置插入 node.r = this.head.r node.l = this.head this.head.r.l = node this.head.r = node&#125;/** * @param &#123;Node&#125; key * @return &#123;void&#125; */LRUCache.prototype.delete = function (node) &#123; if (node.l) &#123; // 断开节点 1 -&gt; 2 -&gt; 3 // 1 -&gt; 3 let l = node.l l.r = node.r node.r.l = l &#125;&#125;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function (key, value) &#123; const node = this.map.get(key) || new Node(key, value) // 更新节点 node.v = value this.map.set(key, node) // 更新位置 this.update(node) if (this.map.size &gt; this.size) &#123; // 删除队尾元素 let del = this.tail.l this.map.delete(del.k) this.delete(del) &#125;&#125; 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LRU","slug":"LRU","permalink":"https://luoyuda.github.io/tags/LRU/"}]},{"title":"开发一个懒加载图片 npm 插件","slug":"JavaScript/lazy","date":"2022-04-12T02:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/12/JavaScript/lazy/","link":"","permalink":"https://luoyuda.github.io/2022/04/12/JavaScript/lazy/","excerpt":"","text":"懒加载图片懒加载图片是 web 中常见的性能优化手段，可以有效的减少非首屏的图片请求，带宽消耗 实现方案 img 元素定义一个 data-src 属性存放图片地址或者普通元素定义一个 data-background-src 属性 获取屏幕可视区域的尺寸 获取元素到窗口边缘的距离 判断元素是否在可视边缘内，如果是则把 data-src 赋值给 src 或者 data-background-src 赋值给 background-image: url() 使用的 APIIntersectionObserver：提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法，具体使用参考 mdn scroll：监听滚动事件，判断目标元素是否在视窗内 编码目录结构 先写一个页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;lazy&lt;/title&gt; &lt;style&gt; img&#123; width: 300px; min-height: 300px; border-radius: 5px; background-color: #ddd; margin: 10px; &#125; .bg&#123; width: 300px; height: 300px; border-radius: 5px; background-color: #eee; margin: 10px; &#125; .data&#123; width: 100%; overflow: scroll; &#125; #data&#123; display: flex; width: 10000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;div class=&quot;data&quot;&gt; &lt;div id=&quot;data&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function() &#123; let app = document.getElementById(&quot;app&quot;); let data = document.getElementById(&quot;data&quot;); let src = &#x27;https://p9-passport.byteacctimg.com/img/user-avatar/fbf0dad2f64546b5718cb7e502e92c7b~1000x1000.image&#x27; let lazyHtml = new Array(20).fill(0).reduce((prev, cur, index) =&gt; &#123; return prev + `&lt;img class=&#x27;img&#x27; index=$&#123;index&#125; data-src=&#x27;$&#123;src&#125;?index=$&#123;+new Date() + index&#125;&#x27;&gt;` &#125;, &#x27;&#x27;) let lazyBackgroundHtml = new Array(20).fill(0).reduce((prev, cur, index) =&gt; &#123; return prev + `&lt;div class=&#x27;bg&#x27; index=$&#123;index&#125; style=&#x27;background-position: center&#x27; data-background-image=&#x27;$&#123;src&#125;?index=$&#123;+new Date() + index&#125;&#x27;&gt;&lt;/div&gt;` &#125;, &#x27;&#x27;) app.innerHTML = lazyHtml + lazyBackgroundHtml data.innerHTML = lazyHtml + lazyBackgroundHtml &#125; &lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 先写如何调用 123456789setTimeout(() =&gt; &#123; // 确保节点插入后使用懒加载工具 window.lazyImage = LazyImage(&#123; el: &#x27;.data&#x27; &#125;) window.lazyImage = LazyImage(&#123; el: &#x27;#app&#x27;, &#125;)&#125;) 开始来写 LazyImage 的实现，先把代码骨架写好 123456789// index.jsclass Lazy &#123; &#125;function LazyImage(...arg) &#123; return new Lazy(...arg)&#125; 构造函数中需要去对参数进行提取合并，初始化操作 123456789101112131415161718192021222324252627282930constructor(options) &#123; options = options || &#123;&#125; // 从哪个元素下获取节点 const el = options.el || &#x27;&#x27; this.el = util.querySelector(el) // 懒加载 N 秒后执行 this.wait = options.wait || 500 // 偏移量 this.diffTop = 0 this.diffLeft = 0 // 容器，是否父容器为滚动元素，相对父容器还是window this.isScrollContainer = options.isScrollContainer || !(this.el.scrollWidth &lt;= this.el.clientWidth) || !(this.el.scrollHeight &lt;= this.el.clientHeight) this.container = this.isScrollContainer ? this.el : window // 合并 observerOption IntersectionObserver 使用的配置 this.observerOption = options.observerOption || &#123; thresholds: [1], root: this.isScrollContainer ? this.el : null, &#125; // 待观察图片数组 this.images = [] // 初始化监听方式，使用单例模式 this.initEvents = getEventFunc().bind(this) // 初始化销毁函数，避免报错，先使用空函数 this.destroyEvent = () =&gt; &#123; &#125; // 更新插件 this.update()&#125; getEventFunc 的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061let func = nullfunction getEventFunc() &#123; // 如果已经判断过，直接返回 if (func) return func // 优先使用 IntersectionObserver if (window.IntersectionObserver) &#123; func = function () &#123; // 这里使用缓存数组，缓存激活元素 let activeImages = [] // 使用 setTimeout 做一个防抖 let timeout // 监听 let observer = new IntersectionObserver((images) =&gt; &#123; activeImages.push(...images) if (timeout) clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; activeImages .filter((image) =&gt; image.isIntersecting) .map((image) =&gt; image.target) .forEach((image) =&gt; &#123; if (this.initImages(image)) &#123; // 完成图片加载后移除监听 observer.unobserve(image) &#125; &#125;) // 清空本次激活数组 activeImages = [] &#125;, this.wait) &#125;, this.observerOption) // 对每一项进行监听 this.images.forEach((image) =&gt; observer.observe(image)) // 返回一个销毁事件监听方法 return () =&gt; &#123; this.images.forEach((image) =&gt; observer.unobserve(image)) &#125; &#125; &#125; else &#123; // 否则降级使用 scroll func = function () &#123; // 这里也做一个防抖 let timeout = null let load = () =&gt; &#123; if (timeout) clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; this.images.forEach((image) =&gt; this.initImages(image)) &#125;, this.wait) &#125; if (this.container !== window) &#123; // fix 横向滚动时上下滚动无法触发更新问题 window.addEventListener(&#x27;scroll&#x27;, load) &#125; this.container.addEventListener(&#x27;scroll&#x27;, load) // 同样返回一个销毁函数 return () =&gt; &#123; this.container.removeEventListener(&#x27;scroll&#x27;, load) window.removeEventListener(&#x27;scroll&#x27;, load) &#125; &#125; &#125; return func&#125; update 和 _init 方法实现 1234567891011_init() &#123; // 先销毁 this.destroyEvent() // 获取元素 this.queryImage() // 监听，并到下一次销毁的方法 this.destroyEvent = this.initEvents()&#125;update() &#123; return this._init()&#125; 编写工具方法 util 1234567891011121314151617181920212223242526272829303132333435363738const util = &#123; // 获取容器宽高 getVwVh(container) &#123; return &#123; vw: container.innerWidth || window.innerWidth || document.documentElement.clientWidth, vh: container.innerHeight || window.innerHeight || document.documentElement.clientHeight, &#125; &#125;, // 获取元素 querySelector(el = &#x27;&#x27;) &#123; return el ? document.querySelector(el) : document.body &#125;, // 获取元素属性值 getAttribute(el, name) &#123; return el.getAttribute(name) &#125;, // 获取全部元素 querySelectorAll(el, search) &#123; return el &amp;&amp; search ? el.querySelectorAll(search) : [] &#125;,&#125;// 初始化工具函数;[ [&#x27;src&#x27;, &#x27;getSrc&#x27;, util.getAttribute], [&#x27;data-src&#x27;, &#x27;getDataSrc&#x27;, util.getAttribute], [&#x27;data-background-image&#x27;, &#x27;getBackgroundSrc&#x27;, util.getAttribute], [&#x27;style&#x27;, &#x27;getStyle&#x27;, util.getAttribute], [&#x27;[data-src]&#x27;, &#x27;queryAllSrc&#x27;, util.querySelectorAll], [&#x27;[data-background-image]&#x27;, &#x27;queryAllImage&#x27;, util.querySelectorAll],].forEach(([key, val, fn]) =&gt; &#123; util[val] = (el) =&gt; fn(el, key)&#125;) queryImage 方法 1234567891011121314queryImage() &#123; if (!this.el) return // 获取所有符合标准的元素 this.images = [ ...util.queryAllSrc(this.el), ...util.queryAllImage(this.el), ].filter((el) =&gt; &#123; // 过滤漏网之鱼 return !!( !util.getSrc(el) &amp;&amp; (util.getDataSrc(el) || util.getBackgroundSrc(el)) ) &#125;)&#125; inViewport 判断是否处于视窗内 12345678910111213inViewport(el) &#123; // 获取容器宽高 const &#123; vw, vh &#125; = util.getVwVh(this.container) // 获取元素的位置 const &#123; top, right, bottom, left &#125; = el.getBoundingClientRect() // 计算判断是否满足条件 return ( top - vh &lt; this.diffTop &amp;&amp; bottom &gt; this.diffTop &amp;&amp; left - vw &lt; this.diffLeft &amp;&amp; right &gt; this.diffLeft )&#125; initImages 加载图片方法 1234567891011121314151617181920212223242526272829303132initImages(image) &#123; // 如果不在视窗内，直接返回 if (!this.inViewport(image)) return null // 获取内容 const src = util.getSrc(image) const dataSrc = util.getDataSrc(image) const dataBackground = util.getBackgroundSrc(image) // 判断是否加载过 if (src || (!dataSrc &amp;&amp; !dataBackground)) return image // 存在src if (dataSrc) &#123; // 修改src image.setAttribute(&#x27;src&#x27;, dataSrc) let load = () =&gt; &#123; // 初始化结束后从数组中清除该节点 this.images = this.images.filter((img) =&gt; img !== image) image.removeAttribute(&#x27;data-src&#x27;) // 删除事件监听 image.removeEventListener(&#x27;load&#x27;, load) &#125; image.addEventListener(&#x27;load&#x27;, load) &#125; if (dataBackground) &#123; // 获取原有的 style 进行拼接 image.style = `$&#123;util.getStyle( image )&#125;; background-image:url($&#123;dataBackground&#125;);` this.images = this.images.filter((img) =&gt; img !== image) image.removeAttribute(&#x27;data-background-image&#x27;) &#125; return image&#125; 看看效果 打包 使用 rollup 打包 1234567891011121314151617181920212223// rollup.config.jsimport babel from &quot;rollup-plugin-babel&quot;;import resolve from &#x27;rollup-plugin-node-resolve&#x27;;import commonjs from &#x27;rollup-plugin-commonjs&#x27;;import &#123; terser &#125; from &#x27;rollup-plugin-terser&#x27;;export default &#123; input: &#x27;src/index.js&#x27;, output: &#123; name: &#x27;LazyImage&#x27;, file: &#x27;xy-lazyimage.min.js&#x27;, format: &#x27;umd&#x27; &#125;, plugins: [ resolve(), commonjs(), babel(&#123; exclude: &#x27;node_modules/**&#x27;, // 防止打包node_modules下的文件 runtimeHelpers: true, // 使plugin-transform-runtime生效 &#125;), terser() ]&#125; package.json 1234567891011121314151617181920212223242526272829303132&#123; &quot;name&quot;: &quot;xy-lazyimage&quot;, &quot;version&quot;: &quot;1.0.6&quot;, &quot;description&quot;: &quot;懒加载图片插件&quot;, &quot;main&quot;: &quot;src/index.js&quot;, &quot;module&quot;: &quot;src/index.js&quot;, &quot;browser&quot;: &quot;xy-lazyimage.min.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;rollup -c&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/Luoyuda/xy-lazyimage&quot;, &quot;author&quot;: &quot;xiayuchen&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;, &quot;@babel/core&quot;: &quot;^7.17.8&quot;, &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.17.0&quot;, &quot;@babel/polyfill&quot;: &quot;^7.12.1&quot;, &quot;@babel/preset-env&quot;: &quot;^7.16.11&quot;, &quot;core-js&quot;: &quot;^3.21.1&quot;, &quot;rollup-plugin-commonjs&quot;: &quot;^10.1.0&quot;, &quot;rollup-plugin-node-resolve&quot;: &quot;^5.2.0&quot;, &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot; &#125;, &quot;keywords&quot;: [&quot;lazy&quot;, &quot;lazy image&quot;, &quot;lazyload&quot;], &quot;dependencies&quot;: &#123; &#125;, &quot;files&quot;: [ &quot;xy-lazyimage.min.js&quot; ]&#125; 源码地址 npm包地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"懒加载图片","slug":"懒加载图片","permalink":"https://luoyuda.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"name":"插件开发","slug":"插件开发","permalink":"https://luoyuda.github.io/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://luoyuda.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"EventLoop 到底是个啥（JavaScript）","slug":"JavaScript/eventloop","date":"2022-04-11T08:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/11/JavaScript/eventloop/","link":"","permalink":"https://luoyuda.github.io/2022/04/11/JavaScript/eventloop/","excerpt":"","text":"同步和异步、阻塞和非阻塞同步和异步关注的是消息通信机制，描述的是一种行为方式 同步：发出调用后，在没有得到结果之前，该调用不返回。当调用返回时得到返回值。调用者主动等待这个调用结果 异步：发出调用后，立即返回。但调用方通常不会立即得到结果。调用者需要等待被调用者通知才能得到调用结果 阻塞非阻塞关注的是程序在等待调用结果时的状态，描述的是一种状态 阻塞：调用结果返回之前，线程被挂起，只有得到结果之后才会激活 非阻塞：调用后不等待结果，该调用不阻塞当前进程 EventLoopJavaScript 是一门单线程的语言，起初只是为了实现简单的功能而设计的脚本语言。单线程存在着任务执行阻塞的问题，遇到耗时的操作时，容易导致页面长时间无响应。 EventLoop（事件循环）是让 JavaScript 做到即是单线程运行，又不会阻塞的一种机制。是 JavaScript 并发模型的基础，用于协调各类事件、交互、脚本执行、UI渲染、网络请求等操作 EventLoop 由三个部分组成，函数调用栈、宏任务队列（macro-task-queue）和微任务队列（micro-task-queue） 函数调用栈当引擎遇到 JS 代码时，会产生全局上下文，并将其压入调用栈中，后面每当遇到函数调用都会往栈中压入新的函数上下文，执行完栈顶内容后，弹出对应的上下文 宏任务队列通过队列存放被注册的宏任务 常见的宏任务（MacroTask）：script 中的代码、setTimeout、setInterval、setImmediate(ie10、node)、postMessage(MessageChannel)、I/O、UI渲染、网络请求、History API requestAnimationFrame不是宏任务！它会在微任务结束后，下一个 EventLoop 开始前去执行 微任务队列通过队列存放被注册的微任务 常见的微任务（MicroTask）：Promise callback、MutationObserver、Object.observe 循环过程一个宏任务一队微任务 调用栈选择最先进入队列的 MacroTask，执行过程如果产生新的 MacroTask 或 MicroTask 分别入队 执行完毕第一个 MacroTask，检查当前的 MicroTask 队列，执行至清空 MicroTaskQueue 浏览器检查更新渲染（render），每次循环都可能会检查更新渲染 重复 1-3，直到所有队列都为空 例子1234567891011121314151617181920212223242526let logs = []let log = (v) =&gt; logs.push(v)setTimeout(() =&gt; &#123; log(&#x27;timer - 1&#x27;) new Promise((resolve) =&gt; &#123; log(&#x27;sync - 1&#x27;) resolve() &#125;).then(() =&gt; &#123; log(&#x27;then - 1&#x27;) &#125;)&#125;)new Promise((resolve) =&gt; &#123; log(&#x27;sync - 2&#x27;) setTimeout(() =&gt; &#123; log(&#x27;timer - 2&#x27;) new Promise((resolve) =&gt; &#123; log(&#x27;sync - 3&#x27;) resolve() &#125;).then(() =&gt; &#123; log(&#x27;then - 3&#x27;) &#125;) &#125;) resolve()&#125;).then(() =&gt; &#123; log(&#x27;then - 2&#x27;)&#125;) 遇到 setTimeout 将回调入队 macro-task-queue 123456789setTimeout(() =&gt; &#123; log(&#x27;timer - 1&#x27;) new Promise((resolve) =&gt; &#123; log(&#x27;sync - 1&#x27;) resolve() &#125;).then(() =&gt; &#123; log(&#x27;then - 1&#x27;) &#125;)&#125;) 接着执行 new Promise 中的同步代码，又遇到 setTimeout 入队 12345new Promise((resolve) =&gt; &#123; log(&#x27;sync - 2&#x27;) // ... 入队 resolve()&#125;) 执行完成同步代码后，入队 then 微任务 micro-task-queue 123.then(() =&gt; &#123; log(&#x27;then - 2&#x27;)&#125;) 此时同步代码已经执行完毕出栈，依次执行 micro-task-queue 中的任务 micro-task-queue 清空，执行 macro-task-queue 队首 setTimeout1 执行完 new Promise 中的同步代码，then2 入队 micro-task-queue 12345log(&#x27;timer - 1&#x27;)new Promise((resolve) =&gt; &#123; log(&#x27;sync - 1&#x27;) resolve()&#125;) 执行完 setTimeout1 后，接着清空 micro-task-queue 123.then(() =&gt; &#123; log(&#x27;then - 1&#x27;)&#125;) 清空后，再次取出 macro-task-queue 队首，同样的操作，执行遇到 microTask 后又入队 then3 123456789setTimeout(() =&gt; &#123; log(&#x27;timer - 2&#x27;) new Promise((resolve) =&gt; &#123; log(&#x27;sync - 3&#x27;) resolve() &#125;).then(() =&gt; &#123; log(&#x27;then - 3&#x27;) &#125;)&#125;) 执行完最后的 then3 后，数组收集到的数据应该为 12345678910[ &#x27;sync - 2&#x27;, &#x27;then - 2&#x27;, &#x27;timer - 1&#x27;, &#x27;sync - 1&#x27;, &#x27;then - 1&#x27;, &#x27;timer - 2&#x27;, &#x27;sync - 3&#x27;, &#x27;then - 3&#x27;] NodeJS 中的 EventLoop times：执行 setTimeout() 和 setInterval() 中定义的回调函数 pending callbacks：处理网络I&#x2F;O或文件I&#x2F;O中的错误的回调（比较少见） idle, prepare：仅系统内部使用（忽略） poll：执行 I&#x2F;O 回调，处理轮询队列中的事件，同时检查定时器是否过期 poll 阶段处理的回调中，如果既派发了 setImmediate、又派发了 setTimeout，一定是先执行 setImmediate，再执行 setTimeout。 check：执行setImmediate() 中定义的回调函数 close callbacks：处理“关闭”的回调函数，socket.on(&#39;close&#39;, ...) 任务队列宏任务队列 Timers Queue IO Callbacks Queue Check Queue Close Callbacks Queue 微任务队列 Next Tick Queue：放置 process.nextTick(callback) Other Micro Queue：放置其他微任务 执行顺序一队一队执行！ 执行 script 同步代码 执行 microTaskQueue，优先清空 Next Tick Queue 中的任务，随后才会清空其它微任务 先执行 Next Tick Queue，所有callbacks会被依次调用 再执行 Other Mico Queue 执行 macroTaskQueue 每个阶段的宏任务执行完后执行微任务 需要特别注意的是 Node11开始，timers 阶段的setTimeout、setInterval等函数派发的任务、包括 setImmediate 派发的任务，都被修改为：一旦执行完当前阶段的一个任务，就立刻执行微任务队列。 123456789101112setTimeout(() =&gt; &#123; console.log(&#x27;timer 1&#x27;) Promise.resolve().then(() =&gt; &#123; console.log(&#x27;then 1&#x27;) &#125;)&#125;)setTimeout(() =&gt; &#123; console.log(&#x27;timer 2&#x27;) Promise.resolve().then(() =&gt; &#123; console.log(&#x27;then 2&#x27;) &#125;)&#125;) 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://luoyuda.github.io/tags/EventLoop/"},{"name":"队列","slug":"队列","permalink":"https://luoyuda.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"排序算法 - 堆排序 （JavaScript实现）","slug":"Sort/heap","date":"2022-04-10T12:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/10/Sort/heap/","link":"","permalink":"https://luoyuda.github.io/2022/04/10/Sort/heap/","excerpt":"","text":"堆排序利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 最大堆 堆内所有节点都大于或等于其孩子的节点值 堆顶元素就是堆内的最大值 最小堆 堆内所有节点都小于或等于其孩子的节点只 堆顶元素就是堆内最大值 实现一个堆12345678910111213141516171819202122class Heap &#123; constructor(size)&#123; &#125; get size() &#123; &#125; // 比较函数 handle(i, j)&#123; &#125; // 添加元素 add(el)&#123; &#125; // 弹出元素 pop()&#123; &#125; // 上浮 up()&#123; &#125; // 下沉 down()&#123; &#125; // 获取堆顶元素 peek()&#123; &#125;&#125;class MaxHeap extends Heap &#123; handle(i, j)&#123; &#125;&#125;class MinHeap extends Heap &#123; handle(i, j)&#123; &#125;&#125; 写一些辅助函数 1234567891011121314151617181920const helper = &#123; // 交换数组中的值 swap(arr, i, j)&#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125;, // 获取父元素的下标 parent(i)&#123; return i &gt;&gt; 1 &#125;, // 获取左孩子下标 left(i)&#123; return i * 2 &#125;, // 获取右孩子下标 right(i)&#123; return i * 2 + 1 &#125;&#125; 构造函数123456constructor(size)&#123; // 开辟数组空间 heap[0] 表示堆的个数 this.heap = new Array(size + 1); // 不真的使用第一个下标，方便后续定位 this.heap[0] = 0&#125; 获取堆当前个数12// 直接返回数组第一项get size() &#123; return this.heap[0] &#125; 获取堆顶元素123peek()&#123; return this.heap[1]&#125; 比较函数123handle(i, j)&#123; return this.heap[i] &lt; this.heap[j]&#125; 最大堆、最小堆继承父类，修改handle函数12345678910class MaxHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &gt; this.heap[j] &#125;&#125;class MinHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &lt; this.heap[j] &#125;&#125; 添加元素将元素插入到完全二叉树的最后一个节点，并执行堆上浮操作 123456789// 添加元素add(el)&#123; if(this.size &gt;= this.heap.length) return -1 // 往尾部插入元素后进行上浮操作 this.heap[0] += 1 this.heap[this.size] = el this.up() return el&#125; 上浮将节点与其父节点进行比较，如果不满足堆条件则和父节点交换，直到满足条件 123456789up()&#123; let i = this.size let j = helper.parent(i) while (this.handle(i, j) &amp;&amp; i &gt; 1)&#123; helper.swap(this.heap, i, j) i = j j = helper.parent(i) &#125;&#125; 弹出元素将堆顶元素删除，把最后一个节点复制到堆顶，然后将堆顶元素执行下沉操作 1234567891011// 弹出元素pop()&#123; if(!this.size) return -1 // 弹出堆顶后将最后一个元素放置到堆顶，然后执行下沉操作 let el = this.peek() helper.swap(this.heap, 1, this.size) this.heap[this.size] = undefined this.heap[0] -= 1 this.down() return el&#125; 下沉将节点与子节点比较，与较小&#x2F;较大的节点交换，直到满足条件 1234567891011121314151617down()&#123; let i = 1 while(i &lt; this.size &amp;&amp; i &lt;= this.size / 2)&#123; // 获取左右孩子下标 let l = helper.left(i) let r = helper.right(i) if(this.handle(r, i) || this.handle(l, i))&#123; // 如果有一个不满足，则进入判断 let j = this.handle(r, l) ? r : l helper.swap(this.heap, i, j) i = j &#125;else&#123; // 找到合适位置，跳出 break &#125; &#125;&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const helper = &#123; swap(arr, i, j)&#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125;, parent(i)&#123; return i &gt;&gt; 1 &#125;, left(i)&#123; return i * 2 &#125;, right(i)&#123; return i * 2 + 1 &#125;&#125;class Heap &#123; constructor(size)&#123; // 开辟数组空间 heap[0] 表示堆的个数 this.heap = new Array(size + 1); this.heap[0] = 0 &#125; get size() &#123; return this.heap[0] &#125; handle(i, j)&#123; return this.heap[i] &lt; this.heap[j] &#125; // 添加元素 add(el)&#123; if(this.size &gt;= this.heap.length) return -1 // 往尾部插入元素后进行上浮操作 this.heap[0] += 1 this.heap[this.size] = el this.up() return el &#125; // 弹出元素 pop()&#123; if(!this.size) return -1 // 弹出堆顶后将最后一个元素放置到堆顶，然后执行下沉操作 let el = this.peek() helper.swap(this.heap, 1, this.size) this.heap[this.size] = undefined this.heap[0] -= 1 this.down() return el &#125; // 上浮 up()&#123; let i = this.size let j = helper.parent(i) while (this.handle(i, j) &amp;&amp; i &gt; 1)&#123; helper.swap(this.heap, i, j) i = j j = helper.parent(i) &#125; &#125; // 下沉 down()&#123; let i = 1 while(i &lt; this.size &amp;&amp; i &lt;= this.size / 2)&#123; let l = helper.left(i) let r = helper.right(i) if(this.handle(r, i) || this.handle(l, i))&#123; let j = this.handle(r, l) ? r : l helper.swap(this.heap, i, j) i = j &#125;else&#123; break &#125; &#125; &#125; // 获取堆顶元素 peek()&#123; return this.heap[1] &#125;&#125;class MaxHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &gt; this.heap[j] &#125;&#125;class MinHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &lt; this.heap[j] &#125;&#125;var sortArray = function(arr)&#123; let n = arr.length let heap = new MinHeap(n) for (let i = 0; i &lt; n; i++) &#123; heap.add(arr[i]) &#125; for (let i = 0; i &lt; n; i++) &#123; arr[i] = heap.pop() &#125; return arr&#125; 执行过程 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(nlogn) O(nlogn) O(nlogn) O(n) in-place 不稳定 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"堆排序","slug":"堆排序","permalink":"https://luoyuda.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}]},{"title":"作用域、执行上下文、作用域链相关知识（JavaScript）","slug":"JavaScript/scope","date":"2022-04-09T04:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/09/JavaScript/scope/","link":"","permalink":"https://luoyuda.github.io/2022/04/09/JavaScript/scope/","excerpt":"","text":"一起养成写作习惯！这是我参与「掘金日新计划 · 4 月更文挑战」的第9天，点击查看活动详情。 作用域（scope）作用域（scope），它规定了如何去查找变量的规则。通俗点就是说当前执行代码对变量的访问权限 比如我当前定义了这三个值 a b c 123var a = 1var b = function()&#123;&#125;function c() &#123;&#125; 声明变量只有在声明之后才能在作用域中查找到它 12345function f(a)&#123; console.log(a + b) // 报错！抛出 ReferenceError b is not defined b = a&#125;f(2) 123456function f(a)&#123; console.log(a + b) // 2 + undefined = NaN var b = a console.log(a + b) // 4&#125;f(2) 上面代码实际等同于 12345678function f(a)&#123; var b console.log(a + b) // 2 + undefined = NaN b = a console.log(a + b) // 4&#125;f(2) 如何声明 var：在编译器解析时，会将 var a = 1 视为 var a a = 1 两段执行，存在变量提升！ let：重复声明报错，属块级作用域，存在变量提升，但会暂时性死区 const：重复声明报错，属块级作用域，存在变量提升，但会暂时性死区。内容只读，修改报错，但引用类型保存的是指针 function：函数声明，直接提升到最上面，提升优先级最高，且已完成赋值！ 静态作用域（词法作用域）静态作用域（词法作用域），采用词法作用域的变量叫词法变量。词法变量有一个在编译时静态确定的作用域。词法变量的作用域可以是一个函数或一段代码，该变量在这段代码区域内可见；在这段区域以外该变量不可见。如图 scope1 与 scope2 是互相隔离的，作用域链沿定义的位置往外延伸 词法作用域里，取变量的值时，会检查函数定义时的文本环境，捕捉函数定义时对该变量的绑定。 全局作用域全局作用域：声明在任何函数之外的顶层作用域的变量就是全局变量，变量拥有全局作用域 123456789var a = 0 // 最外层声明，全局变量function b()&#123; c = 1 // 不使用 var 声明也会被当作全局变量&#125;b()function d()&#123; console.log(a, c) // 可以访问全局作用域的变量&#125;d() 函数作用域（局部作用域）全局作用域：声明在函数内的顶变量，拥有函数作用域，外部环境无法访问到函数内部的变量（模块化的原理） 123456function a()&#123; var b = 1 console.log(b) // 1&#125;a()console.log(b) // 报错 块作用域（局部作用域）块作用域：ES6 开始，使用 let 和 const 声明的变量拥有块级作用域，作用域范围在 &#123;&#125; 之间 1234567891011&#123; let a = 1 const b = 2 console.log(a, b) // 1 2 属于块级作用域内&#125;console.log(a, b) // 报错&#123; var a = 1 var b = 2&#125;console.log(a, b) // 1 2 为什么需要块级作用域 解决声明提前 1234console.log(a) // undefinedvar a = 1console.log(b) // 报错let b = 2 解决 &#123;&#125; 中 var 声明被视为全局变量 123456789&#123; var c = 1&#125;console.log(c) // 1&#123; let d = 1&#125;console.log(c) // 报错 看实际的例子12345678910111213141516var val = &#x27;global&#x27;function fn ()&#123; var val = &#x27;fn&#x27; console.log(val) function _fn()&#123; var val = &#x27;_fn&#x27; console.log(val) return function inner()&#123; var _val = &#x27;inner&#x27; console.log(val) &#125; &#125; return _fn()&#125;console.log(val)fn()() 123456789function fn()&#123; let a = &#x27;a&#x27; console.log(a) if(a)&#123; let b = &#x27;b&#x27; console.log(b) &#125;&#125;fn() 修改词法作用域的方式 eval 与 with (最好不要用！) eval12345function fn(fnStr)&#123; eval(fnStr)&#125;fn(&#x27;a = &quot;a&quot;&#x27;)console.log(a) // a with123456789var a = &#123; b: &#x27;b&#x27;&#125;with(a)&#123; b = &#x27;change&#x27; c = &#x27;c&#x27; // 非严格模式查找键值不存在，会创建一个全局变量!&#125;console.log(a.b) // &#x27;change&#x27;console.log(c) // c 动态作用域动态作用域，采用变量叫动态变量。程序正在执行定义了动态变量的代码段，那么在这段时间内，该变量一直存在；代码段执行结束，该变量便消失。 作用域链沿着调用栈往外延伸，通过逐层检查函数的调用链，并打印第一次遇到的值。 如果是动态作用域 12345678910111213141516var local = &#x27;in global&#x27;function A()&#123; var local = &#x27;in A&#x27; function C()&#123; var local = &#x27;in C&#x27; B() &#125; B() // in A! C() // in C! B() // in A!&#125;function B()&#123; console.log(local)&#125;B() // in global!A() 实际上执行是这样的 12345678910111213141516var local = &#x27;in global&#x27;function A()&#123; var local = &#x27;in A&#x27; function C()&#123; var local = &#x27;in C&#x27; B() &#125; B() // in global! C() // in global! B() // in global!&#125;function B()&#123; console.log(local)&#125;B() // in global!A() 无论你在哪个位置调用 B 都只会向上查找到 in global 编译1var a = 1 词法分析：将字符打断成为有意义的片段（token） 比如上面的声明会被打断成如下 token 辅助工具 var a = 1 &#x3D;&gt; var a = 1 123456789101112131415161718[ &#123; &quot;type&quot;: &quot;Keyword&quot;, &quot;value&quot;: &quot;var&quot; &#125;, &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;value&quot;: &quot;a&quot; &#125;, &#123; &quot;type&quot;: &quot;Punctuator&quot;, &quot;value&quot;: &quot;=&quot; &#125;, &#123; &quot;type&quot;: &quot;Numeric&quot;, &quot;value&quot;: &quot;1&quot; &#125;] 解析：将每个 token 数组转换成一个嵌套元素的树，也就是抽象语法树AST(Abstract Syntax Tree) 1234567891011121314151617181920212223&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;a&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 1, &quot;raw&quot;: &quot;1&quot; &#125; &#125; ], &quot;kind&quot;: &quot;var&quot; &#125; ]&#125; 代码生成：将抽象语法树转换成可执行代码 执行上下文（Execution Context）当 JavaScript 被解析执行时，需要 执行代码的环境 这个环境被称为 执行上下文 分类 全局上下文：全局代码所处的环境，不在函数内的代码均执行与全局上下文中 函数上下文：函数调用时创建的环境 eval上下文：运行 eval 函数中代码时创建的环境 生命周期 创建阶段：此时还未执行代码，只做了准备工作 创建变量对象：arguments，提升函数声明和变量声明 创建作用域链：用于解析变量，从内层开始查找，逐步往外层词法作用域中查找 确定 this 执行阶段：开始执行代码，完成变量赋值，函数引用等等 回收阶段：函数调用完毕后，函数，对应的执行上下文出栈，等待垃圾回收器回收 123456789var e = 0function a(d)&#123; var b = 1 function c()&#123; console.log(e, b, d) &#125; c()&#125;a(1) 全局上下文创建阶段 全局上下文执行阶段 遇到函数调用 a(1) a 函数上下文创建阶段，入栈 a 函数上下文执行阶段 c() 函数调用， c 函数上下文创建阶段，入栈 c 执行完毕，出栈 a 执行完毕，出栈 特点 全局执行上下文在代码开始时创建，有且只有一个，且永远再栈底 函数被调用时就会创建函数执行上下文，后入栈。（根据调用创建） 变量对象（Variable Object，VO）变量对象时上下文相关的数据作用域，存储了上下文定义的变量和函数声明 12345678910111213141516171819202122232425262728293031323334var e = 0/* 全局执行上下文的变量对象则是 windowwindow = &#123; e: 0 ...&#125;*/function a(d)&#123; /* 创建阶段 VO = &#123; arguments: &#123; 0: 1, length: 1 &#125; b: undefined c: fn() &#125; */ var b = 1 /* 开始执行 AO = &#123; arguments: &#123; 0: 1, length: 1 &#125; b: 1 c: fn() &#125; */ function c()&#123; /* 开始执行 AO = &#123; arguments: &#123; &#125; &#125; */ console.log(e, b, d) // 向外层的作用域查询到变量 e, b,d &#125; c()&#125;a(1) 作用域链（Scope Chain）多个变量对象构成的链表则为作用域链（Scope Chain），从离它最近的变量对象（VO）开始查找变量，逐级往上","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"https://luoyuda.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://luoyuda.github.io/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"作用域链","slug":"作用域链","permalink":"https://luoyuda.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"}]},{"title":"排序算法 - 计数排序 （JavaScript实现）","slug":"Sort/count","date":"2022-04-08T08:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/08/Sort/count/","link":"","permalink":"https://luoyuda.github.io/2022/04/08/Sort/count/","excerpt":"","text":"计数排序描述计数排序（Counting sort）是一种稳定的线性时间排序算法。它的复杂度为 Ο(n+k)（其中 k 是整数的范围大小） 基本思想对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。然后顺序输出 实现12345678910111213141516171819202122232425262728293031323334var CountingSort = (arr) =&gt; &#123; // 判空及防止数组越界 if (arr == null || arr.length &lt;= 1) return arr; // 找最大最小 let min = Math.min(...arr) let range = Math.max(...arr) - min + 1 // 建立长度为 range 的数组，下标 0~8 对应数字 1~9 let counting = new Array(range).fill(0) // 遍历 arr 中的每个元素 for (const x of arr) &#123; // 将每个整数出现的次数统计到计数数组中对应下标的位置 counting[x - min] += 1 &#125; // 记录前面比自己小的数字的总数 let preCounts = 0 for (let i = 0; i &lt; counting.length; i++) &#123; // 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。 preCounts += counting[i] // 当前的数字比下一个数字小，累计到 preCounts 中 counting[i] = preCounts - counting[i] &#125; let result = new Array(arr.length) for (const x of arr) &#123; // counting[x - 1] 表示此元素在结果数组中的下标 let index = counting[x - min] result[index] = x // 更新 counting[x - 1]，指向此元素的下一个下标 counting[x-min]+=1 &#125; for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] = result[i] &#125; return arr&#125; 过程分析假如当前输入 [0,2,3,4,1,5,3,1,6,3,6,7,1,2] 找出 max = 7 和 min = 0，生成一个数组 counting = [0, 0, 0, 0, 0, 0, 0, 0] 用于计数 遍历 arr 对每个数进行收集， [1, 3, 2, 3, 1, 1, 2, 1] 记录比自己小的数字的总数 counting = [0, 1, 4, 6, 9, 10, 11, 13] 初始化新数组 [empty × 14]，再遍历 arr x = 0, counting[0] = 0 counting[0]++ result = [0, empty × 13] counting = [1, 1, 4, 6, 9, 10, 11, 13] x = 2, counting[2] = 4 counting[2]++ result = [0, empty × 3, 2, empty × 9] counting = [1, 1, 5, 6, 9, 10, 11, 13] x = 3, counting[3] = 6 counting[3]++ result = [0, empty × 3, 2, empty × 1, 3, empty × 7] counting = [1, 1, 5, 7, 9, 10, 11, 13] x = 4, counting[4] = 9 counting[4]++ result = [0, empty × 3, 2, empty × 1, 3, empty × 2, 4, empty × 4] counting = [1, 1, 5, 7, 10, 10, 11, 13] x = 1, counting[1] = 1 counting[1]++ result = [0, 1, empty × 2, 2, empty × 1, 3, empty × 2, 4, empty × 4] counting = [1, 2, 5, 7, 10, 10, 11, 13] x = 5, counting[5] = 10 counting[5]++ result = [0, 1, empty × 2, 2, empty × 1, 3, empty × 2, 4, 5, empty × 3] counting = [1, 2, 5, 7, 10, 11, 11, 13] x = 3, counting[3] = 7 counting[3]++ result = [0, 1, empty × 2, 2, empty × 1, 3, 3, empty × 1, 4, 5, empty × 3] counting = [1, 2, 5, 8, 10, 11, 11, 13] x = 1, counting[1] = 2 counting[1]++ result = [0, 1, 1, empty × 1, 2, empty × 1, 3, 3, empty × 1, 4, 5, empty × 3] counting = [1, 3, 5, 8, 10, 11, 11, 13] x = 6, counting[6] = 11 counting[6]++ result = [0, 1, 1, empty × 1, 2, empty × 1, 3, 3, empty × 1, 4, 5, 6, empty × 2] counting = [1, 3, 5, 8, 10, 11, 12, 13] x = 3, counting[3] = 8 counting[3]++ result = [0, 1, 1, empty × 1, 2, empty × 1, 3, 3, 3, 4, 5, 6, empty × 2] counting = [1, 3, 5, 9, 10, 11, 13, 13] x = 6, counting[6] = 12 counting[6]++ result = [0, 1, 1, empty × 1, 2, empty × 1, 3, 3, 3, 4, 5, 6, 6, empty × 1] counting = [1, 3, 5, 9, 10, 11, 13, 13] x = 7, counting[6] = 13 counting[7]++ result = [0, 1, 1, empty × 1, 2, empty × 1, 3, 3, 3, 4, 5, 6, 6, 7] counting = [1, 3, 5, 9, 10, 11, 13, 14] x = 1, counting[1] = 3 counting[1]++ result = [0, 1, 1, 1, 2, empty × 1, 3, 3, 3, 4, 5, 6, 6, 7] counting = [1, 4, 5, 9, 10, 11, 13, 14] x = 2, counting[2] = 5 counting[2]++ result = [0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 6, 6, 7] counting = [1, 4, 6, 9, 10, 11, 13, 14] 最后输出数组 [0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 6, 6, 7] 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(n+k) O(n+k) O(n+k) O(n+k) out-place 稳定 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"计数排序","slug":"计数排序","permalink":"https://luoyuda.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"排序算法 - 快速排序 （JavaScript实现）","slug":"Sort/quick","date":"2022-04-08T04:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/08/Sort/quick/","link":"","permalink":"https://luoyuda.github.io/2022/04/08/Sort/quick/","excerpt":"","text":"快速排序描述快速排序借用了分治的思想, 并且基于冒泡排序做了改进。 它将数组拆分为两个子数组, 其中一个子数组的所有元素都比另一个子数组的元素小, 然后对这两个子数组再重复进行上述操作, 直到数组不可拆分, 排序完成。 基本思想 从数组中取出一个数，称之为基数（pivot） 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边 遍历完成后，数组被分成了左右两个区域 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成 实现基本框架 sortArray：入口方法 QuickSort：递归方法，负责不停的划分，直到 p q 指针对撞 partition: 划分函数，根据 pivot 划分区域，然后返回中点，中点右边的值均大于 pivot，左边的值均小于 pivot 12345678910111213141516171819// 排序函数function sortArray(arr)&#123; return QuickSort(arr, 0, arr.length - 1)&#125;// QuickSortfunction QuickSort(arr, p, q)&#123; // 此时排序已完成 if(p &gt;= q) return arr // 通过划分函数获得中点 let m = partition(arr, p, q) // 接着视为两个区域进行递归 QuickSort(arr, p, m - 1) QuickSort(arr, m + 1, q) return arr&#125;// 划分函数function partition(arr, p, q)&#123; // 重点是划分函数的实现&#125; 第一种写法按照基本思想进行 选取一个基准点 pivot, 定义两个指针 i = p, j = p + 1 移动 j 指针找到 比 pivot 小的，移动 i 指针，将其与 i 换位 直到 j &gt; q 之后跳出循环 最后将 p 与 i 进行互换，返回 i 指针 1234567891011121314function partition(arr, p, q)&#123; let pivot = arr[p] let i = p let j = p + 1 while(j &lt;= q)&#123; if(arr[j] &lt; pivot)&#123; i++ swap(arr, i, j) &#125; j++ &#125; swap(arr, i, p) return i&#125; 详细过程 arr = [15, 9, 31, 21, 44, 22, 33, 18, 2] p = 0 q = arr.length - 1 = 8 pivot = arr[0] i = 0 j = 1 开始比对 9 &lt; 15 i++; i = 1 swap(1, 1) arr 不变 31 &gt; 15, 21 &gt; 15, 44 &gt; 15, 22 &gt; 15, 33 &gt; 15, 18 &gt; 15（跳过） 2 &lt; 15 i++; i = 2 swap(2, 8) [15, 9, 2, 21, 44, 22, 33, 18, 31] i = 2, p = 0 swap(0, 2) [2, 9, 15, 21, 44, 22, 33, 18, 31] 返回 i = 2, QuickSort(arr, 0, 1) QuickSort(arr, 3, 8) QuickSort(arr, 0, 1) arr = [2, 9, 15, 21, 44, 22, 33, 18, 31] p = 0 q = 1 i = 0 j = 2 swap(0, 0) 返回 i = 0 , QuickSort(arr, 0, -1)（跳过） QuickSort(arr, 1, 1) （跳过） QuickSort(arr, 3, 8) &#x3D;&gt; partition(arr, 3, 8) [..., 21, 44, 22, 33, 18, 31] i = 3 j = 4 pivot = 21 44 &gt; 21, 22 &gt; 21, 33 &gt; 21 （跳过） 18 &lt; 21 i = 4, j = 7 swap(4, 7) [..., 21, 18, 22, 33, 44, 31] 31 &gt; 21（跳过），i = 4, p = 3, swap(3, 4) [..., 18, 21, 22, 33, 44, 31] 返回 i = 4 QuickSort(arr, 3, 3) （跳过） QuickSort(arr, 5, 8) &#x3D;&gt; partition(arr, 5, 8) [..., 22, 33, 44, 31] i = 5, j = 6 pivot = 22 （跳过） 返回 i = 5 QuickSort(arr, 4, 4) QuickSort(arr, 6, 8) [..., 33, 44, 31] i = 6, j = 7, pivot = 33 44 &gt; 33 （跳过） 31 &lt; 33 i = 7, j = 8 swap(7, 8) [..., 33, 31, 44] i = 7, p = 6 swap(6, 7) [..., 31, 33, 44] 返回 i = 7 QuickSort(arr, 6, 6)（跳过） QuickSort(arr, 8, 8)（跳过） 排序完成 [2, 9, 15, 18, 21, 22, 31, 33, 44] 第二种写法123456789101112131415161718192021222324var partition = (arr, p, q) =&gt; &#123; // 取第一个数为基数 let pivot = arr[p] // 从第二个数开始分区 (i, j) = (p + 1, q) let i = p + 1 // 右边界 let j = q // 相遇时退出循环 while (i &lt; j)&#123; // 找到第一个大于基数的位置 while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++ if(i != j)&#123; // 交换到右分区，使得左边分区都小于或等于基数，右边分区大于或等于基数 swap(arr, i, j) j-- &#125; &#125; // 如果两个指针相等，单独比较 arr[j] pivot if(arr[j] &gt; pivot) j-- // 将基数和中间树交换 swap(arr, p, j) // 返回中间的下标 return j&#125; 详细过程 [31, 15, 18, 22, 33, 21, 44, 2, 9] pivot = 31, i = 1, j = 8 15, 18, 22 &lt; 31 （跳过） 33 &gt; 31 i = 4 j = 8 swap(4, 8) [31, 15, 18, 22, 9, 21, 44, 2, 33] j = 7 9, 21 &lt; 31（跳过） 44 &gt; 31 i = 6 j = 7 swap(6, 7) [31, 15, 18, 22, 9, 21, 2, 44, 33] j = 6 跳出循环 arr[6] = 2 &lt; 31 swap(0, 6) [2, 15, 18, 22, 9, 21, 31, 44, 33] 返回 j = 6 QuickSort(arr, 0, 5) 和 QuickSort(arr, 7, 8) QuickSort(arr, 0, 5) &#x3D;&gt; partition(arr, 0, 5) [2, 15, 18, 22, 9, 21] pivot = 2, i = 1, j = 5 15 &gt; 2 swap(1, 5) &#x3D;&gt; [2, 21, 18, 22, 9, 15] j = 4 21 &gt; 2 swap(1, 4) &#x3D;&gt; [2, 9, 18, 22, 21, 15] j = 3 9 &gt; 2 swap(1, 3) &#x3D;&gt; [2, 22, 18, 9, 21, 15] j = 2 22 &gt; 2 swap(1, 2) &#x3D;&gt; [2, 18, 22, 9, 21, 15] j = 1 跳出循环 arr[1] = 18 &gt; 2 j-- swap(0, 0) 返回 j = 0 QuickSort(arr, 0, -1)（跳过）和 QuickSort(arr, 1, 5) QuickSort(arr, 1, 5) &#x3D;&gt; partition(arr, 1, 5) [18, 22, 9, 21, 15] pivot = 18, i = 2, j = 5 22 &gt; 18 swap(2, 5) &#x3D;&gt; [18, 15, 9, 21, 22] j = 4 15, 9 &lt; 18 （跳过） 21 &gt; 18 此时 i = j = 4 跳出循环 arr[4] = 21 &gt; 18 j-- swap(2, 3) 返回 j = 3 [9, 15, 18, 21, 22] QuickSort(arr, 1, 2)（跳过）和 QuickSort(arr, 4, 5)（跳过） 回到 QuickSort(arr, 7, 8) 交换后完成排序 [2, 9, 15, 18, 21, 22, 31, 33, 44] 第三种写法1234567891011121314151617181920212223var partition = (arr, p, q) =&gt; &#123; // 取第一个数为基数 let pivot = arr[p] // 从第二个数开始分区 let i = p + 1 // 右边界 let j = q // 相遇时退出循环 while (i &lt; j)&#123; // 找到第一个大于基数的位置 while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++ // 找到第一个小于基数的位置 while (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j-- // 交换到右分区，使得左边分区都小于或等于基数，右边分区大于或等于基数 swap(arr, i, j) &#125; // 如果两个指针相等，单独比较 arr[j] pivot if(arr[j] &gt; pivot) j-- // 将基数和中间树交换 swap(arr, p, j) // 返回中间的下标 return j&#125; 详细过程 [22, 2, 18, 31, 33, 9, 15, 44, 21] pivot = 22 i = 1, j = 8 2, 18 &lt; 22 （跳过），31 &gt; 22 i = 3 21 &lt; 22 j = 8 swap(3, 8) [22, 2, 18, 21, 33, 9, 15, 44, 31] 21 &lt; 22（跳过） 33 &gt; 22 i = 4 31, 44 &gt; 22（跳过） 15 &lt; 22 j = 6 swap(4, 6) [22, 2, 18, 21, 15, 9, 33, 44, 31] 15, 9 &lt; 22 跳过，i = 6 j = 6 跳出循环 arr[6] = 33 &gt; 22 j-- swap(0, 5) [9, 2, 18, 21, 15, 22, 33, 44, 31] 返回 j = 5 QuickSort(arr, 0, 4) 和 QuickSort(arr, 6, 8) QuickSort(arr, 0, 4) &#x3D;&gt; partition(arr, 0, 4) [9, 2, 18, 21, 15] pivot = 9, i = 1, j = 4 2 &lt; 9 （跳过） 18 &gt; 9 i = 2 15, 21, 18 &gt; 9 （跳过） j = 2 跳出循环 arr[j] = 18 &gt; 9 j-- swap(0, 1) [2, 9, 18, 21, 15] 返回 j = 1 QuickSort(arr, 0, 0)（跳过） 和 QuickSort(arr, 2, 4) QuickSort(arr, 2, 4) &#x3D;&gt; partition(arr, 2, 4) [18, 21, 15] pivot = 18, i = 3, j = 4 21 &gt; 18 i = 3 15 &lt; 18 j = 4 swap(3, 4) [18, 15, 21] j = 4 跳出循环 arr[4] = 21 &gt; 18 j-- swap(2, 3) [15, 18, 21] 返回 j = 3 QuickSort(arr, 2, 2)（跳过） 和 QuickSort(arr, 4, 4)（跳过） 回到 QuickSort(arr, 6, 8) &#x3D;&gt; partition(arr, 6, 8) [33, 44, 31] pivot = 33, i = 7, j = 8 44 &gt; 33 i = 7 31 &lt; 33 j = 8 swap(7, 8) [33, 31, 44] j = 8 跳出循环 arr[8] &gt; 33 j-- swap(6, 7) [31, 33, 44] 返回 j = 7 QuickSort(arr, 6, 6)（跳过） 和 QuickSort(arr, 8, 8)（跳过） 返回数组 [2, 9, 15, 18, 21, 22, 31, 33, 44] 完成排序 三种方式对比 优化角度分析上面三个版本的实现，我们可以发现，在随机化越高的情况下，快速排序所用的轮次会越少，所以一般我们可以通过打乱数组后进行排序，效率更高 123456789101112131415161718var swap = (arr, i, j) =&gt; &#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125;var randOne = (n, m) =&gt; n + Math.floor(Math.random() * (m - n + 1))var shuffle = (arr) =&gt; &#123; let n = arr.length for (let i = 0; i &lt; n; i++) &#123; let rand = randOne(i, n - 1) swap(arr, i, rand) &#125;&#125;var sortArray = function(arr)&#123; // 排序前先打乱其顺序 shuffle(arr) return QuickSort(arr, 0, arr.length - 1)&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637var sortArray = function(arr)&#123; shuffle(arr) return QuickSort(arr, 0, arr.length - 1)&#125;var QuickSort = (arr, p, q) =&gt; &#123; if(p &gt;= q) return arr let m = partition(arr, p, q) QuickSort(arr, p, m - 1) QuickSort(arr, m + 1, q) return arr&#125;var partition = (arr, p, q) =&gt; &#123; let x = arr[p] let i = p + 1 let j = q while (i &lt; j)&#123; while (i &lt; j &amp;&amp; arr[i] &lt;= x) i++ while (i &lt; j &amp;&amp; arr[j] &gt;= x) j-- swap(arr, i, j) &#125; if(arr[j] &gt;= x) j-- swap(arr, p, j) return j&#125;var swap = (arr, i, j) =&gt; &#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125;var randOne = (n, m) =&gt; n + Math.floor(Math.random() * (m - n + 1))var shuffle = (arr) =&gt; &#123; let n = arr.length for (let i = 0; i &lt; n; i++) &#123; let rand = randOne(i, n - 1) swap(arr, i, rand) &#125;&#125; 再补一个三路快排123456789101112131415161718192021222324// 3路快排 [l,...lt, .. i, ... gt, r]var QuickSort = (arr, l, r) =&gt; &#123; if(l &gt;= r) return arr let x = arr[l] let lt = l let gt = r + 1 let i = l + 1 while(i &lt; gt)&#123; if(arr[i] &lt; x)&#123; swap(arr, i, lt + 1) lt++ i++ &#125;else if(arr[i] &gt; x)&#123; swap(arr, i, gt - 1) gt-- &#125;else&#123; i++ &#125; &#125; swap(arr, lt, l) QuickSort(arr, l, lt -1) QuickSort(arr, gt, r) return arr&#125; 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(nlogn) O(nlogn) O(n^2) O(n) in-place 不稳定 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"快排","slug":"快排","permalink":"https://luoyuda.github.io/tags/%E5%BF%AB%E6%8E%92/"}]},{"title":"排序算法 - 希尔排序 （JavaScript实现）","slug":"Sort/shell","date":"2022-04-07T09:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/07/Sort/shell/","link":"","permalink":"https://luoyuda.github.io/2022/04/07/Sort/shell/","excerpt":"","text":"希尔排序描述希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。 编码实现通过每一轮的调控，让整个数组有序 外层是一个调控增量的循环，gap &gt;&gt;= 1 意味着 gap 每次都缩小一半，相当于除 2 内部是一个插入排序 划分 gap 之后，可以看作是 [0, ... i - gap, i] 的一组数组进行插入排序 随着 gap 的逐渐缩小，最后一轮为 gap = 1 的插入排序时，数组已经实际上基本有序，使用插入排序会得到最高的效率 123456789101112131415var ShellSort = arr =&gt; &#123; let n = arr.length for (let gap = n &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; for (let i = gap; i &lt; n; i++) &#123; let x = arr[i] let j = i - gap while (j &gt;= 0 &amp;&amp; x &lt; arr[j])&#123; arr[j + gap] = arr[j] j -= gap &#125; arr[j + gap] = x &#125; &#125; return arr&#125; 参考动图可以理解的比较直观 优化角度由上可知，增量序列的选择时决定希尔排序效率的关键，如果增量序列每次都无法调整位置，会堆积到最后一趟为 1 的时候大量移动 增量元素不互质，则小增量可能根本不起作用 Knuth 增量序列实现12345678910111213141516171819var ShellSort = arr =&gt; &#123; let n = arr.length let maxGap = 1; while (maxGap &lt;= n / 3) &#123; maxGap = maxGap * 3 + 1; &#125; for (let gap = maxGap; gap &gt; 0; gap = (gap - 1) / 3) &#123; for (let i = gap; i &lt; n; i++) &#123; let x = arr[i] let j = i - gap while (j &gt;= 0 &amp;&amp; x &lt; arr[j])&#123; arr[j + gap] = arr[j] j -= gap &#125; arr[j + gap] = x &#125; &#125; return arr&#125; 对比 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(nlog n) O(nlog2 n) O(nlog2 n) O(1) in-place 不稳定 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"希尔","slug":"希尔","permalink":"https://luoyuda.github.io/tags/%E5%B8%8C%E5%B0%94/"}]},{"title":"排序算法 - 插入排序 （JavaScript实现）","slug":"Sort/Insert","date":"2022-04-07T06:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/07/Sort/Insert/","link":"","permalink":"https://luoyuda.github.io/2022/04/07/Sort/Insert/","excerpt":"","text":"插入排序描述把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的. 编码实现交换法 第一个元素开始，我们可以认为该元素已经被排序 取出 i 元素，在 (0, i) 的区间扫描 假设从 j = i 位置开始往前挪 如果 arr[j - 1] &gt; arr[j]，则需要将 arr[j] 与 arr[j - 1] 交换 重复直到不满足条件 j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j] 12345678910var InsertSort = function(arr)&#123; for (let i = 1; i &lt; arr.length; i++) &#123; let j = i while (j &gt;= 1 &amp;&amp; arr[j - 1] &gt; arr[j])&#123; swap(arr, j, j - 1) j-- &#125; &#125; return arr&#125; 一次插入法 取出第一个元素，默认其有序 从 i = 1 开始遍历，取出 x = arr[i] 往前查找适合的位置后进行插入 比 x 小的值往后移动一位 123456789101112var InsertSort = function(arr)&#123; for (let i = 1; i &lt; arr.length; i++) &#123; let x = arr[i] let j = i - 1 while (j &gt;= 0 &amp;&amp; arr[j] &gt; x)&#123; arr[j + 1] = arr[j] j-- &#125; arr[j + 1] = x &#125; return arr&#125; 折半插入排序折半插入排序是直接插入排序的升级版. 鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可。 折半插入明显的减少了查询的次数，但是数组移动的次数并没有改变，所以时间复杂度还是跟插入排序一致 编码实现 第一个元素开始，我们可以认为该元素已经被排序 取出 x = arr[i] 元素，在 (l, r) 的区间中 取出中间 的下标 m 直到 arr[m] &gt;= x 则将 l 位置往后挪 1 位，反之则将 r 往前挪 1 位 直到 l &lt;= r 时跳出 接下来就需要在 将 (l, i) 中的元素一起往后挪 1 位， 最后在 l 位置插入 x 重复直到外循环结束 123456789101112131415161718192021222324var InsertSort = function(arr)&#123; let n = arr.length for (let i = 1; i &lt; n; i++) &#123; let x = arr[i] let l = 0 let r = i - 1 while(l &lt;= r)&#123; // 二分查找 let m = l + Math.floor((r - l) / 2) if(x &gt;= arr[m])&#123; l = m + 1 &#125;else&#123; r = m - 1 &#125; &#125; // 确定好插入位置后，元素集体往后挪一位 for (let j = i; j &gt; l; j--) &#123; arr[j] = arr[j - 1] &#125; //插入元素 arr[l] = x &#125; return arr&#125; 对比 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(n²) O(n) O(n²) O(1) in-place 稳定 无 输入数组按升序排列 输入数组按降序排列 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"插入","slug":"插入","permalink":"https://luoyuda.github.io/tags/%E6%8F%92%E5%85%A5/"}]},{"title":"排序算法 - 归并排序 （JavaScript实现）","slug":"Sort/merge","date":"2022-04-07T06:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/07/Sort/merge/","link":"","permalink":"https://luoyuda.github.io/2022/04/07/Sort/merge/","excerpt":"","text":"归并排序描述将一个数组分割成 N 个小数组，然后将小数组逐一合并成一个个有序的数组，是分治法的应用 分割：递归对半分割数组 合并：保持元素顺序的同时，将上一步得到的子集合并到一起 编码实现 将数组递归分割，直到只剩下一个元素 逐渐合并两个有序的数组 [6] [10] &#x3D;&gt; [6, 10][13] &#x3D;&gt; [6, 10, 13] 将最后输出的数组结果同步到原数组中 12345678910111213141516171819202122232425262728293031323334353637383940414243var MergeSort = function(arr)&#123; if(!arr.length) return let result = mergeSort(arr, 0 , arr.length - 1) for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] = result[i] &#125; return arr&#125;/** * 二分分割数组 * @param &#123;[Number]&#125; arr * @param &#123;Number&#125; start * @param &#123;Number&#125; end * @returns */var mergeSort = function(arr, start, end)&#123; // 只剩下一个数字，停止拆分 if(start == end) return [arr[start]] let mid = Math.floor((start + end) / 2) let left = mergeSort(arr, start, mid) let right = mergeSort(arr, mid + 1, end) return merge(left, right)&#125;/** * 合并两个有序数组 * @param &#123;[Number]&#125; arr1 * @param &#123;[Number]&#125; arr2 */var merge = function(arr1, arr2)&#123; let result = new Array(arr1.length + arr2.length) let i = 0 let j = 0 while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123; result[i + j] = arr1[i] &lt; arr2[j] ? arr1[i++] : arr2[j++] &#125; while(i &lt; arr1.length)&#123; result[i + j] = arr1[i++] &#125; while(j &lt; arr2.length)&#123; result[i + j] = arr2[j++] &#125; return result&#125; 优化角度优化空间使用只使用一个数组去承载计算的结果 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;*&#125; arr 待排序数组 */var MergeSort = function(arr)&#123; if(!arr.length) return let result = new Array(arr.length) mergeSort(arr, 0 , arr.length - 1, result) return arr&#125;var mergeSort = function(arr, start, end, result)&#123; if(start == end) return let mid = Math.floor((start + end) / 2) mergeSort(arr, start, mid, result) mergeSort(arr, mid + 1, end, result) merge(arr, start, end, result)&#125;var merge = function(arr, start, end, result) &#123; let end1 = Math.floor((start + end) / 2) let start2 = end1 + 1 let end2 = end let index1 = start let index2 = start2 while(index1 &lt;= end1 &amp;&amp; index2 &lt;= end2) &#123; result[index1 + index2 - start2] = arr[index1] &lt;= arr[index2] ? arr[index1++] : arr[index2++] &#125; while(index1 &lt;= end1)&#123; result[index1 + index2 - start2] = arr[index1++] &#125; while(index2 &lt;= end2)&#123; result[index1 + index2 - start2] = arr[index2++] &#125; while(start &lt;= end)&#123; arr[start] = result[start++] &#125; return arr&#125; 算法复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(nlogn) O(nlogn) O(nlogn) O(n) out-place 稳定 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"归并","slug":"归并","permalink":"https://luoyuda.github.io/tags/%E5%BD%92%E5%B9%B6/"}]},{"title":"排序算法 - 选择排序 （JavaScript实现）","slug":"Sort/select","date":"2022-04-07T06:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/07/Sort/select/","link":"","permalink":"https://luoyuda.github.io/2022/04/07/Sort/select/","excerpt":"","text":"选择排序描述选择排序(Selection-sort)是一种简单直观的排序算法。 它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 编码实现 遍历数组，假设第一个为最小值 min = i 遍历 (i, n) 找到最小值的下标 min，最后与 i 进行交换 12345678910111213var SelectSort = (arr) =&gt; &#123; let n = arr.length for (let i = 0; i &lt; n - 1; i++) &#123; let min = i for (let j = i + 1; j &lt; n; j++) &#123; if(arr[j] &lt; arr[min]) &#123; min = j &#125; &#125; swap(arr, i, min) &#125; return arr&#125; 优化角度同时找最小和最大元素双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。找到最大的坐标放在最后一位 遍历数组，找出最大值 max 和最小值 min 交换 min 与 i 判断 i 是否为 max，如果刚好为 i 则由于 i 已经被交换过，max 的值应该是跟 i 交换过后的 min 交换 max 和 n - i - 1 (尾部) 12345678910111213141516171819202122var SelectSort = (arr) =&gt; &#123; let n = arr.length for (let i = 0; i &lt; n &gt;&gt; 1; i++) &#123; let min = i let max = i for (let j = i + 1; j &lt; n - i; j++) &#123; if(arr[j] &lt; arr[min]) &#123; min = j &#125; if(arr[j] &gt; arr[max]) &#123; max = j &#125; &#125; if(arr[min] == arr[max]) break swap(arr, i, min) // 如果最大值的下标刚好是 i， // 由于 arr[i] 和 arr[min] 已经交换了，所以这里要更新 max 的值。 if(i == max) max = min swap(arr, max, n - i - 1) &#125; return arr&#125; 算法复杂度 (稳如狗的时间复杂度) 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(n²) O(n²) O(n²) O(1) in-place 不稳定 对比 跟插入、冒泡相比从图中不难看出，这个排序方法确实很辣鸡啊，无论正序，逆序，随机各种情况下都是很稳定的久（令人泪目） 网站地址 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"选择","slug":"选择","permalink":"https://luoyuda.github.io/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"排序算法 - 冒泡排序 （JavaScript实现）","slug":"Sort/bubble","date":"2022-04-07T03:35:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/07/Sort/bubble/","link":"","permalink":"https://luoyuda.github.io/2022/04/07/Sort/bubble/","excerpt":"","text":"冒泡排序描述冒泡排序是一种简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 编码实现简单来说，冒泡排序就是通过比较相邻元素，交换两个元素位置针对所有的元素作同样的工作之后，排序就完成了 首先用一个外循环来循环数组的所有元素 然后将当前循环到的元素与其他元素比较换位 123456789101112131415161718192021222324252627282930313233function swap(i,j,arr)&#123; var temp = arr[j] arr[j] = arr[i] arr[i] = temp&#125;var bubbleSort = (arr) =&gt; &#123; let n = arr.length for (let i = 0; i &lt; n - 1; i++) &#123; //外循环 看目前排了几个有序的元素 let position = n - 1 - i for (let j = 0; j &lt; position; j++) &#123; // 内循环比较其他元素 // 每次走完这个循环之后，就会有一个元素被冒到 position 的位置 // (position, n) 有序的区间 // 而我们要接着走的是 (0, position) 这个无序的区间 if(arr[j] &gt; arr[j + 1])&#123; swap(arr, j, j + 1) &#125; &#125; /* 当然也可以这样写 let j = 0 while (j &lt; position) &#123; if(arr[j] &gt; arr[j + 1])&#123; swap(arr, j, j + 1) &#125; j++ &#125; */ &#125; return arr&#125; 复杂度 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 O(n²) O(n) O(n²) O(1) in-place 稳定 无 当输入的数据已经是正序时 当输入的数据是反序时 优化角度某一趟未交换时可提前退出123456789101112131415var bubbleSort = arr =&gt; &#123; let n = arr.length let swapped = true for (let i = 0; i &lt; n - 1; i++) &#123; if(!swapped) break swapped = false for (let j = 0; j &lt; n - i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1])&#123; swap(arr, j, j + 1) swapped = true &#125; &#125; &#125; return arr&#125; 记录最后一次交换位置1234567891011121314151617var bubbleSort = arr =&gt; &#123; let lastIndex = arr.length - 1 let swapped = true let swappedIndex = 0 while (swapped)&#123; swapped = false for (let i = 0; i &lt; lastIndex; i++) &#123; if(arr[i] &gt; arr[i + 1])&#123; swap(arr, i, i + 1) swapped = true swappedIndex = i &#125; &#125; lastIndex = swappedIndex &#125; return arr&#125; 双向冒泡排序描述双向冒泡排序是冒泡排序的一个简易升级版，其原理是从两个方向分别排序，第一轮找出最大的放在后面，第二轮找出最小的放在前面，通过逐渐缩短查找范围的方式，因此性能会比冒泡排序好一点 编码实现首先它既然是从两个方向查找的，我们需要定义前后两个下标变量，方便我们来定位当前的查找区间，并且在每一次查找之后需要缩短查找的范围 * 123456789101112131415161718192021222324252627282930var bubbleSort = arr =&gt; &#123; let low = 0 let high = arr.length - 1 let pos, i while (low &lt; high) &#123; //当 low &gt;= high 的时候，双向的区间都已经有序，则跳出循环 i = low while (i &lt; high) &#123; //第一轮 从(low, high) 区间开始 查找最大的放在 high 位 if(arr[i] &gt; arr[i + 1])&#123; swap(arr, i, i + 1) pos = i &#125; i++ &#125; //第一轮 从(low, pos) 区间开始 i = high = pos while (i &gt; low) &#123; //第二轮 从(low, pos) 区间开始 查找最大的放在 low 位 if(arr[i] &lt; arr[i - 1])&#123; swap(arr, i, i - 1) pos = i &#125; i-- &#125; // low逐渐变大 high逐渐变小 low = pos &#125; return arr&#125; 对比图 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"冒泡","slug":"冒泡","permalink":"https://luoyuda.github.io/tags/%E5%86%92%E6%B3%A1/"}]},{"title":"深浅拷贝实现（JavaScript）","slug":"JavaScript/clone","date":"2022-04-05T06:00:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2022/04/05/JavaScript/clone/","link":"","permalink":"https://luoyuda.github.io/2022/04/05/JavaScript/clone/","excerpt":"","text":"数据类型在了解深、浅拷贝之前，得先了解 JavaScript 中的数据类型和存储方式 基本类型：number、string、boolean、null、undefined、symbol 存储在栈内存中 大小固定、体积轻量、相对简单 赋值操作会直接生成一个新的值（深拷贝） 引用类型：object、array、function等 栈存储该对象的引用地址，实际数据存放在堆内存 大小不定、占用空间较大、比较复杂 赋值操作会直接将指针指向该实体的引用地址（处于节省内存考虑，属于浅拷贝） 深浅拷贝定义 浅拷贝：复制某个对象的指针地址，而不是复制对象本身，新旧对象依然共享一块内存 深拷贝：创造一个一模一样的对象，新对象与原对象不共享内存，修改新对象不影响到原对象 浅拷贝Arrayslice()123456789function cloneArrayBySlice(list)&#123; return list.slice()&#125;var arr = [1, 2, &#123; name: &#x27;xy&#x27; &#125;]var arrClone = cloneArrayBySlice(arr)arr[0] = 2arrClone[0] = 3arrClone[2].name = &#x27;change&#x27; // 引用类型是浅拷贝地址console.log(arr, arrClone) // [ 2, 2, &#123; name: &#x27;change&#x27; &#125; ] [ 3, 2, &#123; name: &#x27;change&#x27; &#125; ] concat123function cloneArrayByConcat(list)&#123; return [].concat(list)&#125; spread123function cloneArrayBySpread(list)&#123; return [...list]&#125; Objectassign值得注意的是 assign 接受第一个入参为 target 后续的参数为混入到 target 上，所以也算一种浅拷贝吧（勉强） 123function assign(obj)&#123; return Object.assign(obj)&#125; 深拷贝assign为什么这里还能出现在这个？ Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象 12var a = &#123; a: 1 &#125;var b = Object.assign(&#123;&#125;, a) // 此时是将 a 混入到 &#123;&#125; 对象上，所以 a != b 当然它只要超过值是引用类型还是执行浅拷贝 123var a = &#123; a: 1, b: &#123; b : 2 &#125; &#125;var b = Object.assign(&#123;&#125;, a)a.b === b.b JSON.parse这个方法的原理是将对象序列化成字符串，再解析 json 字符串解析为对象 123function clone(obj)&#123; return JSON.parse(JSON.stringify(obj))&#125; 缺点 忽略 symbol undefined function 类型 不支持循环引用对象的拷贝 MessageChannelChannel Messaging API的 MessageChannel 接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据 123var &#123; port1, port2 &#125; = new MessageChannel()port1.onmessage = e =&gt; console.log(e.data)port2.postMessage(&#x27;hello from port2&#x27;) // hello from port2 1234567function clone(obj)&#123; return new Promise((res, rej) =&gt; &#123; const &#123; port1, port2 &#125; = new MessageChannel() port1.onmessage = e =&gt; res(e.data) port2.postMessage(obj) &#125;)&#125; 缺点 异步取值 不支持 function 和 symbol 类型 递归遍历使用递归去创建对象，再赋值，可以处理大部分场景 123456789101112function clone(obj) &#123; if(!obj) return null var target = Array.isArray(obj) ? [] : &#123;&#125; for(var key in obj)&#123; if(typeof obj[key] === &#x27;object&#x27;)&#123; target[key] = clone(obj[key]) &#125;else&#123; target[key] = obj[key] &#125; &#125; return target&#125; 缺点 不支持循环引用 处理循环引用的解决方案使用 WeakMap 数据结构存储循环引用的映射关系 123456789101112131415161718192021function clone(obj)&#123; var map = new WeakMap() function _clone(obj)&#123; var val = map.get(obj) if(val) return val var target = obj instanceof Array ? [] : &#123;&#125; map.set(obj, target) for (const key in obj) &#123; if (Object.hasOwnProperty.call(obj, key)) &#123; const el = obj[key]; if(el &amp;&amp; typeof el === &#x27;object&#x27;) &#123; target[key] = _clone(el) &#125;else&#123; target[key] = el &#125; &#125; &#125; return target &#125; return _clone(obj)&#125; 测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const &#123; clone &#125; = require(&#x27;./clone.js&#x27;)const runTests = (tests, message) =&gt; &#123; describe(message, function() &#123; tests.forEach(([args, res], i) =&gt; &#123; test(`$&#123;i&#125;`, () =&gt; &#123; expect(clone(args)).toEqual(args) &#125;); &#125;) &#125;)&#125;const Tests = [ &#123; tests: [ [ (function () &#123; var a = &#123; a: 1, b: &#x27;1&#x27;, c: true, d: false, e: null, f: undefined, g: function()&#123;&#125;, h: Symbol(&#x27;b&#x27;), i: [ 1, &#x27;1&#x27;, true, false, null, undefined, function()&#123;&#125;, &#123; a: 1, b: &#x27;1&#x27;, c: true, d: false, e: null, f: undefined, g: function()&#123;&#125;, h: Symbol(&#x27;b&#x27;), &#125;, [1, &#x27;1&#x27;, true, false, null, undefined, function()&#123;&#125;] ], j: &#123; a: 1, b: &#x27;1&#x27;, c: true, d: false, e: null, f: undefined, g: function()&#123;&#125;, h: Symbol(&#x27;b&#x27;), i: [ 1, &#x27;1&#x27;, true, false, null, undefined, function()&#123;&#125;, &#123; a: 1, b: &#x27;1&#x27;, c: true, d: false, e: null, f: undefined, g: function()&#123;&#125;, h: Symbol(&#x27;b&#x27;), &#125; ] &#125;, &#125; return &#123; ...a, a &#125; &#125;)() ], ], message: &#x27;number&#x27; &#125;]Tests.forEach((&#123;tests, message&#125;) =&gt; runTests(tests, message)) 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://luoyuda.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://luoyuda.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"飘忽不定的 this 与 call / apply / bind / new （JavaScript）","slug":"JavaScript/this","date":"2022-04-05T06:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/05/JavaScript/this/","link":"","permalink":"https://luoyuda.github.io/2022/04/05/JavaScript/this/","excerpt":"","text":"thisJavaScript 作为一个语言，有着一堆怪异的表现，最耀眼的那颗星必是 this 关键字 为什么会出现 this123456var a = &#123; b: function()&#123; console.log(this.d) &#125;, d: 1&#125; 根据我们对于基本数据类型与引用数据类型的理解，这里的 value 储存的实际上是什么？ 它实际上应该是一个存储在 栈内存 中的 内存地址，指向 堆内存 中的 函数主体 这时候如果有一个新的对象 1234var c = &#123; b: a.b, d: 2&#125; 那问题来了，函数允许在不同的上下文中执行 我要打印对象上的 d，需要有一个可以指代执行环境的关键字，这时候 this 就产生了 所以 this 本质上是获取内部执行环境(context)的一种机制，所以 this 的值是函数内部执行环境初始化时才决定，且不能进行更改 如何确定 this 的值this 指向调用该函数的对象，储存着调用该函数对象的值。也就是说，搞清由谁调用了这个函数，就能准确的找到 this 指向哪个对象 12345// 接上a.b() // a对象上调用了bc.b() // c对象上调用了cvar e = c.b // 这里实际上是使用一个 e 变量存储了 b 函数的引用地址！e() // 这里是谁调用了 b ？ this 的指向规则默认绑定 (b() / (b = b)() / (b || b)() / (b, b)() ...)默认绑定是指函数作为独立函数调用时，this 指向全局对象 window (严格模式下是 undefined) 12345678910111213141516var c = &#x27;window&#x27;var a = &#123; b:function()&#123; console.log(this.c) &#125;, c: &#x27;a&#x27;&#125;var d = a.b;d();// 赋值时导致隐形丢失((a.b, a.b))();((a.b = a.b))(); ((a.b || a.b))();((a.b &amp;&amp; a.b))();setTimeout(a.b);setInterval(a.b, 1000); new绑定 new 来调用 foo() 时，我们会构造一个新对象并把它绑定到 foo() 调用中的 this 上 隐式绑定 (a.b)函数的调用是在某个对象上触发的，即调用位置上存在上下文对象，a.b()，绑定 a 12345678910111213141516var c = &#x27;window&#x27;var a = &#123; b:function()&#123; console.log(this.c) &#125;, c: &#x27;a&#x27;, d: &#123; b:function()&#123; console.log(this.c) &#125;, c: &#x27;d&#x27; &#125;&#125;a.b() // aa.d.b() // d 就近 显示绑定 (call / apply / bind)通过 call , apply , bind 的方式，显式的指定 this 所指向的对象 12345678910111213141516171819var c = &#x27;window&#x27;function b()&#123; console.log(this.c)&#125;var a = &#123; c: &#x27;a&#x27;&#125;var d = &#123; c: &#x27;d&#x27;&#125;var e = &#123; c: &#x27;e&#x27;&#125;b() // windowb.call(a) // ab.apply(d) // db.bind(e)() // e call / apply 模拟实现使用一个指定的 this 值调用某个函数 将函数设为对象属性 执行函数 删除该对象属性123456789101112Function.prototype.newCall = function()&#123; if(typeof this !== &#x27;function&#x27;) throw new Error(&#x27;no function&#x27;) var context = arguments[0] || window context.fn = this var args = [] for(var i = 1; i &lt; arguments.length; i++)&#123; args.push(arguments[i]) &#125; var result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) delete context.fn return result&#125; 123456789Function.prototype.newApply = function()&#123; if(typeof this !== &#x27;function&#x27;) throw new Error(&#x27;no function&#x27;) var context = arguments[0] || window context.fn = this var args = arguments[1] || [] var result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;) delete context.fn return result&#125; bind 模拟实现创建一个新函数，使用第一个参数作为运行新函数的 this 其他参数作为新函数的入参 取出入参 新建一个函数 F() 作为参数返回值 创建一个 函数 f() f.prototype = this.prototype F.prototype = new f() 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 函数调用的时候，新传入的参数跟之前提取的参数合并为一个数组 self.apply( this instanceof F ? this : context, arg ) ‘是否 new 调用’, this instanceof fBound&quot;1234567891011121314151617Function.prototype.newBind = function()&#123; if(typeof this !== &#x27;function&#x27;) throw new Error(&#x27;no function&#x27;) var context = arguments[0] || window var fn = this var F = function()&#123;&#125; var args = [] for(let i = 1; i &lt; arguments.length; i++) args.push(arguments[i]) var bind = function()&#123; for(let i = 0; i &lt; arguments.length; i++) args.push(arguments[i]) context = this instanceof bind ? this : context return fn.apply(context, args) &#125; F.prototype = this.prototype bind.prototype = new F() bind.prototype.constructor = bind return bind&#125; new 操作符绑定 (new b())new 来调用 b() 时，会构造一个新对象并把它绑定到 foo() 调用中的 this 上 12345function b(a)&#123; this.a = a&#125;console.log(new b(1).a) // 1 new 模拟实现创建一个用户定义的对象类型实例 先从 Object.prototype 克隆一个对象 obj Construtor 是外部传入的构造器 obj.__proto__ = Construtor.prototype ret = Construtor.apply(O, arguments) 借用构造器给 obj 设置属性 ret || obj 总是返回一个对象 1234567function New()&#123; var obj = new Object(); var Constructor = Array.prototype.shift.call(arguments) obj.__proto__ = Constructor.prototype let ret =Constructor.apply(obj, arguments) return typeof ret === &#x27;object&#x27; ? ret : obj&#125; 绑定优先级new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 按规则判断 this 指向 是否 new 调用 是否 call、apply、bind 显性绑定 是否是当作某个对象方法调用 其余的都是用默认绑定 箭头函数的 this1234567891011121314var a = () =&gt; &#123; console.log(this)&#125;var b = &#123; c: () =&gt; &#123; console.log(this) &#125;, d()&#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125; babel 编译后，指向就浅而易见了 1234567891011121314151617181920&quot;use strict&quot;;var _this = void 0;var a = function a() &#123; console.log(_this);&#125;;var b = &#123; c: function c() &#123; console.log(_this); &#125;, d: function d() &#123; var _this2 = this; return function () &#123; console.log(_this2); &#125;; &#125;&#125;; 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"this","slug":"this","permalink":"https://luoyuda.github.io/tags/this/"},{"name":"call / apply","slug":"call-apply","permalink":"https://luoyuda.github.io/tags/call-apply/"},{"name":"bind","slug":"bind","permalink":"https://luoyuda.github.io/tags/bind/"},{"name":"new","slug":"new","permalink":"https://luoyuda.github.io/tags/new/"}]},{"title":"如何实现一个全等函数（JavaScript）","slug":"JavaScript/eq","date":"2022-04-04T07:00:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2022/04/04/JavaScript/eq/","link":"","permalink":"https://luoyuda.github.io/2022/04/04/JavaScript/eq/","excerpt":"","text":"如何才算相等参（chao）考（xi）underscore 的实现 测试用例虽然函数还没完成，但是得先把饼画出去，不然怎么招商引资？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197const &#123; eq &#125; = require(&#x27;./eq.js&#x27;)const runTests = (tests, message) =&gt; &#123; describe(message, function() &#123; tests.forEach(([args, res], i) =&gt; &#123; let argMsg = &#x27;&#x27; try &#123; argMsg = args.toString() &#125; catch (error) &#123; &#125; test(`$&#123;i&#125;-$&#123;argMsg&#125;`, () =&gt; &#123; expect(eq(...args)).toEqual(res) &#125;); &#125;) &#125;)&#125;const Tests = [ &#123; tests: [ [[0, 0], true], [[0, -0], false], [[1, 1], true], [[-1, 1], false], [[-1, -1], true], [[1, new Number(1)], true], [[-1, new Number(-1)], true], [[NaN, NaN], true], [[NaN, 1], false], [[&#x27;1&#x27;, 1], false], [[true, 1], false], [[false, 1], false], [[null, 1], false], [[&#123;&#125;, 1], false], [[[], 1], false], [[function()&#123;&#125;, 1], false], [[undefined, 1], false], [[new String(1), 1], false], [[new Boolean(1), 1], false], [[new String(&#x27;1&#x27;), 1], false], [[new Boolean(true), 1], false], ], message: &#x27;number&#x27; &#125;, &#123; tests: [ [[&#x27;&#x27;, &#x27;&#x27;], true], [[&#x27;1&#x27;, &#x27;&#x27;], false], [[&#x27;1&#x27;, &#x27;1&#x27;], true], [[true, &#x27;&#x27;], false], [[false, &#x27;&#x27;], false], [[-1, &#x27;-1&#x27;], false], [[1, &#x27;1&#x27;], false], [[NaN, &#x27;NaN&#x27;], false], [[new String(&#x27;NaN&#x27;), &#x27;NaN&#x27;], true], [[&#123;&#125;, &#x27;&#x27;], false], [[[], &#x27;&#x27;], false], [[function()&#123;&#125;, &#x27;&#x27;], false], [[null, &#x27;&#x27;], false], [[undefined, &#x27;&#x27;], false], [[new Boolean(&#x27;1&#x27;), &#x27;1&#x27;], false], [[new Boolean(true), &#x27;1&#x27;], false], ], message: &#x27;string&#x27; &#125;, &#123; tests: [ [[/a/, /a/], true], [[/a/ig, /a/], false], [[/a/, new RegExp(&#x27;a&#x27;)], true], [[/a/i, new RegExp(&#x27;a&#x27;, &#x27;i&#x27;)], true], [[/a/ig, new RegExp(&#x27;a&#x27;, &#x27;ig&#x27;)], true], ], message: &#x27;RegExp&#x27; &#125;, &#123; tests: [ [[new Boolean(true), new Boolean(true)], true], [[new Boolean(false), new Boolean(true)], false], [[true, true], true], [[true, false], false], [[true, new Boolean(true)], true], [[false, new Boolean(false)], true], [[true, new Boolean(false)], false], [[undefined, new Boolean(false)], false], [[null, new Boolean(false)], false], [[[], new Boolean(false)], false], [[&#123;&#125;, new Boolean(false)], false], [[function()&#123;&#125;, new Boolean(false)], false], [[new String(&#x27;false&#x27;), new Boolean(false)], false], [[new Number(&#x27;false&#x27;), new Boolean(false)], false], ], message: &#x27;boolean&#x27; &#125;, &#123; tests: [ [[undefined, null], false], [[undefined, undefined], true], [[null, null], true], [[new Boolean(null), null], false], [[new String(null), null], false], [[new Number(null), null], false], [[new Boolean(undefined), undefined], false], [[new String(undefined), undefined], false], [[new Number(undefined), undefined], false], [[[], undefined], false], [[&#123;&#125;, undefined], false], [[function()&#123;&#125;, undefined], false], [[0, undefined], false], [[&#x27;&#x27;, undefined], false], [[&#x27;0&#x27;, undefined], false], [[0, null], false], [[&#x27;&#x27;, null], false], [[&#x27;0&#x27;, null], false], [[NaN, null], false], [[NaN, undefined], false], ], message: &#x27;undefined null&#x27; &#125;, &#123; tests: (function() &#123; var s1 = Symbol.for(1) var s2 = Symbol.for(1); return [ [[Symbol(1), Symbol(1)], false], [[Symbol(&#x27;1&#x27;), Symbol(&#x27;1&#x27;)], false], [[Symbol(&#x27;1&#x27;), Symbol(1)], false], [[s1, s2], true], ] &#125;)(), message: &#x27;Symbol&#x27; &#125;, &#123; tests: (function() &#123; var f1 = function()&#123;&#125; var f2 = () =&gt; &#123;&#125;; return [ [[f1, function()&#123;&#125;], false], [[f2, () =&gt; &#123;&#125;], false], [[f1, f1], true], [[f2, f2], true], [[f2, f1], false], ] &#125;)(), message: &#x27;function&#x27; &#125;, &#123; tests: [ [[new Date(), new Date()], true], [[new Date(), new Date(1)], false], ], message: &#x27;date&#x27; &#125;, &#123; tests: (function() &#123; function A(a)&#123; this.a = a &#125; function B(a)&#123; this.a = a &#125; var a = new A(1) var b = new A(1) var d = new A(2) var c = new B(2) var e = &#123; a: 1, e &#125; var f = &#123; a: 1, f &#125; var g = &#123; a: 1, f &#125; return [ [[a, b], true], [[a, c], false], [[a, d], false], [[&#123;&#125;, []], false], [[&#123;&#125;, &#123;&#125;], true], [[&#123;a: 1&#125;, &#123;a: 1&#125;], true], [[&#123;a: 2&#125;, &#123;a: 1&#125;], false], [[&#123;a: 1, b: &#123;c : 1, d: 2&#125;&#125;, &#123;a: 1, b: &#123;c : 1, d: 2, &#125;&#125;], true], [[[&#123;a: 1, b: &#123;c : 1, d: 2&#125;&#125;], [&#123;a: 1, b: &#123;c : 1, d: 2, &#125;&#125;]], true], [[&#123;a: 1, b: &#123;c : 1, d: 2&#125;&#125;, &#123;a: 1, b: &#123;c : 1, d: 2, e:1 &#125;&#125;], false], [[e, f], true], [[e, g], true], [[[1,2,3], [1,2,3]], true], ] &#125;)(), message: &#x27;object&#x27; &#125;]Tests.forEach((&#123;tests, message&#125;) =&gt; runTests(tests, message)) 开始写 eq 函数1234567function eq(a, b)&#123; &#125;module.exports = &#123; eq&#125; 基本类型比较部分12345678910111213function eq(a, b)&#123; // 处理 -0 和 +0 的情况和相同的基本类型的比较 if(a === b) return a !== 0 || 1 / a === 1 / b // 处理 NaN if(a !== a) return b !== b // 处理 null 的情况 if(a == null || b == null) return false // 过滤 a 或 b 中存在一个基本类型的情况 var type = typeof a if(type !== &#x27;function&#x27; &amp;&amp; type !== &#x27;object&#x27; &amp;&amp; typeof b !== &#x27;object&#x27;) return false // 开始对象类型的比较 return deepEqual(a, b)&#125; 这里主要着重处理了 -0 和 NaN 的情况 -0 &amp; 0这个显然是不相等的，但是在JavaScript中是相等的 真的要研究为什么会有 -0 是因为底层存储使用的是带符号位的二进制存储 number 类型，-0 则是符号位为 10 的情况，+0 则为 00，符号位为 0 对象类型该如何比较？1234567891011121314function deepEqual(a, b) &#123; var typeA = Object.prototype.toString.call(a) var typeB = Object.prototype.toString.call(b) // 类型都不一样，没法相爱 if(typeA !== typeB) return false // 通过隐式类型转换处理为基本类型再比较 switch(typeA) &#123; // 处理 Number() new Number() 的情况 case &#x27;[object Number]&#x27;: // + new Number(1) === + new Number(1).valueOf() if(+a !== +a) return +b !== +b if(+a === +b) return 1 / a === 1 / b &#125;&#125; 此时已经通过 number 的测试用例辣 接着处理 new String() 和 new RegExp() 这种情况 12345678910111213141516171819function deepEqual(a, b) &#123; var typeA = Object.prototype.toString.call(a) var typeB = Object.prototype.toString.call(b) // 类型都不一样，没法相爱 if(typeA !== typeB) return false // 通过隐式类型转换处理为基本类型再比较 switch(typeA) &#123; // 处理 Number() new Number() 的情况 case &#x27;[object Number]&#x27;: // + new Number(1) === + new Number(1).valueOf() if(+a !== +a) return +b !== +b if(+a === +b) return 1 / a === 1 / b case &#x27;[object RegExp]&#x27;: case &#x27;[object String]&#x27;: // &#x27;&#x27; + new RegExp() === &#x27;&#x27; + new RegExp().toString() // &#x27;&#x27; + new String() === &#x27;&#x27; + new String().toString() return &#x27;&#x27; + a === &#x27;&#x27; + b &#125;&#125; 以同样的思路处理 new Boolean() 和 new Date() 的情况 顺手处理下 Symbol 类型 123456789101112131415161718192021222324function deepEqual(a, b) &#123; var typeA = Object.prototype.toString.call(a) var typeB = Object.prototype.toString.call(b) // 类型都不一样，没法相爱 if(typeA !== typeB) return false // 通过隐式类型转换处理为基本类型再比较 switch(typeA) &#123; // 处理 Number() new Number() 的情况 case &#x27;[object Number]&#x27;: // + new Number(1) === + new Number(1).valueOf() if(+a !== +a) return +b !== +b if(+a === +b) return 1 / a === 1 / b case &#x27;[object RegExp]&#x27;: case &#x27;[object String]&#x27;: // &#x27;&#x27; + new RegExp() === &#x27;&#x27; + new RegExp().toString() // &#x27;&#x27; + new String() === &#x27;&#x27; + new String().toString() return &#x27;&#x27; + a === &#x27;&#x27; + b case &#x27;[object Boolean]&#x27;: case &#x27;[object Date]&#x27;: return +a === +b case &#x27;[object Symbol]&#x27;: return Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b) &#125;&#125; 处理 function 12345678... // 到这里还剩下三种类型，Array || Object || function var isArray = typeA === &#x27;[object Array]&#x27;; if(!isArray) &#123; // 这里过滤 function 类型 if(typeof a !== &#x27;object&#x27;) return false &#125;... 1234567891011121314151617181920// 到这里还剩下三种类型，Array || Object || functionvar isArray = typeA === &#x27;[object Array]&#x27;;if(!isArray) &#123; // 这里过滤 function 类型 if(typeof a !== &#x27;object&#x27;) return false // 这里需要判断对象类型是否是同一个构造器 var aCtor = a.constructor var bCtor = b.constructor if( aCtor !== bCtor &amp;&amp; typeof aCtor !== &#x27;function&#x27; &amp;&amp; aCtor instanceof aCtor &amp;&amp; typeof bCtor !== &#x27;function&#x27; &amp;&amp; bCtor instanceof bCtor &amp;&amp; (&#x27;constructor&#x27; in a &amp;&amp; &#x27;constructor&#x27; in b) )&#123; return false &#125;&#125;// 到这里已经是要么是数组，要么是同类型的实例对象 接下去该怎么对数组&#x2F;对象的每一项进行比较呢？显然得考虑深度问题，所以得引入递归 1234567891011function eq(a, b, aStack, bStack) &#123; ... return deepEqual(a, b, aStack, bStack)&#125;function deepEqual(a, b, aStack, bStack) &#123; ... // 到这里已经是要么是数组，要么是同类型的实例对象 aStack = aStack || [] bStack = bStack || []&#125; 通过递归每一项去比对，通过栈来管理深度问题 1234567891011121314151617181920212223242526272829303132333435// 到这里已经是要么是数组，要么是同类型的实例对象aStack = aStack || []bStack = bStack || []// 优先处理循环引用的问题var len = aStack.lengthwhile (len--) &#123; if(aStack[len] === a) return bStack[len] === b&#125;// 不存在循环引用，将a b 分别入栈aStack.push(a)bStack.push(b)if(isArray)&#123; var len = a.length // 个数不同，不能恋爱 if(len !== b.length) return false while(len--)&#123; // 详细对每一项进行比对 if(!eq(a[len], b[len], aStack, bStack)) return false &#125;&#125;else&#123; // 这里偷懒用 Object.keys var keys = Object.keys(a) var len = keys.length // 个数不同，不能恋爱 if(len !== Object.keys(b).length) return false while(len--)&#123; // 详细对每一项进行比对 if(!eq(a[keys[len]], b[keys[len]], aStack, bStack)) return false &#125;&#125;// 比对结束了，记得出栈！aStack.pop()bStack.pop()// 大功告成return true 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * * @param &#123;any&#125; a * @param &#123;any&#125; b * @param &#123;[]&#125; aStack * @param &#123;[]&#125; bStack * @returns Boolean */function eq(a, b, aStack, bStack) &#123; // 处理 -0 和 +0 的情况和相同的基本类型的比较 if(a === b) return a !== 0 || 1 / a === 1 / b // 处理 NaN if(a !== a) return b !== b // 处理 null 的情况 if(a == null || b == null) return false // 过滤 a 或 b 中存在一个基本类型的情况 var type = typeof a if(type !== &#x27;function&#x27; &amp;&amp; type !== &#x27;object&#x27; &amp;&amp; typeof b !== &#x27;object&#x27;) return false // 开始对象类型的比较 return deepEqual(a, b, aStack, bStack)&#125;/** * * @param &#123;any&#125; a * @param &#123;any&#125; b * @param &#123;[]&#125; aStack * @param &#123;[]&#125; bStack * @returns Boolean */function deepEqual(a, b, aStack, bStack) &#123; var typeA = Object.prototype.toString.call(a) var typeB = Object.prototype.toString.call(b) // 类型都不一样，没法相爱 if(typeA !== typeB) return false // 通过隐式类型转换处理为基本类型再比较 switch(typeA) &#123; // 处理 Number() new Number() 的情况 case &#x27;[object Number]&#x27;: // + new Number(1) === + new Number(1).valueOf() if(+a !== +a) return +b !== +b if(+a === +b) return 1 / a === 1 / b case &#x27;[object RegExp]&#x27;: case &#x27;[object String]&#x27;: // &#x27;&#x27; + new RegExp() === &#x27;&#x27; + new RegExp().toString() // &#x27;&#x27; + new String() === &#x27;&#x27; + new String().toString() return &#x27;&#x27; + a === &#x27;&#x27; + b case &#x27;[object Boolean]&#x27;: case &#x27;[object Date]&#x27;: return +a === +b case &#x27;[object Symbol]&#x27;: return Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b) break; &#125; // 到这里还剩下三种类型，Array || Object || function var isArray = typeA === &#x27;[object Array]&#x27;; if(!isArray) &#123; // 这里过滤 function 类型 if(typeof a !== &#x27;object&#x27;) return false // 这里需要判断对象类型是否是同一个构造器 var aCtor = a.constructor var bCtor = b.constructor if( aCtor !== bCtor &amp;&amp; typeof aCtor !== &#x27;function&#x27; &amp;&amp; aCtor instanceof aCtor &amp;&amp; typeof bCtor !== &#x27;function&#x27; &amp;&amp; bCtor instanceof bCtor &amp;&amp; (&#x27;constructor&#x27; in a &amp;&amp; &#x27;constructor&#x27; in b) )&#123; return false &#125; &#125; // 到这里已经是要么是数组，要么是同类型的实例对象 aStack = aStack || [] bStack = bStack || [] // 优先处理循环引用的问题 var len = aStack.length while (len--) &#123; if(aStack[len] === a) return bStack[len] === b &#125; // 不存在循环引用，将a b 分别入栈 aStack.push(a) bStack.push(b) if(isArray)&#123; var len = a.length // 个数不同，不能恋爱 if(len !== b.length) return false while(len--)&#123; // 详细对每一项进行比对 if(!eq(a[len], b[len], aStack, bStack)) return false &#125; &#125;else&#123; // 这里偷懒用 Object.keys var keys = Object.keys(a) var len = keys.length // 个数不同，不能恋爱 if(len !== Object.keys(b).length) return false while(len--)&#123; // 详细对每一项进行比对 if(!eq(a[keys[len]], b[keys[len]], aStack, bStack)) return false &#125; &#125; // 比对结束了，记得出栈！ aStack.pop() bStack.pop() // 大功告成 return true&#125;module.exports = &#123; eq&#125; 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"全等","slug":"全等","permalink":"https://luoyuda.github.io/tags/%E5%85%A8%E7%AD%89/"}]},{"title":"去重到底有多少种写法？（JavaScript）","slug":"JavaScript/unique","date":"2022-04-02T07:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/02/JavaScript/unique/","link":"","permalink":"https://luoyuda.github.io/2022/04/02/JavaScript/unique/","excerpt":"","text":"测试用例在写代码之前写一组测试（使用 Jest ），这有利于我们每次修改后完善代码，我们先写一个对基本类型进行去重的版本（忽略 NaN） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const &#123; unique &#125; = require(&#x27;./unique.1.js&#x27;)describe(&#x27;unique&#x27;, function() &#123; var genArray = (len, cb) =&gt; new Array(len).fill(0).map(cb) var genNumbers = (gap, len = 20) =&gt; genArray(len, (el, i) =&gt; i % gap) var genStrings = (gap, len = 20) =&gt; genArray(len, (el, i) =&gt; (i % gap) + &#x27;&#x27;) var genBooleans = (gap, len = 4) =&gt; genArray(len, (el, i) =&gt; (i % gap) === 1) var genUndefined = (len = 4) =&gt; genArray(len, () =&gt; void 0) var genNull = (len = 4) =&gt; genArray(len, () =&gt; null) var tests = [ &#123; message: &#x27;numbers&#x27;, input: genNumbers(5) &#125;, &#123; message: &#x27;strings&#x27;, input: genStrings(10, 20) &#125;, &#123; message: &#x27;booleans&#x27;, input: genBooleans(2, 4) &#125;, &#123; message: &#x27;undefined&#x27;, input: genUndefined() &#125;, &#123; message: &#x27;null&#x27;, input: genNull() &#125;, &#123; message: &#x27;complex&#x27;, input: [ ...genNumbers(5), ...genStrings(5), ...genBooleans(2), ...genUndefined(), ...genNull(), ] &#125; ] tests.forEach((&#123;message, input&#125;) =&gt; &#123; test(message, () =&gt; &#123; expect(unique(input)).toEqual([...new Set(input)]) &#125;) &#125;)&#125;) 接着开始实现123function unique (list)&#123;&#125;module.exports.unique = unique 保存后运行测试用例，必然没通过，因为啥也没有嘛 Set 方式上面使用 new Set 已经是一种去重方式了, 保存后运行 123function unique (list)&#123; return [...new Set(list)]&#125; 这样肯定过的，没啥疑问 最土的办法 双重 for1234567891011121314151617181920/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; let result = [] for (let i = 0; i &lt; list.length; i++) &#123; let hasEl = false for(let j = 0; j &lt; result.length; j++) &#123; // 检查收录的数据 if(result[j] === list[i])&#123; hasEl = true break &#125; &#125; if(!hasEl) result.push(list[i]) &#125; return result&#125; 也可以写成这样 12345678910111213/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; let result = [] list.forEach(item =&gt; &#123; if(result.some(el =&gt; el === item)) return result.push(item) &#125;) return result&#125; 甚至你可以用万能的 reduce 1234567891011/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; return list.reduce((prev, item) =&gt; &#123; if(!prev.some(el =&gt; el === item)) prev.push(item) return prev &#125;, [])&#125; 当然你也可以不用 some 换成 indexOf 123456789101112/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; return list.reduce((prev, item) =&gt; &#123; if(prev.indexOf(item) === -1) prev.push(item) return prev &#125;, [])&#125; 优化时间复杂度的版本12345678910111213141516171819202122/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; const result = [] const cache = &#123;&#125; // 处理 1 和 &#x27;1&#x27; 情况 const key = el =&gt; `[$&#123;typeof el&#125; $&#123;el&#125;]` for (let i = 0; i &lt; list.length; i++) &#123; let el = list[i] // 注意这里也会有消耗, // 如果是不需要特别处理 1 和 &#x27;1&#x27; 不需要额外生成key let k = key(el) if(!cache[k]) &#123; cache[k] = true result.push(el) &#125; &#125; return result&#125; 也可以这么写 1234567891011121314151617/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; const result = [] const cache = &#123;&#125; const key = el =&gt; `[$&#123;typeof el&#125; $&#123;el&#125;]` list.forEach(item =&gt; &#123; let k = key(item) if(cache[k]) return cache[k] = true result.push(item) &#125;) return result&#125; 可以通过 filter 12345678910111213/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; const cache = &#123;&#125; const computed = el =&gt; &#123; let k = `[$&#123;typeof el&#125; $&#123;el&#125;]` return cache[k] ? false : cache[k] = true &#125; return list.filter(computed)&#125; 还是可以用万能的 reduce 123456789101112131415/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; return [ ...Object.values( list.reduce((prev, cur) =&gt; &#123; prev[`$&#123;typeof cur&#125; $&#123;cur&#125;`] = cur return prev &#125;, &#123;&#125;) ) ]&#125; 排序后比对元素注意这个会把数组重新排序，输出顺序不稳定 123456789101112131415161718/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; let sort = list.slice().sort((a, b) =&gt; a &lt; b ? -1 : 1) let result = [] let last for (let i = 0; i &lt; sort.length; i++) &#123; const element = sort[i]; if(!i || last !== element)&#123; result.push(element) &#125; last = element &#125; return result&#125; 利用 filter 12345678910/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; return list.slice() .sort((a, b) =&gt; a &lt; b ? -1 : 1). filter((el, i, arr) =&gt; !i || arr[i - 1] !== el)&#125; 总结正常的情况到这里就已经差不多一共就 Set , for循环，cache和排序后比对前后元素四种方法。 是这个世界存在一个神奇的东西 NaN，它并不等于自身，所以上面存在比较相等逻辑的方法被 NaN 爆杀，只剩Set 和 键值对才能对付 NaN 了 123456789101112131415161718192021/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; return [...new Set(list)]&#125;/** * unique * @param &#123;[]&#125; list * @returns */function unique (list)&#123; const cache = &#123;&#125; const computed = el =&gt; &#123; let k = `[$&#123;typeof el&#125; $&#123;el&#125;]` return cache[k] ? false : cache[k] = true &#125; return list.filter(computed)&#125; 谨慎使用 NaN （最好不要让它出现） 如果追求对象也去重可以键值对的键值基础上 JSON.stringify(value) 123456789101112131415161718192021222324252627282930313233343536373839/** * 去重 * @param &#123;[]&#125; array 待去重数组 * @param &#123;Boolean&#125; isSorted 是否排序 * @param &#123;function&#125; iteratee 比较函数 * @param &#123;object&#125; context 作用域 */function unique(array, isSorted, iteratee, context)&#123; if(typeof isSorted !== &#x27;boolean&#x27;)&#123; context = iteratee iteratee = isSorted isSorted = false &#125; if(isSorted === true)&#123; iteratee = function(value)&#123; return value &#125; &#125;else if(typeof iteratee !== &quot;function&quot;)&#123; iteratee = function(value)&#123; value = value instanceof RegExp ? value.toString() : value var key = (typeof value) + JSON.stringify(value) if(this[key]) return false this[key] = true return true &#125; &#125; iteratee = iteratee.bind(context || &#123;&#125;) var result = [] var last for(var i = 0; i &lt; array.length; i++)&#123; var value = array[i] var computed = iteratee(value, i, array) if(isSorted)&#123; if(!i || computed !== last) result.push(value) last = value &#125;else&#123; if(computed) result.push(value) &#125; &#125; return result&#125; 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"去重","slug":"去重","permalink":"https://luoyuda.github.io/tags/%E5%8E%BB%E9%87%8D/"}]},{"title":"JavaScript 原型链与继承","slug":"JavaScript/inherit","date":"2022-04-02T05:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/02/JavaScript/inherit/","link":"","permalink":"https://luoyuda.github.io/2022/04/02/JavaScript/inherit/","excerpt":"","text":"继承原型链prototype 是函数上的一个属性 __proto__ 是对象实例上的属性，指向其构造函数的 prototype 属性 原型层层往上形成了原型链，需要注意的是 123456789Object.__proto__ === Function.prototypeFunction.__proto__ === Function.prototype(function ()&#123;&#125;).__proto__ === Function.prototypeFunction.prototype.__proto__ === Object.prototypeObject.prototype.__proto__ === null// 箭头函数(() =&gt; &#123;&#125;).__proto__ === Function.prototype(() =&gt; &#123;&#125;).prototype === undefined ES6 class 相关的原型链相关知识1234567891011121314151617181920212223242526class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // trueclass B extends A&#123;&#125;let a = new A()let b = new B()B.__proto__ === AB.prototype.__proto__ === A.prototypeb.__proto__ === B.prototypeb.__proto__.__proto__ === A.prototypeb.__proto__.__proto__ === a.__proto__Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A); 原型链继承通过原型链实现继承 缺点 引用类型的属性绘本所有实例共享 创建 Child 实例无法向 Parent 传参 原型链 child.__proto__ -&gt; Child.prototype -&gt; new Parent() Child.prototype.constructor -&gt; Parent 1234567891011121314151617181920function Parent()&#123;&#125;Parent.prototype.sayName = function()&#123; console.log(this.name)&#125;function Child(name)&#123; this.name = name&#125;Child.prototype = new Parent()const child = new Child(&#x27;child&#x27;)child.sayName() // childconsole.log(child) // Parent &#123; name: &#x27;child&#x27; &#125;console.log(child instanceof Parent) // trueconsole.log(child instanceof Child) // trueconsole.log(child.__proto__ === Child.prototype) // trueconsole.log(Child.prototype.constructor === Parent) // true 借用构造函数继承在子类中调用父类的构造函数绑定在子类的 this 上 优点 避免了引用类型被共享的问题 Child 可以向 Parent 传参 缺点 每次创建实例都会创建一遍父类方法 原型链 child.__proto__ -&gt; Child.prototype Child.prototype.constructor -&gt; Child 123456789101112131415161718function Parent2(name)&#123; this.name = name this.sayName = function()&#123; console.log(this.name) &#125;&#125;function Child2(name)&#123; Parent2.call(this, name)&#125;var child2 = new Child2(&#x27;child&#x27;)child2.sayName() // childconsole.log(child2) // Child2 &#123; name: &#x27;child&#x27; &#125;console.log(child2 instanceof Parent2) // trueconsole.log(child2 instanceof Child2) // trueconsole.log(child2.__proto__ === Child2.prototype) // trueconsole.log(Child2.prototype.constructor === Child2) // true 组合继承在子类中调用父类掉构造函数绑定到子类的 this 上，把子类的原型等于父类的实例 优点 避免引用被共享 不需要重复创建方法 缺点 需要多 new 一次 原型链 child.__proto__ -&gt; Child.prototype Child.prototype.constructor -&gt; Child 1234567891011121314151617181920function Parent3(name)&#123; this.name = name&#125;Parent3.prototype.sayName = function()&#123; console.log(this.name)&#125;function Child3(name)&#123; Parent3.call(this, name)&#125;Child3.prototype = new Parent()Child3.prototype.constructor = Child3const child3 = new Child3(&#x27;child3&#x27;)child3.sayName() // child3console.log(child3) // Child3 &#123; name: &#x27;child3&#x27; &#125;console.log(child3 instanceof Parent2) // falseconsole.log(child3 instanceof Child3) // trueconsole.log(child3.__proto__ === Child3.prototype) // trueconsole.log(Child3.prototype.constructor === Child3) // true 原型式继承将传入的对象作为创建的对象的原型 缺点 引用类型被共享 原型链 child.__proto__ -&gt; F.prototype -&gt; o 1234567891011121314151617const P = &#123; name: &#x27;P&#x27;, sayName()&#123; console.log(this.name) &#125;&#125;function CreateObj(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125;const child4 = CreateObj(P)child4.sayName() // Pconsole.log(child4) // &#123;&#125;console.log(child4 instanceof Object) // trueconsole.log(child4.__proto__ === P) // true 寄生式继承创建一个封装继承过程的函数，用来增强对象，然后返回对象 缺点 重复创建方法 引用类型共享 原型链 child.__proto__ -&gt; o 123456789101112131415161718const P = &#123; name: &#x27;P&#x27;, sayName()&#123; console.log(this.name) &#125;&#125;function CreateObj1(o, name)&#123; var clone = Object.create(o) clone.name = name return clone&#125;const child5 = CreateObj1(P, &#x27;child5&#x27;)child5.sayName() // Pconsole.log(child5) // &#123;&#125;console.log(child5 instanceof Object) // trueconsole.log(child5.__proto__ === P) // true 寄生组合式继承 优点 只调用一次父类构造函数 避免在 Parent.prototype 创建不必要多余的属性 原型链保持不变，能正常使用 instanceof 和 isPrototypeOf 原型链 child.__proto__ -&gt; Child.prototype Child.prototype.constructor -&gt; Child 12345678910111213141516171819202122232425262728293031323334function object(o)&#123; function F()&#123;&#125; F.prototype = o return new F()&#125;function inherit(child, parent)&#123; const prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;function Parent6(name)&#123; this.name = name&#125;Parent6.prototype.sayName = function()&#123; console.log(this.name)&#125;function Child6(name)&#123; // 增强子类实例 Parent6.call(this, name)&#125;// 绑定原型inherit(Child6, Parent6)const child6 = new Child6(&#x27;child6&#x27;)child6.sayName() // child6console.log(child6) // Child6 &#123; name: &#x27;child6&#x27; &#125;console.log(child6 instanceof Child6) // trueconsole.log(child6 instanceof Parent6) // trueconsole.log(child6.__proto__ === Child6.prototype) // trueconsole.log(Child6.prototype.constructor === Child6) // true 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"https://luoyuda.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"继承","slug":"继承","permalink":"https://luoyuda.github.io/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"设计模式 - 笔记 - 创造型设计模式 （JavaScript实现）","slug":"designPattern/1","date":"2022-04-02T05:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/02/designPattern/1/","link":"","permalink":"https://luoyuda.github.io/2022/04/02/designPattern/1/","excerpt":"","text":"创造型设计模式关注怎样创建对象？降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成，关注于将对象的创建与使用分离 简单工厂模式由一个工厂对象决定创建某一种产品对象类的实例。主要是用来创建同一类对象。通过创建一个新对象包装增强属性后返回对象，主要用来创建同一类对象 优点 类包含了所有实现细节 只需要关心参数 缺点 种类单一 增加类个数，会增加复杂度和理解难度 扩展困难 1234567891011121314151617181920212223242526272829303132333435363738const PopFactory = function(type, content) &#123; const o = new Object() // 共用部分 o.content = content o.show = function()&#123; console.log(`content: $&#123;this.content&#125;`) &#125; // 差异部分 switch(type)&#123; case &#x27;alert&#x27;: o.hide = function()&#123; console.log(&#x27;alert-hide&#x27;) &#125; break; case &#x27;prompt&#x27;: o.hide = function()&#123; console.log(&#x27;prompt-hide&#x27;) &#125; break; case &#x27;confirm&#x27;: o.hide = function()&#123; console.log(&#x27;confirm-hide&#x27;) &#125; break; &#125; // 返回工厂对象 return o&#125;const alert = PopFactory(&#x27;alert&#x27;, &#x27;alert-content&#x27;)const prompt = PopFactory(&#x27;prompt&#x27;, &#x27;prompt-content&#x27;)const confirm = PopFactory(&#x27;confirm&#x27;, &#x27;confirm-content&#x27;)alert.show()prompt.show()confirm.show()alert.hide()prompt.hide()confirm.hide() 工厂方法模式通过对产品类的抽象，使其可以创建多类产品的实例,创建属于同一类，但是又有些许差异性的情况 优点 只需要知道具体工厂的名称就可得到所要的产品 无须知道产品的具体创建过程 灵活性增强 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则 缺点 个数过多，增加复杂度 增加抽象性和理解难度 抽象产品只能生产一种产品 1234567891011121314151617181920212223const Factory = function (type, content) &#123; if(this instanceof Factory)&#123; return new this[type](content) &#125;else&#123; return new Factory(type, content) &#125;&#125;Factory.prototype.A = function(content)&#123; this.content = content this.type = &#x27;A&#x27;&#125;Factory.prototype.B = function(content)&#123; this.content = content this.type = &#x27;B&#x27;&#125;Factory.prototype.C = function(content)&#123; this.content = content this.type = &#x27;C&#x27;&#125;const a = new Factory(&#x27;A&#x27;, &#x27;test&#x27;)const b = Factory(&#x27;B&#x27;, &#x27;test&#x27;)const c = Factory(&#x27;C&#x27;, &#x27;test&#x27;) 抽象工厂模式通过抽象，使其业务用于对产品类簇的创建，而不负责创建某一类产品，显性的去定义一些功能，而不做具体实现，子类继承后子类负责实现，用于制定类的结构 优点 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则 缺点 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度 建造者模式将一个复杂对象的构建层与其表示层分离，同样的构建过程采取不一样的表示，关注实例的创造过程，一般用于创建符合对象 优点 封装性好，构建和表示分离 扩展性好，各个具体的建造者相互独立，有利于系统的解耦 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险 缺点 产品的组成部分必须相同，这限制了其使用范围 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大 123456789101112131415161718192021222324252627282930313233343536373839404142const VehicleFactory = function(subType, superType) &#123; if(typeof VehicleFactory[superType] === &#x27;function&#x27;)&#123; // 继承父类 比如 BWM 继承 Car YUTONG 继承 Bus function F() &#123;&#125; F.prototype = new VehicleFactory[superType]() subType.prototype = new F() subType.prototype.constructor = subType &#125;else&#123; throw new Error(&#x27;未创建抽象类&#x27;) &#125;&#125;VehicleFactory.Car = function()&#123; this.type = &#x27;Car&#x27;&#125;VehicleFactory.Car.prototype.getPrice = function()&#123; throw new Error(&#x27;抽象方法不可调用&#x27;)&#125;VehicleFactory.Car.prototype.getSpeed = function()&#123; throw new Error(&#x27;抽象方法不可调用&#x27;)&#125;VehicleFactory.Bus = function()&#123; this.type = &#x27;Bus&#x27;&#125;VehicleFactory.Bus.prototype.getPrice = function()&#123; throw new Error(&#x27;抽象方法不可调用&#x27;)&#125;VehicleFactory.Bus.prototype.getSpeed = function()&#123; throw new Error(&#x27;抽象方法不可调用&#x27;)&#125;const BMW = function(price, speed)&#123; this.price = price this.speed = speed&#125;VehicleFactory(BMW, &#x27;Car&#x27;) BMW.prototype.getPrice = function()&#123; return this.type + &#x27; price &#x27; + this.price&#125;BMW.prototype.getSpeed = function()&#123; return this.type + &#x27; speed &#x27; + this.speed&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445const Human = function (params) &#123; this.skill = params.skill || &#x27;无&#x27; this.hobby = params.hobby || &#x27;无&#x27;&#125;Human.prototype.getSkill = function() &#123; return this.skill&#125;Human.prototype.getHobby = function() &#123; return this.hobby&#125;const Name = function(name) &#123; this.wholeName = name&#125;const Work = function(work) &#123; switch (work) &#123; case &#x27;code&#x27;: this.work = &#x27;搬砖师&#x27; this.workDescription = &#x27;996警告&#x27; break; case &#x27;ui&#x27;: this.work = &#x27;P图师&#x27; this.workDescription = &#x27;想要五彩斑斓的黑&#x27; break; default: this.work = &#x27;无业游民&#x27; this.workDescription = &#x27;干一天玩三天&#x27; break; &#125;&#125;Work.prototype.changeWork = function(work) &#123; this.work = work&#125;Work.prototype.changeWorkDescription = function(workDescription) &#123; this.workDescription = workDescription&#125;const Person = function(name, work, skill, hobby)&#123; const _person = new Human(skill, hobby) _person.name = new Name(name) _person.work = new Work(work) return _person&#125; 原型模式用原型实例指向创建对象的类，使用创建新对象的类共享对象的属性及方法，可以让多个对象分享同一个原型对象上的属性方法 123456789101112131415161718192021222324252627const Person = function(name, age) &#123; this.name = name this.age = age&#125;Person.prototype.getName = function() &#123; return this.name&#125;Person.prototype.getAge = function() &#123; return this.age&#125;const Woman = function(name, age) &#123; Person.call(this, name, age)&#125;Woman.prototype = new Person()Woman.prototype.constructor = WomanWoman.prototype.getAge = function() &#123; return `女人的年龄是秘密`&#125;const Man = function(name, age) &#123; Person.call(this, name, age)&#125;Man.prototype = new Person()Man.prototype.constructor = Manconst woman = new Woman(&#x27;小红&#x27;, 24)const man = new Man(&#x27;李白&#x27;, 24) 单例模式只允许实例化一个对象类，通过不同的命名空间来组织区分各个模块 优点 内存里只有一个实例，减少了内存的开销 可以避免对资源的多重占用 设置全局访问点，可以优化和共享资源的访问 缺点 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则 123456789101112131415161718192021const LazySingle = (function ()&#123; let _instance = null function _Single()&#123; // 静态变量 const STATIC_COUNT = 2 // 单例对象 return &#123; getStaticCount: function ()&#123; return `静态变量 STATIC_COUNT = $&#123;STATIC_COUNT&#125;` &#125;, publicCount: 3, // 公共变量 &#125; &#125; return function ()&#123; // 惰性返回 if(!_instance)&#123; _instance = _Single() &#125; return _instance &#125;&#125;)() 源码地址","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://luoyuda.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"创造型设计模式","slug":"创造型设计模式","permalink":"https://luoyuda.github.io/tags/%E5%88%9B%E9%80%A0%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 - 笔记 - 结构型设计模式 （JavaScript实现）","slug":"designPattern/2","date":"2022-04-02T05:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/02/designPattern/2/","link":"","permalink":"https://luoyuda.github.io/2022/04/02/designPattern/2/","excerpt":"","text":"创造型设计模式关注于代码结构的优化，以降低系统耦合 外观模式为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口访问子接口，简化使用，通过对接口方法的封装，提供给上层代码使用 优点 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，编译一个子系统不会影响其他的子系统，也不会影响外观对象 缺点 不能很好地限制客户使用子系统类，很容易带来未知风险 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则” 123456789101112131415const Facade = function () &#123; // 模拟一个存在差异性的对象 const obj = &#123; value: Math.random() * 2 &gt; 1 ? 0 : 1, otherValue: Math.random() * 2 &gt; 1 ? 0 : 1 &#125; return &#123; getValue: function()&#123; return obj.value || obj.otherValue &#125;, getObj: function()&#123; return obj &#125; &#125;&#125; 适配器模式将一个类的接口转换成另一个接口，以满足用户需求，使类中接口不兼容问题得到解决 优点 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题 缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱 1234567891011121314151617const extend = function(_default, options) &#123; for (const key in _default) &#123; if (_default.hasOwnProperty(key)) &#123; const element = _default[key]; options[key] = options[key] || element &#125; &#125; return options&#125;// 数据适配器const adapter = function(arr=[]) &#123; return &#123; name: arr[0], age: arr[1], &#125;&#125; 代理模式通过一个中介代理两个对象的传递 优点 客户端与目标间起到一个中介作用和保护目标对象的作用 代理对象可以扩展目标对象的功能 将客户端与目标对象分离，降低了系统的耦合度，增加可扩展性 缺点 会造成系统设计中类的数量增加 增加一个代理对象，会造成请求处理速度变慢 增加了系统的复杂度 12345678910111213141516const Girl = function(name)&#123; this.name = name&#125;const Boy = function(name)&#123; this.name = name this.sendGift = function(gift, girl)&#123; console.log(`$&#123;this.name&#125; 送 $&#123;gift&#125; 给 $&#123;girl.name&#125;`) &#125;&#125;const ProxySend = function(boy, girl) &#123; this.sendGift = function(gift)&#123; boy.sendGift(gift, girl) &#125;&#125; 装饰者模式在不改变对象的基础上，对其进行包装扩展，对原有对象进行一个扩展，是一种良性的扩展 优点 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果 装饰器模式完全遵守开闭原则 缺点 饰器模式会增加许多子类，过度使用会增加程序得复杂性 12345678910111213141516const Person = function() &#123;&#125;Person.prototype.getName = function(a, b, c) &#123; console.log(&#x27;Person-getName&#x27;,a, b, c)&#125;const log = function(a, b, c) &#123; console.log(&#x27;Decorator-&#x27;,a, b, c)&#125;const decorator = function(A, name, fn) &#123; var f = A.prototype[name] var bind = function()&#123; fn.apply(this, arguments) return f.apply(this, arguments) &#125; A.prototype[name] = bind&#125;decorator(Person, &#x27;getName&#x27;, log) 桥接模式在系统沿着多个维度变化的同时，不增加其复杂度并达到解耦 优点 抽象与实现分离，扩展能力强 符合开闭原则 符合合成复用原则 实现细节对客户透明 缺点 聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，增加了系统的理解与设计难度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const Speed = function(x, y)&#123; this.x = x this.y = y&#125;Speed.prototype.run = function(x, y)&#123; console.log(`($&#123;this.x&#125;, $&#123;this.y&#125;) ==&gt; ($&#123;x&#125;, $&#123;y&#125;)`) this.x = x this.y = y&#125;// 颜色单元const Color = function(color)&#123; this.color = color&#125;Color.prototype.draw = function()&#123; console.log(`绘制$&#123;this.color&#125;`)&#125;// 变形单元const Shape = function(shape)&#123; this.shape = shape&#125;Shape.prototype.change = function()&#123; console.log(`变形 $&#123;this.shape&#125;`)&#125;// 说话单元const Speak = function()&#123; &#125;Speak.prototype.say = function(word)&#123; console.log(`$&#123;word&#125;`)&#125;// 球类const Ball = function(c, x=0, y=0)&#123; this.speed = new Speed(x, y) this.color = new Color(c)&#125;// 精灵类const Sprite = function(c, x, y, s)&#123; this.shape = new Shape(s) this.speed = new Speed(x, y) this.color = new Color(c)&#125;// 人类const Person = function(x, y)&#123; this.speed = new Speed(x, y) this.speak = new Speak()&#125; 组合模式部分-整体模式，将对象组合成树形结构以表示部分整体的层次结构 优点 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则” 缺点 设计复杂，需要花更多时间理清类之间的层次关系 不容易限制容器中的构件 不容易用继承的方法来增加构件的新功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132const El = function(type, content=&#x27;&#x27;, children = []) &#123; this.type = type this.content = content this.children = children&#125;El.prototype.render = function()&#123; return `&lt;$&#123;this.type&#125;&gt;$&#123;this.content&#125;$&#123;this.children.reduce((p, i) =&gt; p + i.render(), &#x27;&#x27;)&#125;&lt;/$&#123;this.type&#125;&gt;`&#125;const News = function()&#123; this.children = [] this.element = null&#125;News.prototype.init = function()&#123; throw new Error(&#x27;抽象方法&#x27;)&#125;News.prototype.add = function()&#123; throw new Error(&#x27;抽象方法&#x27;)&#125;News.prototype.getElement = function()&#123; throw new Error(&#x27;抽象方法&#x27;)&#125;const inherit = function(child, parent) &#123; function F() &#123;&#125; F.prototype = new parent() child.constructor = child child.prototype = new F()&#125;const Container = function(id, parent)&#123; News.call(this) this.id = id this.parent = parent this.init()&#125;inherit(Container, News)Container.prototype.init = function()&#123; this.element = new El(&#x27;ul&#x27;) this.element.id = this.id return this&#125;Container.prototype.add = function(child)&#123; this.element.children.push(child) return this&#125;Container.prototype.getElement = function()&#123; return this.element.render()&#125;const Item = function(id, parent)&#123; News.call(this) this.id = id this.parent = parent this.init()&#125;inherit(Item, News)Item.prototype.init = function()&#123; this.element = new El(&#x27;li&#x27;) this.element.id = this.id return this&#125;Item.prototype.add = function(child)&#123; this.element.children.push(child) return this&#125;Item.prototype.getElement = function()&#123; return this.element.render()&#125;const Group = function(id, parent)&#123; News.call(this) this.id = id this.parent = parent this.init()&#125;inherit(Group, News)Group.prototype.init = function()&#123; this.element = new El(&#x27;div&#x27;) this.element.id = this.id return this&#125;Group.prototype.add = function(child)&#123; this.element.children.push(child) return this&#125;Group.prototype.getElement = function()&#123; return this.element.render()&#125;const ImageNews = function(url, href)&#123; News.call(this) this.url = url this.href = href this.init()&#125;inherit(ImageNews, News)ImageNews.prototype.init = function()&#123; this.element = new El(&#x27;a&#x27;, this.href) this.element.children.push(new El(&#x27;img&#x27;, this.url)) return this&#125;ImageNews.prototype.add = function(child)&#123; this.element.children.push(child) return this&#125;ImageNews.prototype.getElement = function()&#123; return this.element.render()&#125;const TextNews = function(content, href)&#123; News.call(this) this.content = content this.href = href this.init()&#125;inherit(TextNews, News)TextNews.prototype.init = function()&#123; this.element = new El(&#x27;a&#x27;, this.href) this.element.children.push(new El(&#x27;span&#x27;, this.content)) return this&#125;TextNews.prototype.add = function(child)&#123; this.element.children.push(child) return this&#125;TextNews.prototype.getElement = function()&#123; return this.element.render()&#125; 享元模式 运用共享技术有效支持大量的细粒度的对象，避免对象间拥有相同内容造成多余开销 优点 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力 缺点 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性 读取享元模式的外部状态会使得运行时间稍微变长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 运动单元const speed = &#123; run: function(x, y)&#123; console.log(`($&#123;this.x&#125;, $&#123;this.y&#125;) ==&gt; ($&#123;x&#125;, $&#123;y&#125;)`) this.x = x this.y = y &#125;&#125;// 颜色单元const color = &#123; draw: function()&#123; console.log(`绘制$&#123;this.color&#125;`) &#125;&#125;// 变形单元const shape = &#123; change: function()&#123; console.log(`变形 $&#123;this.shape&#125;`) &#125;&#125;// 说话单元const speak = &#123; say: function(word)&#123; console.log(`$&#123;word&#125;`) &#125;&#125;// 球类const Ball = function(c, x=0, y=0)&#123; this.x = x this.y = y this.color = c&#125;Ball.prototype = &#123; ...color, ...speed,&#125;// 精灵类const Sprite = function(c, x, y, s)&#123; this.x = x this.y = y this.color = c this.shape = s&#125;Sprite.prototype = &#123; ...color, ...speed, ...shape&#125;// 人类const Person = function(x, y)&#123; this.x = x this.y = y&#125;Person.prototype = &#123; ...speak, ...speed,&#125; 源码地址","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://luoyuda.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"结构型设计模式","slug":"结构型设计模式","permalink":"https://luoyuda.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式 - 笔记 - 行为型设计模式 （JavaScript实现）","slug":"designPattern/3","date":"2022-04-02T05:00:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/02/designPattern/3/","link":"","permalink":"https://luoyuda.github.io/2022/04/02/designPattern/3/","excerpt":"","text":"行为型设计模式关注于模块间的沟通 模板方法模式父类定义一组操作算法骨架，而将实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤 优点 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展 它在父类中提取了公共的部分代码，便于代码复用 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则 缺点 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const TemplateCar = function(data = &#123;&#125;)&#123; this.type = data.type || &#x27;&#x27; this.wheelCount = data.wheelCount || 2 this.mirrorCount = data.mirrorCount || 2 this.color = data.color || &#x27;白色&#x27; this.beforeRun = data.beforeRun || this.beforeRun this.afterRun = data.afterRun || this.afterRun&#125;TemplateCar.prototype.makeWheel = function(count)&#123; console.log(`正在做出$&#123;count&#125;个轮子`)&#125;TemplateCar.prototype.makeMirror = function(count)&#123; console.log(`正在做出$&#123;count&#125;个后视镜`)&#125;TemplateCar.prototype.makeCarBody = function(color)&#123; console.log(`正在做出$&#123;color&#125;车身`)&#125;TemplateCar.prototype.beforeRun = function()&#123; console.log(`逮虾户，油门启动`)&#125;TemplateCar.prototype.afterRun = function()&#123; console.log(`逮虾户，猛踩刹车`)&#125;TemplateCar.prototype.run = function()&#123; this.beforeRun() console.log(`我一路向北，离开有你的地方`) this.afterRun()&#125;TemplateCar.prototype.init = function()&#123; this.makeWheel(this.wheelCount) this.makeMirror(this.mirrorCount) this.makeCarBody(this.color)&#125;const Motorcycle = function(data = &#123;&#125;)&#123; data.type = &#x27;motorcycle&#x27; TemplateCar.call(this, data) this.init()&#125;Motorcycle.prototype = new TemplateCar()const Car = function(data = &#123;&#125;)&#123; data.type = &#x27;car&#x27; data.mirrorCount = 2 data.wheelCount = 4 TemplateCar.call(this, data) this.init()&#125;Car.prototype = new TemplateCar()Car.prototype.init = function()&#123; this.makeWheel(this.wheelCount) this.makeMirror(this.mirrorCount) this.makeCarBody(this.color) console.log(`小汽车组装完毕`)&#125;const ToyotaCar = function(data=&#123;&#125;)&#123; this.logo = &#x27;Toyota&#x27; Car.call(this, data)&#125;ToyotaCar.prototype = new Car() 策略模式将定义的一组算法封装起来，使其相互之间可以替换，封装的算法具有一定的独立性，不会随着客户端变化而变化 优点 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句 提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码 提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的 提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法 把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离 缺点 必须理解所有策略算法的区别，以便适时选择恰当的算法 造成很多的策略类，增加维护难度 1234567891011121314151617const Strategy = (function()&#123; const _strategy = &#123; a(arg)&#123; console.log(`a -&gt; $&#123;arg&#125;`) &#125; &#125; return &#123; check(type, ...args)&#123; if(!_strategy[type]) return this return _strategy[type](...args) &#125;, add(type, fn)&#123; _strategy[type] = fn return this &#125; &#125;&#125;)() 职责链模式解决请求点发送者与请求点接受者的耦合，通过链上多个对象分解请求流程，实现请求在多个对象中传递，直到最后一个对象完成处理的请求 优点 降低了对象之间的耦合度 增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则 增强了给对象指派职责的灵活性 简化了对象之间的连接 只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则 缺点 不能保证每个请求一定被处理 请求的处理可能涉及多个处理对象，系统性能将受影响 可能会造成循环调用 123456789101112const Chain = function(fn)&#123; this.fn = fn this.successor = null&#125;Chain.prototype.setNextSuccessor = function(successor)&#123; return this.successor = successor&#125;Chain.prototype.passRequest = function()&#123; let ret = this.fn.apply(this, arguments) if(ret !== &#x27;successor&#x27;) return ret return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)&#125; 命令模式将请求与实现解耦并封装成独立对象，从而使得不同的请求对客户端实现参数化 优点 通过引入中间件（抽象接口）降低系统的耦合度 扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则” 与组合模式结合实现宏命令 与备忘录模式结合，实现命令的撤销与恢复 与装饰器模式结合，增加额外功能 缺点 可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性 抽象必然会额外增加类的数量，增加理解成本 123456789101112131415161718192021222324252627const Command = (function()&#123; const _command = &#123; a(arg)&#123; console.log(`a -&gt; $&#123;arg&#125;`) &#125;, b(arg)&#123; console.log(`b -&gt; $&#123;arg&#125;`) &#125;, c(arg)&#123; console.log(`c -&gt; $&#123;arg&#125;`) &#125; &#125; return &#123; execute(commands)&#123; if(!commands || !commands.length) return this commands.forEach((&#123; command=&#x27;&#x27;, params &#125;) =&gt; &#123; if(!_command[command]) return if(typeof params === &#x27;string&#x27;)&#123; params = [params] &#125; _command[command].apply(this, params) &#125;) console.log(this) return this &#125; &#125;&#125;)() 访问者模式针对对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法 优点 扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能 复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度 灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构 符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一 缺点 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则” 破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类 12345678const ArrayVisitor = (function()&#123; return &#123; splice()&#123; var args = Array.prototype.splice.call(arguments, 1) return Array.prototype.splice.apply(arguments[0], args) &#125; &#125;&#125;)() 中介者模式通过中介者对象封装一系列对象之间的交互，使对象之间不再互相引用，降低他们之间的耦合 优点 类之间各司其职，符合迪米特法则 降低了对象之间的耦合性，使得对象易于独立地被复用 将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展 缺点 中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护 12345678910111213141516171819const Mediator = (function () &#123; let _msg = &#123;&#125; return &#123; register(type, action)&#123; if(_msg[type])&#123; _msg[type].push(action) &#125;else&#123; _msg[type] = [action] &#125; &#125;, send(type)&#123; if(_msg[type])&#123; _msg[type].forEach(fn =&gt; &#123; fn() &#125;) &#125; &#125; &#125;&#125;)() 备忘录模式在不破坏对象封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态 优点 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息 简化了发起人类。不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则 缺点 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源 12345678910111213const Data = (function () &#123; const _cache = &#123;&#125; return &#123; getData(type, callback=()=&gt;&#123;&#125;)&#123; if(_cache[type]) return callback(_cache[type]) const timer = setTimeout(() =&gt; &#123; const data = Math.random() * 10 _cache[type] = data callback(data) &#125;, 1000 * Math.random()) &#125; &#125;&#125;)() 迭代器模式在不暴露对象内部结构的情况下，可以顺序访问聚合对象内部的元素 优点 访问一个聚合对象的内容而无须暴露它的内部表示 遍历任务交由迭代器完成，这简化了聚合类 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历 增加新的聚合类和迭代器类都很方便，无须修改原有代码 封装性良好，为遍历不同的聚合结构提供一个统一的接口 缺点 增加了类的个数，这在一定程度上增加了系统的复杂性 1234567891011121314151617181920212223function _forOf(obj, cb)&#123; if(typeof obj[Symbol.iterator] !== &#x27;function&#x27;) throw new TypeError(&#x27;Symbol.iterator is not a function&#x27;) if(typeof cb !== &#x27;function&#x27;) throw new TypeError(&#x27;cb is not a function&#x27;) var iteratee = obj[Symbol.iterator]() var res while(true)&#123; res = iteratee.next() if(res.done) break cb(res.value) &#125;&#125;function _createIterator(list, iterator)&#123; var next = 0 var obj = &#123; next: function()&#123; return next &lt; list.length ? &#123; done: false, value: iterator(list[next++]) &#125; : &#123; done: true, value: undefined &#125; &#125;, &#125; obj[Symbol.iterator] = function()&#123; return obj &#125; return obj&#125; 解释器模式通过一定的文法对应定义一个解释器，通过解释器解释语言的意思 优点 扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法 容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易 缺点 执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦 会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护 可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到 12345678910111213141516171819202122const Play = (function () &#123; const _str = &#123; &#x27;up&#x27;: &#x27;向上&#x27;, &#x27;down&#x27;: &#x27;向下&#x27;, &#x27;left&#x27;: &#x27;向左&#x27;, &#x27;right&#x27;: &#x27;向右&#x27;, &#x27;move&#x27;: &#x27;移动&#x27;, &#x27;jump&#x27;: &#x27;跳&#x27; &#125; return &#123; exec(strings)&#123; strings = strings.split(&#x27; &#x27;) if(!strings || !strings.length) return this let text = &#x27;&#x27; strings.forEach(str =&gt; &#123; text += _str[str] || str &#125;) console.log(text) return this &#125; &#125;&#125;)() 状态模式根据不同的状态做出不同的行为，状态驱动行为，行为决定状态 优点 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则” 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换 缺点 使用必然会增加系统的类与对象的个数 结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱 对开闭原则的支持不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码 1234567891011121314151617181920212223var Light = function() &#123; this.state = &#x27;off&#x27; // 电灯初始状态 off this.button = null // 电灯开关按钮&#125;Light.prototype.init = function () &#123; var button = document.createElement(&#x27;button&#x27;),self = this; button.innerHTML = &#x27;开关&#x27;; this.button = document.body.appendChild(button); this.button.onclick = function () &#123; self.buttonWasPressed(); &#125;&#125;;Light.prototype.buttonWasPressed = function () &#123; if (this.state === &#x27;off&#x27;) &#123; console.log(&#x27;开灯&#x27;); this.state = &#x27;on&#x27;; &#125; else if (this.state === &#x27;on&#x27;) &#123; console.log(&#x27;关灯&#x27;); this.state = &#x27;off&#x27;; &#125;&#125;;var light = new Light();light.init(); 观察者模式指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，依赖于它的对象都得到通知并被自动更新，在观察者模式中有两个主要角色：Subject（主题）和 Observer（观察者） 优点 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则 目标与观察者之间建立了一套触发机制 缺点 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率 1234567891011121314151617181920212223class Observer &#123; constructor(name)&#123; this.name = name &#125; notify()&#123; console.log(`$&#123;this.name&#125; has been notified`) &#125;&#125;class Subject &#123; observers = [] addObserver(observer)&#123; console.log(observer.name, &#x27;is push&#x27;) this.observers.push(observer) &#125; deleteObserver(observer)&#123; console.log(&#x27;remove observer: &#x27;, observer.name) this.observers = this.observers.filter(o =&gt; o !== observer) &#125; notifyObservers()&#123; console.log(&#x27;notify&#x27;) this.observers.forEach(o =&gt; o.notify()) &#125;&#125; 发布订阅模式发送者（称为发布者）不会将消息直接发送给接收者（称为订阅者）。而是将发布的消息分为不同的类别，然后分别发送给不同的订阅者 优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 1234567891011121314151617181920212223242526272829303132333435class Event&#123; constructor()&#123; this.cache = &#123;&#125; return this &#125; on(type, event)&#123; if(!this.cache[type]) this.cache[type] = [] if(this.cache[type].indexOf(event) == -1)&#123; this.cache[type].push(event) &#125; return this &#125; off(type, event)&#123; if(!this.cache[type]) return this this.cache[type] = this.cache[type].filter(e =&gt; e !== event) return this &#125; once(type, event)&#123; let _event = function()&#123; event.apply(this, arguments) this.off(type, _event) &#125; this.on(type, _event) return this &#125; emit()&#123; let type = arguments[0] let args = Array.prototype.slice.call(arguments, 1) let list = this.cache[type] || [] for (const event of list) &#123; event.apply(this, args) &#125; return this &#125;&#125; 与观察者模式的差异 观察者模式 观察者是知道 Subject 的，Subject 一直保持对观察者进行记录 紧耦合 大部分情况是同步的 发布订阅 发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信 松耦合 大部分情况是异步的 源码地址","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://luoyuda.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"行为型设计模式","slug":"行为型设计模式","permalink":"https://luoyuda.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Promise 相关方法模拟实现（ES6）","slug":"JavaScript/promise-01","date":"2022-04-01T16:50:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/01/JavaScript/promise-01/","link":"","permalink":"https://luoyuda.github.io/2022/04/01/JavaScript/promise-01/","excerpt":"","text":"Promise.prototype.finallyfinally() 方法返回一个 Promise 。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数 那怎么实现呢？ 直接往 then 方法塞两个回调不就完事！ 1234567891011121314151617/** * finally() 方法返回一个Promise。在promise结束时 * 无论结果是fulfilled或者是rejected，都会执行指定的回调函数 * @param &#123;function&#125; fn * @returns promise */Promise.prototype.finally = function (fn) &#123; return this.then(function (value) &#123; return Promise.resolve(fn()).then(function () &#123; return value &#125;) &#125;, function (reason)&#123; return Promise.reject(fn()).then(function () &#123; return reason &#125;) &#125;) &#125; 12345678// ES6Promise.prototype.finally = function (fn) &#123; return this.then(value =&gt; &#123; return Promise.resolve(fn()).then(() =&gt; value) &#125;, reason =&gt; &#123; return Promise.reject(fn()).then(() =&gt; reason) &#125;)&#125; 这方法有啥用呢？比如你在处理异步请求的时候，经常会使用 loading，是不是事后无论请求成功或者失败都要把 loading 去掉，一般就是用在无论失败或成功都需要执行的操作 12345678910111213141516171819var load = falsenew Promise(function (resolve, reject) &#123; load = true setTimeout(function () &#123; console.log(&#x27;in pending: &#x27; + load) // in pending: true if(Math.random() &gt; 0.5)&#123; resolve() &#125;else&#123; reject() &#125; &#125;, 100)&#125;).then(function()&#123; console.log(&#x27;in fulfilled: &#x27; + load) // in fulfilled: true&#125;).catch(function()&#123; console.log(&#x27;in rejected: &#x27; + load) // in rejected: true&#125;).finally(function () &#123; load = false console.log(&#x27;in finally: &#x27; + load) // in finally: false&#125;) Promise.prototype.catch这个其实没啥好讲的，其实等于 this.then(null, fn) 12345678/** * catch() 方法返回一个Promise，并且处理拒绝的情况。 * @param &#123;function&#125; fn * @returns promise */Promise.prototype.catch = function (fn) &#123; return this.then(null, fn)&#125; 使用方法极其简单 123Promise.reject().catch(function()&#123; console.log(&#x27;in catch&#x27;)&#125;) Promise.reject &amp; Promise.resolve12345678910111213141516171819202122232425262728/** * Promise.reject()方法返回一个带有拒绝原因的Promise对象 * @param &#123;any&#125; reason */Promise.reject = function (reason) &#123; return new Promise(function(resolve, reject)&#123; var fn = function () &#123; reject(reason) &#125; if(reason instanceof Promise)&#123; reason.then(fn, fn) &#125;else &#123; fn() &#125; &#125;)&#125;// ES6Promise.reject = function (reason) &#123; return new Promise((resolve, reject) =&gt; &#123; const fn = () =&gt; reject(reason) reason instanceof Promise ? reason.then(fn, fn) : fn() &#125;)&#125;Promise.reject(new Promise(res =&gt; &#123; console.log(&#x27;in promise&#x27;) // in promise res(2)&#125;)).then(v =&gt; console.log(&#x27;in then &#x27; + v)).catch(v =&gt; console.log(&#x27;in catch &#x27;, v)) // in catch Promise &#123; 2 &#125; 123456789101112131415161718192021222324252627/** * Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象 * 如果这个值是一个 promise ，那么将返回这个 promise * @param &#123;any&#125; reason */Promise.resolve = function (value) &#123; if(value instanceof Promise) return value return new Promise(function(resolve, reject)&#123; resolve(value) &#125;)&#125;// ES6Promise.resolve = function (value) &#123; return value instanceof Promise ? value : new Promise(resolve =&gt; resolve(value))&#125;Promise.resolve(new Promise((res, rej) =&gt; &#123; console.log(&#x27;in promise&#x27;) // in promise res(2)&#125;)).then(v =&gt; console.log(&#x27;in then &#x27; + v)) // in then 2.catch(v =&gt; console.log(&#x27;in catch &#x27;, v))// 注意这里会有区别哦！Promise.resolve(new Promise((res, rej) =&gt; &#123; console.log(&#x27;in promise&#x27;) // in promise rej(2)&#125;)).then(v =&gt; console.log(&#x27;in then &#x27; + v)).catch(v =&gt; console.log(&#x27;in catch &#x27;, v)) // in catch 2 接下来就是面试经常问到的四个方法了 Promise.allPromise.all 是所有 Promise 结果都为 fulfilled 时才会执行 then 方法的回调！ 值得注意的是，all 方法接收的是一个迭代器对象，很多实现代码上来就是一个 for 循环的写法是不对的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Promise.all() 方法接收一个 promise 的 iterable 类型的输入 * 并且只返回一个Promise实例 * resolve([value,...]) * reject(firstReject) * @param &#123;*&#125; iterable * @returns promise */Promise.all = function (iterable) &#123; return new Promise(function(resolve, reject)&#123; var iteratee = iterable[Symbol.iterator]() var len = 0 var i = 0 var res = null var result = [] while (true)&#123; res = iteratee.next() if(res.done) break !(function(j)&#123; len++ var val = !(res.value instanceof Promise) ? Promise.resolve(res.value) : res.value val.then(function(value)&#123; result[j] = value i++ if(len === i &amp;&amp; res.done) resolve(result) &#125;, function(reason)&#123; reject(reason) &#125;) &#125;)(len) &#125; &#125;)&#125;;// ES6Promise.all = function (iterable) &#123; return new Promise((resolve, reject) =&gt; &#123; const promiseList = [...iterable] // 转换可迭代对象为数组 const result = [] let j = 0 let len = promiseList.length promiseList.forEach((val, i) =&gt; &#123; val = !(val instanceof Promise) ? Promise.resolve(val) : val val.then(value =&gt; &#123; result[i] = value j++ if(len &lt;= j) resolve(result) &#125;, reason =&gt; reject(reason)) &#125;) &#125;)&#125;; 测试代码 1234567891011121314[ new Map([[Promise.resolve(1), Promise.resolve(2)]]), new Set([Promise.resolve(1), Promise.resolve(2)]), [Promise.resolve(1), Promise.resolve(2)], new Set([Promise.reject(1), Promise.resolve(2)]), [Promise.reject(1), Promise.resolve(2)], [1, &#x27;1&#x27;, true, false, null, undefined, &#123;&#125;, function()&#123;&#125;, Symbol(), Promise.resolve(2)]].forEach(item =&gt; &#123; Promise.all(item).then(v =&gt; &#123; console.log(v) &#125;).catch(r =&gt; &#123; console.log(&#x27;in catch &#x27; + r) &#125;)&#125;) Promise.anyPromise.any 是只要有一个 Promise 结果都为 fulfilled 时就会执行 then 方法的回调！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Promise.any() 方法接收一个 promise 的 iterable 类型的输入 * 只要其中的一个 promise 成功，就返回那个已经成功的 promise * resolve([value,...]) * reject(firstReject) * @param &#123;*&#125; iterable * @returns promise */Promise.any = function (iterable) &#123; return new Promise(function(resolve, reject)&#123; var iteratee = iterable[Symbol.iterator]() var res = null var len = 0 var i = 0 while (true)&#123; res = iteratee.next() if(res.done) break len++ var val = !(res.value instanceof Promise) ? Promise.resolve(res.value) : res.value val.then(function(value)&#123; i++ resolve(value) &#125;, function(reason)&#123; i++ if(i &gt;= len &amp;&amp; res.done)&#123; reject(reason) &#125; &#125;) &#125; &#125;)&#125;;// ES6Promise.any = function (iterable) &#123; return new Promise((resolve, reject) =&gt; &#123; const promiseList = [...iterable] const len = promiseList.length let i = 0 promiseList.forEach(val =&gt; &#123; val = !(val instanceof Promise) ? Promise.resolve(val) : val val.then(value =&gt; &#123; i++ resolve(value) &#125;, reason =&gt; &#123; i++ if(i &gt;= len)&#123; reject(reason) &#125; &#125;) &#125;) &#125;)&#125;; 测试 1234567891011121314[ new Map([[Promise.resolve(1), Promise.resolve(2)]]), new Set([Promise.resolve(1), Promise.resolve(2)]), [Promise.resolve(1), Promise.resolve(2)], new Set([Promise.reject(1), Promise.resolve(2)]), [Promise.reject(1), Promise.resolve(2)], [1, &#x27;1&#x27;, true, false, null, undefined, &#123;&#125;, function()&#123;&#125;, Symbol(), Promise.resolve(2)]].forEach(item =&gt; &#123; Promise.any(item).then(v =&gt; &#123; console.log(v) &#125;).catch(r =&gt; &#123; console.log(&#x27;in catch &#x27; + r) &#125;)&#125;) Promise.racePromise.race 是只要有一个 Promise 产生结果时就会执行 then 方法的回调！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Promise.race(iterable) 方法返回一个 promise， * 一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝 * resolve([value,...]) * reject(firstReject) * @param &#123;*&#125; iterable * @returns promise */Promise.race = function (iterable) &#123; return new Promise(function(resolve, reject)&#123; var iteratee = iterable[Symbol.iterator]() var res = null var done = false while (true)&#123; res = iteratee.next() if(res.done) break var val = !(res.value instanceof Promise) ? Promise.resolve(res.value) : res.value val.then(function(value)&#123; if(done) return done = true resolve(value) &#125;, function(reason)&#123; if(done) return done = true reject(reason) &#125;) &#125; &#125;)&#125;;Promise.race = function (iterable) &#123; return new Promise(function(resolve, reject)&#123; const promiseList = [...iterable] let done = false promiseList.forEach(val =&gt; &#123; val = !(val instanceof Promise) ? Promise.resolve(val) : val val.then(value =&gt; &#123; if(done) return done = true resolve(value) &#125;, reason =&gt; &#123; if(done) return done = true reject(reason) &#125;) &#125;) &#125;)&#125;; Promise.allSettledPromise.allSettled 返回一个在所有给定的promise都已经fulfilled或rejected后的promise 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise * 并带有一个对象数组，每个对象表示对应的promise结果 * resolve([value,...]) * @param &#123;*&#125; iterable * @returns promise */Promise.allSettled = function (iterable) &#123; return new Promise(function(resolve)&#123; var iteratee = iterable[Symbol.iterator]() var res = null var i = 0 var len = 0 var result = [] var allSettled = function()&#123; i++ if(len &lt;= i &amp;&amp; res.done) resolve(result) &#125; while (true)&#123; res = iteratee.next() if(res.done) break !(function(j)&#123; var val = !(res.value instanceof Promise) ? Promise.resolve(res.value) : res.value val.then(function(value)&#123; result[j] = &#123; value: value, status: &#x27;fulfilled&#x27; &#125; allSettled() &#125;, function(reason)&#123; result[j] = &#123; reason: reason, status: &#x27;rejected&#x27; &#125; allSettled() &#125;) &#125;(len)) len += 1 &#125; &#125;)&#125;;Promise.allSettled = function (iterable) &#123; return new Promise(resolve =&gt; &#123; const promiseList = [...iterable] const result = [] const len = promiseList.length let j = 0 var allSettled = () =&gt; len &lt;= ++j &amp;&amp; resolve(result) promiseList.forEach((val, i) =&gt; &#123; var val = !(val instanceof Promise) ? Promise.resolve(val) : val val.then(value =&gt; &#123; result[i] = &#123; value: value, status: &#x27;fulfilled&#x27; &#125; allSettled() &#125;, reason =&gt; &#123; result[i] = &#123; reason: reason, status: &#x27;rejected&#x27; &#125; allSettled() &#125;) &#125;) &#125;)&#125;; 搞定收工！ 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://luoyuda.github.io/tags/Promise/"}]},{"title":"200 行逐行分解 Promise 模拟实现（ES6）","slug":"JavaScript/promise-02","date":"2022-04-01T09:50:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/04/01/JavaScript/promise-02/","link":"","permalink":"https://luoyuda.github.io/2022/04/01/JavaScript/promise-02/","excerpt":"","text":"再看不懂你就来砍我吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// 如何快速写一个 Promisevar MyPromise = (function() &#123; // 1. 三种状态 var PENDING = &#x27;pending&#x27;; var FULFILLED = &#x27;fulfilled&#x27;; var REJECTED = &#x27;rejected&#x27;; /** * 2. `Promise constructor` 是一个函数，通过 `new` 操作符调用，接受一个立即执行的函数作为参数 * @param &#123;function&#125; executor * @returns Promise */ function _Promise(executor)&#123; var p = this // 3. 初始化状态，成功，失败异步队列 p.status = PENDING p.value = null p.reason = null p.onFulfilled = [] p.onRejected = [] try &#123; // 4. 立即执行这个函数，并给这个函数传入两个入参(resolve, reject)用于改变 promise 状态 executor(function(value)&#123; // 5. resolvePromise 通过此方法接着解决 promise resolvePromise(p, value) &#125;, function(reason)&#123; rejectPromise(p, reason) &#125;) &#125; catch (error) &#123; rejectPromise(p, error) &#125; // 返回一个 Promise 实例 return p &#125; /** * 6. then 方法接受两个回调方法，并返回一个新的 promise 对象 * @param &#123;function&#125; onFulfilled 成功回调 * @param &#123;function&#125; onRejected 失败回调 * @returns promise */ _Promise.prototype.then = function(onFulfilled, onRejected)&#123; // 7. 需要对回调方法进行兼容 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : function(value)&#123; return value &#125; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function(reason)&#123; throw reason &#125; // 8. 当前的 `promise` 实例 var p1 = this // 9. 返回一个新的 `promise` 实例 var p2 = new MyPromise(function()&#123;&#125;) // 10. 注册微任务事件 function fulfilled()&#123; // 注册一个微任务 queueMicrotask(function()&#123; try &#123; var x = onFulfilled(p1.value) // 这里得注意要使用 p2 resolvePromise(p2, x) &#125; catch (error) &#123; rejectPromise(p2, error) &#125; &#125;) &#125; function rejected()&#123; queueMicrotask(function()&#123; try &#123; var x = onRejected(p1.reason) resolvePromise(p2, x) &#125; catch (error) &#123; rejectPromise(p2, error) &#125; &#125;) &#125; // 判断状态 var status = p1.status if(status === PENDING)&#123; // 推入队列中 p1.onFulfilled.push(fulfilled) p1.onRejected.push(rejected) &#125;else if(status === FULFILLED)&#123; // 立即执行 fulfilled() &#125;else if(status === REJECTED)&#123; // 立即执行 rejected() &#125; // 返回一个新的 promise 实例 return p2 &#125; /** * 15. 补一个 runCb 方法执行回调函数 * @param &#123;function[]&#125; cbs * @param &#123;any&#125; val */ function runCbs(cbs, val)&#123; cbs.forEach(function(cb)&#123; cb(val) &#125;) &#125; // 11. 接着来写三个处理promise状态的函数 /** * 16. 失败的 promise 处理方法 * @param &#123;promise&#125; p promise 实例 * @param &#123;any&#125; reason 失败原因 * @returns */ function rejectPromise(p, reason)&#123; // 12. rejected 的时候得这么做呢？首先判断当前状态是否为 PENDING if(p.status !== PENDING) return // 13. 更改状态，保存 reason p.status = REJECTED p.reason = reason // 14. 依次执行 onRejected 中的回调方法 runCbs(p.onRejected, p.reason) &#125; /** * 17. 成功的 promise 处理方法 * @param &#123;promise&#125; p promise 实例 * @param &#123;any&#125; value */ function fulfillPromise(p, value)&#123; // 18. 同样的，判断状态，更改状态，保存值，执行函数 if(p.status !== PENDING) return p.status = FULFILLED p.value = value runCbs(p.onFulfilled, p.value) &#125; /** * promise resolve 程序，核心 * @param &#123;promise&#125; p 需要被解决的 promise 实例 * @param &#123;any&#125; x */ function resolvePromise(p, x)&#123; // 19. 禁止递归调用 if(p === x) return rejectPromise(p, new TypeError(&#x27;same&#x27;)) // 20. 如果 x 是一个 promise 实例的情况 if(x instanceof MyPromise)&#123; // 21. 如果 x 还是一个等待中的状态，往 then 增加回调处理 if(x.status === PENDING)&#123; x.then(function(value)&#123; resolvePromise(p, value) &#125;, function(reason)&#123; rejectPromise(p, reason) &#125;) &#125;else if(x.status === FULFILLED)&#123; // 22. 如果是一个已成功的状态，直接使用成功的处理方法 fulfillPromise(p, x.value) &#125;else if(x.status === REJECTED)&#123; // 23. 如果是一个已失败的状态，直接使用失败的处理方法 rejectPromise(p, x.reason) &#125; &#125;else if(x &amp;&amp; (typeof x === &#x27;function&#x27; || typeof x === &#x27;object&#x27;))&#123; // 25. 这里是处理 thenable 的情况 var then try &#123; then = x.then &#125; catch (error) &#123; // 26. 报错则直接失败 rejectPromise(p, error) &#125; if(typeof then === &#x27;function&#x27;)&#123; // 这里需要只调用一次 var done = false try &#123; // 调用 then then.call(x, function(y)&#123; if(done) return done = true // 接着解决 resolvePromise(p, y) &#125;, function(reason)&#123; if(done) return done = true rejectPromise(p, reason) &#125;) &#125; catch (error) &#123; if(done) return done = true rejectPromise(p, error) &#125; &#125;else&#123; // 27. 如果不是一个函数,则直接成功 fulfillPromise(p, x) &#125; &#125;else&#123; // 24. 其他情况都算成功 fulfillPromise(p, x) &#125; &#125; return _Promise&#125;)();// npm i --save promises-aplus-tests &amp;&amp; promises-aplus-tests index.js// 就可以测试是否符合 Promise A+ 规范MyPromise.deferred = function()&#123; var result = &#123;&#125; result.promise = new MyPromise(function(resolve, reject)&#123; result.resolve = resolve result.reject = reject &#125;) return result&#125;module.exports = MyPromise 关于 then 方法的规范 流转图 再贴一个 ES6 的实现 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://luoyuda.github.io/tags/Promise/"}]},{"title":"Symbol 不完全模拟实现（ES6）","slug":"JavaScript/Symbol","date":"2022-04-01T05:00:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2022/04/01/JavaScript/Symbol/","link":"","permalink":"https://luoyuda.github.io/2022/04/01/JavaScript/Symbol/","excerpt":"","text":"symbol 是 ES6 中新增的基本类型，通过 Symbol() 函数返回 symbol 类型的值，值是唯一的。Symbol类似于内建对象类，无法作为构造器使用！ 实现先一组目标 12345678910111213141516171819202122232425262728293031323334const types = [1, &#x27;1&#x27;, false, true, undefined, null, NaN, &#123;&#125;, [], function()&#123;&#125;]const createSymbols = (fn, test) =&gt; &#123; return test.map(item =&gt; fn(item)).reduce((prev, item) =&gt; &#123; prev[item] = String(item) return prev &#125;, &#123;&#125;)&#125;const tests = [...types, ...types]console.log(createSymbols(Symbol, tests))/*&#123; [Symbol(1)]: &#x27;Symbol(1)&#x27;, [Symbol(1)]: &#x27;Symbol(1)&#x27;, [Symbol(false)]: &#x27;Symbol(false)&#x27;, [Symbol(true)]: &#x27;Symbol(true)&#x27;, [Symbol()]: &#x27;Symbol()&#x27;, [Symbol(null)]: &#x27;Symbol(null)&#x27;, [Symbol(NaN)]: &#x27;Symbol(NaN)&#x27;, [Symbol([object Object])]: &#x27;Symbol([object Object])&#x27;, [Symbol()]: &#x27;Symbol()&#x27;, [Symbol(function()&#123;&#125;)]: &#x27;Symbol(function()&#123;&#125;)&#x27;, [Symbol(1)]: &#x27;Symbol(1)&#x27;, [Symbol(1)]: &#x27;Symbol(1)&#x27;, [Symbol(false)]: &#x27;Symbol(false)&#x27;, [Symbol(true)]: &#x27;Symbol(true)&#x27;, [Symbol()]: &#x27;Symbol()&#x27;, [Symbol(null)]: &#x27;Symbol(null)&#x27;, [Symbol(NaN)]: &#x27;Symbol(NaN)&#x27;, [Symbol([object Object])]: &#x27;Symbol([object Object])&#x27;, [Symbol()]: &#x27;Symbol()&#x27;, [Symbol(function()&#123;&#125;)]: &#x27;Symbol(function()&#123;&#125;)&#x27;&#125;*/ 唯一值可以通过引用类型实现，通过 toString 方法控制输出 1234567891011121314151617181920212223var MySymbol = (function()&#123; // 只要引用不同就不会比较相等 function _Symbol(description)&#123; // 不能被new调用 if(this instanceof _Symbol) throw new TypeError(&#x27;Symbol is not a constructor&#x27;) var desc = description === undefined ? &#x27;&#x27; : String(description) var symbol = Object.create(&#123; toString: function()&#123; return &#x27;Symbol (&#x27; + this._description + &#x27;)&#x27; &#125; &#125;) Object.defineProperties(symbol, &#123; &#x27;_description&#x27;: &#123; value: desc, writable: false, enumerable: false, configurable: false &#125; &#125;) return symbol &#125; return _Symbol&#125;)(); 理想很丰富，现实很骨感，确实没法用字符串去规避掉作为键值的重复 只能加个 id 维持一下生活了 1234567891011121314151617181920212223242526272829303132333435363738var MySymbol = (function()&#123; var generateString = (function()&#123; var id = 0 return function(desc)&#123; return &#x27;Symbol(&#x27; + (id++) + &#x27;) (&#x27; + desc + &#x27;)&#x27; &#125; &#125;)(); function generateId(val)&#123; return &#x27;Symbol (&#x27; + this._description + &#x27;)&#x27; &#125; // 只要引用不同就不会比较相等 function _Symbol(description)&#123; // 不能被new调用 if(this instanceof _Symbol) throw new TypeError(&#x27;Symbol is not a constructor&#x27;) var desc = description === undefined ? &#x27;&#x27; : String(description) var symbol = Object.create(&#123; toString: function()&#123; return this._name &#125; &#125;) Object.defineProperties(symbol, &#123; &#x27;_description&#x27;: &#123; value: desc, writable: false, enumerable: false, configurable: false &#125;, &#x27;_name&#x27;: &#123; value: generateString(desc), writable: false, enumerable: false, configurable: false &#125; &#125;) return symbol &#125; return _Symbol&#125;)(); 抛开 id 不谈，假装我们已经实现了（doge） 接着得看下 for 和 keyFor 该如何实现 Symbol.for()根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局 symbol 注册表中！ 12345var symbolTable = &#123;&#125;_Symbol.for = function(description)&#123; return symbolTable[description] ? symbolTable[description] : symbolTable[description] = _Symbol(description)&#125; Symbol.keyFor()获取全局 symbol 注册表中与某个 symbol 关联的键，通过 Symbol.For 注册的值哦！ 123456_Symbol.keyFor = function(symbol)&#123; for (var key in symbolTable) &#123; if(symbolTable[key] === symbol) return key &#125; return undefined&#125; 这样就好了吗？现实很骨感啊 因为对象键值存储会进行 String() 的类型转换，为了尽可能接近，我们只好用双数组的方法了 12345678910111213141516171819202122var _symbolKey = []var _symbolValue = []_Symbol.for = function(description)&#123; var i = 0 var len = _symbolKey.length while (i &lt; len) &#123; if(_symbolKey[i] === description) return _symbolValue[i] i++ &#125; _symbolKey.push(description) _symbolValue.push(_Symbol(description)) return _symbolValue[i]&#125;_Symbol.keyFor = function(symbol)&#123; var i = 0 var len = _symbolValue.length while (i &lt; len) &#123; if(symbol === _symbolValue[i]) return _symbolKey[i] i++ &#125; return undefined&#125; 123456789// 测试用例types.map(item =&gt; (&#123; item, symbol: MySymbol.for(item) &#125;)).forEach((&#123; item, symbol &#125;) =&gt; &#123; let sym = MySymbol.keyFor(symbol) if(!(sym === item))&#123; if(sym !== sym) return console.log(&#x27;no pass&#x27;) console.log(item, sym, String(symbol)) &#125;&#125;) 搞定，完成（并不完全模拟） 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"Symbol","slug":"Symbol","permalink":"https://luoyuda.github.io/tags/Symbol/"}]},{"title":"Map 模拟实现（ES6）","slug":"JavaScript/Map","date":"2022-03-31T11:50:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2022/03/31/JavaScript/Map/","link":"","permalink":"https://luoyuda.github.io/2022/03/31/JavaScript/Map/","excerpt":"","text":"Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值可以作为一个键或一个值 实现先写好骨架 123456789101112131415161718192021222324252627282930313233343536373839404142434445var MyMap = (function()&#123; // 处理 NaN var symbolNaN = Symbol(&#x27;NaN&#x27;) function _encode(val)&#123; return val !== val ? symbolNaN : val &#125; function _decode(val)&#123; return val === symbolNaN ? NaN : val &#125; // 迭代器相关，参考 Set ，不重复写了 function _forOf(obj, cb)&#123; if(typeof obj[Symbol.iterator] !== &#x27;function&#x27;) throw new TypeError(&#x27;Symbol.iterator is not a function&#x27;) if(typeof cb !== &#x27;function&#x27;) throw new TypeError(&#x27;cb is not a function&#x27;) var iteratee = obj[Symbol.iterator]() var res while(true)&#123; res = iteratee.next() if(res.done) break cb(res.value) &#125; &#125; function _createIterator(list, iterator)&#123; var next = 0 var obj = &#123; next: function()&#123; return next &lt; list.length ? &#123; done: false, value: iterator(list[next++]) &#125; : &#123; done: true, value: undefined &#125; &#125;, &#125; obj[Symbol.iterator] = function()&#123; return obj &#125; return obj &#125; function _Map(values)&#123;&#125; _Map.prototype.has = function(key)&#123;&#125; _Map.prototype.set = function(key, val)&#123;&#125; _Map.prototype.get = function(key)&#123;&#125; _Map.prototype.delete = function(key)&#123;&#125; _Map.prototype.clear = function()&#123;&#125; _Map.prototype.keys = function()&#123;&#125; _Map.prototype.values = function()&#123;&#125; _Map.prototype.entries = function()&#123;&#125; _Map.prototype.forEach = function(fn, context)&#123;&#125; return _Map&#125;)(); 构造函数接受一组可迭代器对象，使用双数组分别存储 key 和 value，一一映射 123456789101112131415161718192021/** * 构造函数 * @param &#123;*&#125; values 迭代器对象 */function _Map(values)&#123; var self = this this._key = [] this._value = [] // size 是可访问属性，用于返回 一个Map 对象的成员数量 Object.defineProperty(self, &#x27;size&#x27;, &#123; enumerable: false, configurable: false, get()&#123; return self._key.length &#125; &#125;) _forOf(values, function(val)&#123; if(typeof val !== &#x27;object&#x27;) throw new TypeError(&#x27;value must be an object&#x27;) self.set(val[0], val[1]) &#125;)&#125; hasmap 中是否存在指定元素 12345678/** * 方法has() 返回一个bool值，用来表明map 中是否存在指定元素 * @param &#123;any&#125; key * @returns Boolean 如果指定元素存在于Map中，则返回true。其他情况返回false */_Map.prototype.has = function(key)&#123; return this._key.indexOf(_encode(key)) !== -1&#125; set为 map 添加记录 1234567891011121314/** * set() 方法为 Map 对象添加或更新一个指定了键（key）和值（value）的（新）键值对 * @param &#123;any&#125; key * @param &#123;any&#125; val * @returns Map 对象 */_Map.prototype.set = function(key, val)&#123; key = _encode(key) var i = this._key.indexOf(key) if(i === -1) i = this.size this._key[i] = key this._value[i] = val return this&#125; get获取 map 中的某个元素 1234567891011/** * get() 方法返回某个 Map 对象中的一个指定元素。 * @param &#123;any&#125; key * @returns value || undefined */_Map.prototype.get = function(key)&#123; key = _encode(key) var i = this._key.indexOf(key) if(i === -1) return undefined return this._value[i]&#125; delete移除 map 中的元素 12345678910111213/** * delete() 方法用于移除 Map 对象中指定的元素 * @param &#123;any&#125; key * @returns Boolean 如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false */_Map.prototype.delete = function(key)&#123; key = _encode(key) var i = this._key.indexOf(key) if(i === -1) return false this._key.splice(i, 1) this._value.splice(i, 1) return true&#125; clear清除 map 中所有元素 1234567/** * clear()方法会移除Map对象中的所有元素。 */_Map.prototype.clear = function()&#123; this._key = [] this._value = []&#125; keys &amp; values &amp; entries &amp; forEach1234567891011121314151617181920212223242526272829303132333435363738394041/** * keys() 返回一个引用的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的key值。 * @returns 一个新的 Map 可迭代对象 */_Map.prototype.keys = function()&#123; return _createIterator(this._key, function(key)&#123; return _decode(key) &#125;)&#125;/** * values() 方法返回一个新的Iterator对象。它包含按顺序插入Map对象中每个元素的value值。 * @returns 一个新的 Map 可迭代对象 */_Map.prototype.values = function()&#123; return _createIterator(this._value, function(value)&#123; return value &#125;)&#125;/** * entries() 方法返回一个新的包含 [key, value] 对的 Iterator 对象 * 返回的迭代器的迭代顺序与 Map 对象的插入顺序相同 * @returns 一个新的 Map 迭代器对象 */_Map.prototype.entries = function()&#123; var res = [] var len = this._key.length var i = 0 while(i &lt; len)&#123; res[i] = [_decode(this._key[i]), this._value[i++]] &#125; return _createIterator(res, function(entry)&#123; return entry &#125;)&#125;/** * forEach() 方法按照插入顺序依次对 Map 中每个键/值对执行一次给定的函数 * @param &#123;function&#125; fn * @param &#123;any&#125; context */_Map.prototype.forEach = function(fn, context)&#123; var i = 0 var len = this._key.length while(i &lt; len)&#123; fn.call(context, _decode(this._key[i]), this._value[i++], this) &#125;&#125; 补上迭代器补丁，完成1234_Map.prototype[Symbol.iterator] = function()&#123; return this.entries()&#125;return _Map 测试一波123456789101112const m1 = new MyMap([[1,2]])console.log(m1.has(1))console.log(m1.set(1, 3))console.log(m1.set(NaN, 4))console.log(m1.get(NaN))console.log(m1.set(NaN, 5))console.log(m1.get(NaN))console.log([...m1.keys()])console.log([...m1.values()])console.log([...m1.entries()])console.log([...m1])m1.forEach(console.log) 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"Map","slug":"Map","permalink":"https://luoyuda.github.io/tags/Map/"}]},{"title":"Set 模拟实现（ES6）","slug":"JavaScript/Set","date":"2022-03-31T11:23:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2022/03/31/JavaScript/Set/","link":"","permalink":"https://luoyuda.github.io/2022/03/31/JavaScript/Set/","excerpt":"","text":"Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用，值的集合 实现先把程序骨架写好 123456789101112131415var MySet = (function()&#123; var symbolNaN = Symbol(&#x27;NaN&#x27;); function _encode(val)&#123;&#125; function _decode(val)&#123;&#125; function _createIterator(list, iterator)&#123;&#125; function _Set(values)&#123; &#125; _Set.prototype.has = function(val)&#123;&#125; _Set.prototype.delete = function(val)&#123;&#125; _Set.prototype.clear = function()&#123;&#125; _Set.prototype.entries = function()&#123;&#125; _Set.prototype.values = function()&#123;&#125; _Set.prototype.forEach = function(fn, context) &#123;&#125; _Set.prototype[Symbol.iterator] = function()&#123;&#125; return _Set&#125;)(); 构造函数构造函数接受一个迭代器对象，并将其顺序插入到集合中 12345678910111213141516171819202122232425262728// 迭代器遍历方法function _forOf(obj, cb)&#123; if(typeof obj[Symbol.iterator] !== &#x27;function&#x27;) throw new TypeError(obj + &#x27;is not a iterable&#x27;) if(typeof cb !== &#x27;function&#x27;) throw new TypeError(&#x27;cb is not a function&#x27;) var iterable = obj[Symbol.iterator]() var res while(true)&#123; res = iterable.next() if(res.done) break cb(res.value) &#125;&#125;// 构造函数function _Set(values)&#123; var self = this self._set = [] Object.defineProperty(self, &#x27;size&#x27;, &#123; enumerable: false, configurable: false, get()&#123; return self._set.length &#125; &#125;) _forOf(values, function(val)&#123; self.add(val) &#125;) return self&#125; add先判断是否存在，然后往里面写入，这里需要注意的一点是 NaN 的情况 NaN != NaN 这是什么大坑 通过 _encode 和 _decode 方法进行处理 123456789101112131415var symbolNaN = Symbol(&#x27;NaN&#x27;); // 处理NaNfunction _encode(val)&#123; return val !== val ? symbolNaN : val;&#125;function _decode(val)&#123; return val === symbolNaN ? NaN : val; &#125;// 在Set对象尾部添加一个元素。返回该Set对象。_Set.prototype.add = function(val)&#123; if(!this.has(val))&#123; // 插入时 encode，读取时 decode this._set.push(_encode(val)) &#125; return this&#125; has1234// 返回一个布尔值，表示该值在Set中存在与否_Set.prototype.has = function(val)&#123; return this._set.indexOf(_encode(val)) !== -1&#125; delete12345678910// 移除Set中与这个值相等的元素，返回Set.prototype.has(value)// 在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。// Set.prototype.has(value)在此后会返回false。_Set.prototype.delete = function(val)&#123; if(!this.has(val)) return false val = _encode(val) let i = this._set.indexOf(val) this._set.splice(i, 1) return true&#125; clear1234// 移除Set对象内的所有元素。_Set.prototype.clear = function()&#123; this._set = []&#125; entries &amp; values这两个方法是返回迭代器对象 迭代器是一个对象，它定义一个序列，并在终止时可能返回一个返回值。 更具体地说，迭代器是通过使用 next() 方法实现 Iterator protocol 的任何一个对象，该方法返回具有两个属性的对象： value，这是序列中的 next 值；和 done ，如果已经迭代到序列中的最后一个值，则它为 true 。如果 value 和 done 一起存在，则它是迭代器的返回值 简单带你说就是通过 next() 方法去访问下一个值，直到 done 为 true 停止 12345678910111213// 创建迭代器对象function _createIterator(list, iterator)&#123; var next = 0 var obj = &#123; next: function()&#123; return next &lt; list.length ? &#123; done: false, value: iterator(list[next++]) &#125; : &#123; done: true, value: undefined &#125; &#125; &#125; obj[Symbol.iterator] = function() &#123; return obj &#125; return obj&#125; 有了这个生成迭代器方法，我们就可以根据规范去编写 12345678// 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组_Set.prototype.entries = function()&#123; return _createIterator(this._set, function(val)&#123; return [_decode(val), _decode(val)]&#125;)&#125;// 返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值_Set.prototype.values = function()&#123; return _createIterator(this._set, function(val)&#123; return _decode(val)&#125;)&#125; 注意 Set 对象也是一个迭代器对象 1234// 声明为迭代器对象_Set.prototype[Symbol.iterator] = function()&#123; return this.values();&#125; forEach1234567// 按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。_Set.prototype.forEach = function(fn, context) &#123; for (var i = 0; i &lt; this._set.length; i++) &#123; var val = _decode(this._set[i]) fn.call(context, val, val, this) &#125;&#125; 大功告成，简单写一个测试试试看1234567891011121314151617181920212223242526272829303132333435363738let arr = [1,2,3,4,NaN,1,2,3,4,NaN]let mySet = new MySet(arr)let set = new Set(arr)let myResult = []let result = []mySet.forEach((...args) =&gt; &#123; myResult.push(args)&#125;)set.forEach((...args) =&gt; &#123; result.push(args)&#125;)myResult.push([...mySet])result.push([...set])for (const val of set.entries()) &#123; result.push(val)&#125;for (const val of set.values()) &#123; result.push(val)&#125;for (const val of mySet.entries()) &#123; myResult.push(val)&#125;for (const val of mySet.values()) &#123; myResult.push(val)&#125;myResult.push(mySet.has(NaN))myResult.push(mySet.delete(NaN))myResult.push(mySet.has(NaN))myResult.push(mySet.delete(NaN))myResult.push(mySet)result.push(set.has(NaN))result.push(set.delete(NaN))result.push(set.has(NaN))result.push(set.delete(NaN))result.push(set)console.log(myResult)console.log(result) 完全一致! 源码地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"Set","slug":"Set","permalink":"https://luoyuda.github.io/tags/Set/"}]},{"title":"二分查找 - 算法（JavaScript）","slug":"algorithm/binarySearch","date":"2022-03-30T11:23:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2022/03/30/algorithm/binarySearch/","link":"","permalink":"https://luoyuda.github.io/2022/03/30/algorithm/binarySearch/","excerpt":"","text":"二分查找 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半 讲人话就是：每次都取中间元素，直到左右指针互相碰撞时为止 应用一般用于一组有序元素的查找，例如一组学生中找到分数等于85的那个同学 704. 二分查找 binarySearch 方法12345678910/** * binarySearch * @param &#123;number[]&#125; list 已经排序数组 * @param &#123;number&#125; target 查找对象 * @return &#123;number&#125; 找到返回下标，没找到返回 -1 */function binarySearch(list, target)&#123; &#125; 先写测试用例写一个跑测试用例的方法，接收一组测试用例和执行函数，当不匹配时打印 1234567891011121314151617const runTests = (tests, fn) =&gt; &#123; let pass = tests.every(( &#123; input, output &#125; ) =&gt; &#123; const result = fn(...input); if(!(JSON.stringify(result) === JSON.stringify(output)))&#123; console.log(input, output, result); return false; &#125; return true &#125;) return console.log(pass ? &#x27;通过&#x27; : &#x27;gg&#x27;)&#125;const Tests = [ ]runTests(Tests, binarySearch) Tests要怎么写？一个个写显然太麻烦可以这样写 1234567891011121314const Tests = [ ...new Array(12).fill(0) .map((item, index) =&gt; (&#123; input:[new Array(10).fill(0).map((item, i) =&gt; i), index], output: index &gt; 9 ? -1 : index &#125;))][ &#123; input: [ [0,1,2,3,4,5,6,7,8,9], 0 ], output: 0 &#125;, ... &#123; input: [ [0,1,2,3,4,5,6,7,8,9], 9 ], output: 9 &#125;, ... &#123; input: [ [0,1,2,3,4,5,6,7,8,9], 11 ], output: -1 &#125;] 当然你也可以加些间隔 1234567891011121314const Tests = [ ...new Array(11).fill(0).map((item, index) =&gt; (&#123; input:[new Array(10).fill(0).map((item, i) =&gt; i * 5), index * 5], output: index &gt; 9 ? -1 : index &#125;))][ &#123; input: [ [0,5,10,15,20,25,30,35,40,45], 0 ], output: 0 &#125;, ... &#123; input: [ [0,5,10,15,20,25,30,35,40,45], 45 ], output: 9 &#125;, ... &#123; input: [ [0,5,10,15,20,25,30,35,40,45], 55 ], output: -1 &#125;,] 直接抽离成函数 12345678910const createTests = (len, gap, other) =&gt; new Array(len + other).fill(0).map((item, index) =&gt; (&#123; input:[new Array(len).fill(0).map((item, i) =&gt; i * gap), index * gap], output: index &gt; len - 1 ? -1 : index&#125;))const Tests = [ ...createTests(10, 1, 2), ...createTests(10, 5, 2),] 开始编码定义左右指针i,j 当满足 while 时证明已经找到&#x2F;没法再找了 12345678function binarySearch(list, target)&#123; let l = 0 let r = list.length - 1 while(l &lt; r)&#123; &#125; return list[l] === target ? l : -1&#125; 接着写循环里面内容 计算出中间元素下标 判断中间元素缩短查找范围 12345while(l &lt; r)&#123; let mid = l + ((r - l) &gt;&gt; 1) if(list[mid] &gt;= target) r = mid else l = mid + 1&#125; 这个写法是判断右边元素往左边靠拢的写法，当遇到重复的有序数组，例如 [0,1,1,1,1,2]会找到第一个 1 的位置，如果要找到最后一个 1 要怎么写？ 反过来写就行拉 12345678910111213141516/** * binarySearch * @param &#123;number[]&#125; list 已经排序数组 * @param &#123;number&#125; target 查找对象 * @return &#123;number&#125; 找到返回下标，没找到返回 -1 */function binarySearch(list, target)&#123; let l = 0 let r = list.length - 1 while(l &lt; r)&#123; let mid = l + ((r - l + 1) &gt;&gt; 1) // 这里得处理下溢出的情况 if(list[mid] &lt;= target) l = mid // 左往右缩范围 else r = mid - 1 &#125; return list[l] === target ? l : -1&#125; 源码地址 博客地址","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"https://luoyuda.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"Generator 与 Co 模块理解（ES6）","slug":"Generator/01","date":"2022-03-20T11:23:00.000Z","updated":"2022-03-20T11:23:00.000Z","comments":true,"path":"2022/03/20/Generator/01/","link":"","permalink":"https://luoyuda.github.io/2022/03/20/Generator/01/","excerpt":"","text":"源码地址 是什么Generator 是 ES6 提供的一种异步编程解决方案，是协程的一种实现，本质是状态机的一种实现，封装了多个内部状态 执行函数后会返回一个遍历器对象，依次遍历函数内部中的每一个状态 语法 通过 *function()&#123;&#125; 声明为一个 Generator 函数 通过 yield 关键字作为暂停标志 换句话说就是 next() 执行到下一个 yield &#x2F; return时停止 返回 &#123; value: 表示当前的内部状态的值, done: 表示是否遍历完毕 &#125; 1234567891011121314151617function *genFunc()&#123; console.log(&#x27;before yield 1&#x27;) yield 1 console.log(&#x27;before yield 2&#x27;) yield 2 console.log(&#x27;before yield 3&#x27;) yield 3 console.log(&#x27;before return 4&#x27;) return 4&#125;const gen = genFunc()console.log(gen.next()) // before yield 1 &#123; value: 1, done: false &#125;console.log(gen.next()) // before yield 2 &#123; value: 2, done: false &#125;console.log(gen.next()) // before yield 3 &#123; value: 3, done: false &#125;console.log(gen.next()) // before return 1 &#123; value: 4, done: true &#125;console.log(gen.next()) // &#123; value: undefined, done: true &#125;console.log(gen.next()) // &#123; value: undefined, done: true &#125; 如果传参数会是怎么样的 1234567891011121314151617181920212223242526function *genFunc(x)&#123; console.log(`before yield x + 1 x = $&#123;x&#125;`) var y = yield (x + 1) console.log(`before yield y + 1 x = $&#123;x&#125; y = $&#123;y&#125;`) var z = yield (y + 1) console.log(`before yield z + 1 x = $&#123;x&#125; y = $&#123;y&#125; z = $&#123;z&#125;`) var i = yield (z + 1) console.log(`before return x = $&#123;x&#125; y = $&#123;y&#125; z = $&#123;z&#125; i = $&#123;i&#125;`) return i&#125;const a = genFunc(5)// 第一次传递参数是无效的，传递的参数表示上一个yield表达式的返回值！value = x + 1console.log(a.next(4)) // before yield x + 1 x = 5 &#123; value: 6, done: false &#125; // 传入 3 y = 3，value = y + 1 = 4console.log(a.next(3)) // before yield y + 1 x = 5 y = 3 &#123; value: 4, done: false &#125;// 传入 2 z = 2, value = z + 1 = 2console.log(a.next(2)) // before yield z + 1 x = 5 y = 3 z = 2 &#123; value: 3, done: false &#125;// 传入 1 i = 1, value = i + 1 = 1console.log(a.next(1)) // before return x = 5 y = 3 z = 2 i = 1 &#123; value: 1, done: true &#125;const b = genFunc()console.log(b.next()) // before yield x + 1 x = undefined &#123; value: NaN, done: false &#125;console.log(b.next()) // before yield y + 1 x = undefined y = undefined &#123; value: NaN, done: false &#125;console.log(b.next()) // before yield z + 1 x = undefined y = undefined z = undefined &#123; value: NaN, done: false &#125;console.log(b.next()) // before return x = undefined y = undefined z = undefined i = undefined &#123; value: undefined, done: true &#125; 模拟过程（极简）123456789101112function *genFunc()&#123; console.log(&#x27;before yield 1&#x27;) var a = yield 1 console.log(`before yield 2 a = $&#123;a&#125;`) var b = yield (a + 1) console.log(`before return b = $&#123;b&#125;`) return a + b&#125;const gen = genFunc()console.log(gen.next()) // before yield 1 &#123; value: 1, done: false &#125;console.log(gen.next(2)) // before yield 2 a = 2 &#123; value: 3, done: false &#125;console.log(gen.next(3)) // before return b = 3 &#123; value: 5, done: true &#125; 通过 babel 编译后 1234567891011121314151617181920212223242526272829var _marked = /*#__PURE__*/regeneratorRuntime.mark(genFunc);function genFunc() &#123; var a, b; return regeneratorRuntime.wrap(function genFunc$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: console.log(&#x27;before yield 1&#x27;); _context.next = 3; return 1; case 3: a = _context.sent; console.log(&quot;before yield 2 a = &quot;.concat(a)); _context.next = 7; return a + 1; case 7: b = _context.sent; console.log(&quot;before return b = &quot;.concat(b)); return _context.abrupt(&quot;return&quot;, a + b); case 10: case &quot;end&quot;: return _context.stop(); &#125; &#125; &#125;, _marked);&#125; 我们可以先忽略里面函数被转换的样子，先关注 regeneratorRuntime 对象提供两个方法 mark：包装后返回一个迭代器对象 warp：包装 gen 创建变量存储状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var regeneratorRuntime = (function () &#123; var end = &#123;&#125; // 用于后续判断 function makeInvokeMethod(innerFn, context) &#123; var state = &#x27;start&#x27; return function invoke(method, arg) &#123; if(state === &#x27;completed&#x27;) return &#123; value: undefined, done: true&#125; context.method = method context.arg = arg while(true)&#123; context.sent = context.arg; var arg = innerFn.call(null, context) state = context.done ? &quot;completed&quot; : &quot;yield&quot; if(arg === end)&#123; continue &#125; return &#123; value: arg, done: context.done &#125; &#125; &#125; &#125; return &#123; mark: function (genFun)&#123; genFun.prototype.next = function (arg) &#123; return this._invoke(&#x27;next&#x27;, arg) &#125; return genFun &#125;, wrap: function(innerFn, marked)&#123; var context = &#123; done: false, method: &#x27;next&#x27;, next: 0, prev: 0, sent: undefined, abrupt: function(type, arg)&#123; // 后续为 return 时调用 var record = &#123;&#125; record.type = type record.arg = arg return this.complete(record) &#125;, complete: function(record)&#123; // 完成后调用 if (record.type === &quot;return&quot;) &#123; this.rval = this.arg = record.arg; this.method = &quot;return&quot;; this.next = &quot;end&quot;; &#125; return end; &#125;, stop: function()&#123; // 遍历完成，停止 this.done = true return this.rval &#125; &#125; marked.prototype._invoke = makeInvokeMethod(innerFn, context); return marked.prototype &#125; &#125;&#125;)(); 如何让它自动执行呢？Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权，当任务都是同步任务的时候 123456789101112function *genFunc()&#123; yield 1 yield 2 return 3&#125;var gen = genFunc()var res = gen.next()while (!res.done)&#123; console.log(res.value) res = gen.next()&#125;console.log(res.value) 如果任务是异步的，这里的顺序执行 next 就显然是会出现问题 ThunkThunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式 1234567891011121314151617181920212223function asyncFn(x, callback)&#123; setTimeout(() =&gt; &#123; callback(x + 1) &#125;)&#125;function callback(x)&#123; console.log(`by callback: $&#123;x&#125;`)&#125;// 普通的调用方式asyncFn(1, callback)function Thunk(fn)&#123; return function()&#123; const args = Array.prototype.slice.call(arguments) return function(callback)&#123; args.push(callback) return fn.apply(this, args) &#125; &#125;&#125;const thunkAsync = Thunk(asyncFn)// thunkifythunkAsync(1)(callback) 改成这样有什么意义呢？callback放在后续传入有什么不一样吗？直接看代码！ 1234567891011121314151617181920function co(genF)&#123; var gen = genF() function next()&#123; var args = Array.prototype.slice.call(arguments) var res = gen.next.apply(gen, args) if(res.done) return res.value // 传入 next 作为 callback， 这就是实现 co 自动执行的关键！ // next 被触发时，异步任务已经得到结果，并执行下一个 gen.next ！ // 这也是为什么 co 是需要后面跟 Thunk 函数的原因！ res.value(next) &#125; next()&#125;function* genF()&#123; var i = yield thunkAsync(1) // 这里进行传参，执行后是需要传入 callback 才开始执行异步 var j = yield thunkAsync(2) console.log(i, j) return i + j&#125;co(genF) 如果理解了这个，下面这个 Promise 版本就很容易理解了 12345678910111213141516171819202122232425function asyncFn(x)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x + 1) &#125;) &#125;)&#125;function* genF()&#123; var i = yield asyncFn(1) var j = yield asyncFn(2) console.log(i, j) return i + j&#125;function co(genF)&#123; return new Promise((resolve) =&gt; &#123; var gen = genF() function step(next)&#123; let res = next(); if(res.done) return resolve(res.value) Promise.resolve(res.value).then(v =&gt; step(() =&gt; gen.next(v))) &#125; step(() =&gt; gen.next()) &#125;)&#125;co(genF) 再贴一个增加容错处理的 1234567891011121314151617181920function co(genF)&#123; return new Promise((res, rej) =&gt; &#123; const gen = genF() const step = nextF =&gt; &#123; let next try &#123; next = nextF() &#125; catch (error) &#123; rej(error) &#125; if(next.done) return res(next.value) Promise.resolve(next.value).then(v =&gt; &#123; step(() =&gt; gen.next(v)) &#125;, r =&gt; &#123; step(() =&gt; gen.throw(r)) &#125;) &#125; return step(() =&gt; gen.next()) &#125;)&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"异步处理","slug":"异步处理","permalink":"https://luoyuda.github.io/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"}]},{"title":"Vue 源码阅读（一）从打包开始阅读","slug":"Vue/01/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/01/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/01/README/","excerpt":"","text":"源码地址 从打包开始阅读Vue源码首先看 package.json 中的 script.build 定位到 build.js build.js 首先读取所有的构建内容， 然后执行 build 方法 递归执行并写入文件 分析构建入口得知运行时入口为 web/entry-runtime.js web/entry-runtime.js 入口引入 Vue 构造函数并暴露","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（二） Vue 初始化","slug":"Vue/02/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/02/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/02/README/","excerpt":"","text":"Vue 初始化当我们创建一个Vue实例时 创建Vue类：构造函数、原型方法、静态方法 创建Vue实例：初始化数据、事件、模板 12import Vue form &#x27;vue&#x27;const vueInstance = new Vue(options) Vue 类通过查看打包内容可知，Vue 构造函数在 src/platforms/web/entry-runtime.js 中 12import Vue from &#x27;./runtime/index&#x27;export default Vue 接着看 /src/platforms/web/runtime/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Vue from &#x27;core/index&#x27;import config from &#x27;core/config&#x27;import &#123; extend, noop &#125; from &#x27;shared/util&#x27;import &#123; mountComponent &#125; from &#x27;core/instance/lifecycle&#x27;import &#123; devtools, inBrowser &#125; from &#x27;core/util/index&#x27;import &#123; query, mustUseProp, isReservedTag, isReservedAttr, getTagNamespace, isUnknownElement&#125; from &#x27;web/util/index&#x27;import &#123; patch &#125; from &#x27;./patch&#x27;import platformDirectives from &#x27;./directives/index&#x27;import platformComponents from &#x27;./components/index&#x27;// 初始化平台相关的配置Vue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// 注册内置指令和组件extend(Vue.options.directives, platformDirectives) // v-show v-modelextend(Vue.options.components, platformComponents) // transition transitionGroup// 如果不是浏览器，patch不进行任何操作Vue.prototype.__patch__ = inBrowser ? patch : noop// 如果有 el 且浏览器环境，进行挂载操作Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125;if (inBrowser) &#123; // devtools 代码 忽略 ...&#125;export default Vue 这里实际上是对Vue构造函数进行一些基于原型上的扩展、平台代码、devtools代码的处理 接着进入 import Vue from &#39;core/index&#39; 1234567891011import Vue from &#x27;./instance/index&#x27;import &#123; initGlobalAPI &#125; from &#x27;./global-api/index&#x27;// 绑定全局方法到 Vue 构造函数中initGlobalAPI(Vue)// SSR 相关Vue.version = &#x27;__VERSION__&#x27;export default Vue 居然也不在这个文件中，接着往里面读 ./instance/index 123456789101112131415161718192021222324import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; // 如果不是New操作符调用弹出警告 this._init(options)&#125;// 往 prototype 上增加属性和方法initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue initMixin ：src/core/instance/init.js 添加了 _init 1234567initMixin(Vue)// src/core/instance/init.jsexport function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; // ... &#125;&#125; stateMixin： src/core/instance/state.js 添加了 $data、$props 、$watch、$set 、$delete 123456789stateMixin(Vue)// src/core/instance/state.jsexport function stateMixin (Vue: Class&lt;Component&gt;) &#123; Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef) Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef) Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function ()&#123;&#125;&#125; eventsMixin： src/core/instance/event.js 添加了 $on、$off 、$once、$emit 12345678eventsMixin(Vue)// src/core/instance/event.jsexport function eventsMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype.$on = function()&#123;&#125; Vue.prototype.$once = function()&#123;&#125; Vue.prototype.$off = function()&#123;&#125; Vue.prototype.$emit = function()&#123;&#125;&#125; lifecycleMixin： src/core/instance/lifecycle.js 添加了 _update、$forceUpdate 、$destroy 12345678lifecycleMixin(Vue)// src/core/instance/lifecycle.jsexport function lifecycleMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._update = function () &#123;&#125; Vue.prototype.$forceUpdate = function () &#123;&#125; Vue.prototype.$destroy = function () &#123;&#125; &#125;&#125; renderMixin： src/core/instance/render.js 添加了 RenderHelpers 、$nextTick、_render 1234567renderMixin(Vue)// src/core/instance/render.jsexport function renderMixin (Vue: Class&lt;Component&gt;) &#123; installRenderHelpers(Vue.prototype) Vue.prototype.$nextTick = function () &#123;&#125; Vue.prototype._render = function () &#123;&#125;&#125; 再回到 initGlobalAPI: src/core/global-api/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import config from &#x27;../config&#x27;import &#123; initUse &#125; from &#x27;./use&#x27;import &#123; initMixin &#125; from &#x27;./mixin&#x27;import &#123; initExtend &#125; from &#x27;./extend&#x27;import &#123; initAssetRegisters &#125; from &#x27;./assets&#x27;import &#123; set, del &#125; from &#x27;../observer/index&#x27;import &#123; ASSET_TYPES &#125; from &#x27;shared/constants&#x27;import builtInComponents from &#x27;../components/index&#x27;import &#123; observe &#125; from &#x27;core/observer/index&#x27;import &#123; warn, extend, nextTick, mergeOptions, defineReactive&#125; from &#x27;../util/index&#x27;export function initGlobalAPI (Vue: GlobalAPI) &#123; // 添加一个config 对象 const configDef = &#123;&#125; configDef.get = () =&gt; config Object.defineProperty(Vue, &#x27;config&#x27;, configDef) // 暴露一些 util 上的方法 Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; // set、del、nextTick类方法 Vue.set = set Vue.delete = del Vue.nextTick = nextTick // 2.6 暴露 observable 方法 Vue.observable = (obj) =&gt; &#123; observe(obj) return obj &#125; Vue.options = Object.create(null) // 这里初始化 components directives filters 的值为空对象、方便进行后续扩展 ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &#x27;s&#x27;] = Object.create(null) &#125;) Vue.options._base = Vue // 添加内置组件 KeepAlive extend(Vue.options.components, builtInComponents) // 添加 Vue.use 注册插件 initUse(Vue) // 添加 Vue.mixin 混入 initMixin(Vue) // 添加 Vue.extend 继承 initExtend(Vue) // 注册 Vue.component Vue.directive Vue.filter 把注册的组件放入对应的 components directives filters 中 initAssetRegisters(Vue)&#125; 以上就是 Vue 类中的基本内容 new Vue()由上面可知，new Vue() 时构造函数执行的方法实际为 _init 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // vm 指向 实例自己 // a uid vm._uid = uid++ // 唯一id // 开发模式收集性能数据时使用，忽略 let startTag, endTag if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // 避免重复观测 vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // 内部优化使用 initInternalComponent(vm, options) &#125; else &#123; // 走到这里 // 合并全局的 options 到组件 $options 中 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* 忽略 */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // 暴露自己 vm._self = vm // 初始化生命周期相关的变量 _watcher、_inactive、_directInactive、_isMounted、_isDestroyed、_isBeingDestroyed // 设置父子组件引用关系，设置 $root $parent(定位第一个非抽象父节点) $children $refs initLifecycle(vm) // 注册事件 将父组件的监听器注册到子组件身上 initEvents(vm) // 做一些 render 的准备工作 initRender(vm) // 准备工作完成, 触发 beforeCreate 并进入 create 阶段 callHook(vm, &#x27;beforeCreate&#x27;) // 在初始化 data/props 之前 处理依赖注入 provide / inject initInjections(vm) // data, props, computed 在这里初始化, Vue是如何实现数据响应化 initState(vm) // 处理当前组件的 provide 选项 initProvide(vm) // 完成create阶段, 触发 created 钩子 callHook(vm, &#x27;created&#x27;) /* 忽略 */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; // 如果存在el自动挂载 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125;","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（三） 合并配置","slug":"Vue/03/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/03/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/03/README/","excerpt":"","text":"看Vue如何合并配置合并选项的代码 123456// 合并全局的 options 到组件 $options 中vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) 这里有两个方法 resolveConstructorOptions和mergeOptions 先看第一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options if (Ctor.super) &#123; // 这里递归的去取出所有父类的options, 并合并到当前 const superOptions = resolveConstructorOptions(Ctor.super) const cachedSuperOptions = Ctor.superOptions // 如果存在缓存,则直接返回 if (superOptions !== cachedSuperOptions) &#123; // 如果父类的选项发生变化,需要重新合并父类options Ctor.superOptions = superOptions // 检查是否有任何后期修改/附加的选项 (#4976) const modifiedOptions = resolveModifiedOptions(Ctor) // 更新配置 if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; // 将父类上的options都合并到当前options options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; // 如果指定了&#x27;name&#x27;在组件容器中注册下自己 options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125;// 检查是否需要修改function resolveModifiedOptions (Ctor: Class&lt;Component&gt;): ?Object &#123; let modified const latest = Ctor.options const sealed = Ctor.sealedOptions for (const key in latest) &#123; if (latest[key] !== sealed[key]) &#123; if (!modified) modified = &#123;&#125; modified[key] = latest[key] &#125; &#125; return modified&#125;// 一般两种方式创建 Vue 组件new Vue(options)// 通过继承Vue和注入options创建一个新的类，此时就需要执行此方法const NewVue = Vue.extend(options)new NewVue() 第二个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** 确保所有 props 选项语法都标准化为 基于对象的格式。 */function normalizeProps (options: Object, vm: ?Component) &#123; const props = options.props if (!props) return // 初始化对象 const res = &#123;&#125; let i, val, name if (Array.isArray(props)) &#123; // [&#x27;name&#x27;] =&gt; &#123; name: &#123; type: null &#125; &#125; // 使用数组语法时，props 必须是字符串 i = props.length while (i--) &#123; val = props[i] if (typeof val === &#x27;string&#x27;) &#123; name = camelize(val) // font-size =&gt; fontSize res[name] = &#123; type: null &#125; // 字符串默认 type = null &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;props must be strings when using array syntax.&#x27;) &#125; &#125; &#125; else if (isPlainObject(props)) &#123; // &#123; name: &#123; type: string &#125; &#125; -&gt; val = 纯对象不做处理 // &#123; name: [&#x27;string&#x27;] || string &#125; -&gt; &#123; name: &#123; type: [&quot;string&quot;] || string &#125; &#125; for (const key in props) &#123; val = props[key] name = camelize(key) res[name] = isPlainObject(val) ? val : &#123; type: val &#125; &#125; &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn( `Invalid value for option &quot;props&quot;: expected an Array or an Object, ` + `but got $&#123;toRawType(props)&#125;.`, vm ) &#125; options.props = res&#125;/** * 确保inject为对象格式 &#123; key: &#123; from: &#x27;&#x27; &#125; &#125; */function normalizeInject (options: Object, vm: ?Component) &#123; const inject = options.inject if (!inject) return const normalized = options.inject = &#123;&#125; if (Array.isArray(inject)) &#123; for (let i = 0; i &lt; inject.length; i++) &#123; normalized[inject[i]] = &#123; from: inject[i] &#125; &#125; &#125; else if (isPlainObject(inject)) &#123; for (const key in inject) &#123; const val = inject[key] normalized[key] = isPlainObject(val) ? extend(&#123; from: key &#125;, val) : &#123; from: val &#125; &#125; &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn( `Invalid value for option &quot;inject&quot;: expected an Array or an Object, ` + `but got $&#123;toRawType(inject)&#125;.`, vm ) &#125;&#125;/** * 如果指令是一个函数，处理为对象模式 &#123; bind: function, update: function &#125; */function normalizeDirectives (options: Object) &#123; const dirs = options.directives if (dirs) &#123; for (const key in dirs) &#123; const def = dirs[key] if (typeof def === &#x27;function&#x27;) &#123; dirs[key] = &#123; bind: def, update: def &#125; &#125; &#125; &#125;&#125;/** 将两个options合并为一个新的options 用于实例化和继承的核心 */export function mergeOptions ( parent: Object, child: Object, vm?: Component): Object &#123; // 忽略 if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkComponents(child) &#125; // 如果child函数的话，取函数.options if (typeof child === &#x27;function&#x27;) &#123; child = child.options &#125; // 合并props 统一格式为 &#123; key: &#123; type: type || type[] &#125; &#125; normalizeProps(child, vm) // 处理Inject &#123; key: &#123; from: &#x27;&#x27; &#125; &#125; normalizeInject(child, vm) // 处理指令 如果指令是一个函数，处理为对象模式 &#123; bind: function, update: function &#125;. normalizeDirectives(child) // 合并 extends 和 mixins if (!child._base) &#123; if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm) &#125; if (child.mixins) &#123; for (let i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm) &#125; &#125; &#125; const options = &#123;&#125; let key // 这里开始进行合并，根据strats上的规则来进行合并，如果没有特殊要求，则默认子类覆盖父类 for (key in parent) &#123; mergeField(key) &#125; for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125; &#125; function mergeField (key) &#123; const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key) &#125; return options&#125; 总结起来就是 如果存在父类，将父类上的options先合并到当前的options中 接下去归一化处理props inject directive 合并extends mixins 根据strats[name]上的函数进行合并操作，默认子类覆盖父类","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（四） Observer","slug":"Vue/04/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/04/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/04/README/","excerpt":"","text":"Observer数据响应分为Observer和Watcher 两个核心部分组成 根据之前的分析可知，Vue 是在_init 方法中的initState(vm) 完成对数据观测 12// data, props, computed 在这里初始化, Vue是如何实现数据响应化initState(vm) 接着找到这个方法 12345678910111213141516// src/core/instance/state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) // 处理 props 代理到_props上，并进行响应式观测 if (opts.methods) initMethods(vm, opts.methods) // 把methods上的方法绑定到vm上 if (opts.data) &#123; initData(vm) // 处理data =&gt; vm[key] proxy =&gt; vm._data &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) // 处理计算属性 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 先忽略上面，先看 initData(vm) 12345678910111213141516171819202122232425262728293031323334353637383940function initData (vm: Component) &#123; let data = vm.$options.data // 1. 通过 getData 方法 执行 data() data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; // 如果返回值不是一个对象则提醒需要返回对象，并自己创建一个对象接着下一步 data = &#123;&#125; &#125; const keys = Object.keys(data) let i = keys.length while (i--) &#123; const key = keys[i] // 4. 如果data在 props, methods中存在相同键值发起警告，省略 if (!isReserved(key)) &#123; // 代理 // 5. this.meg =&gt; this._data.msg proxy(vm, `_data`, key) &#125; &#125; // 6. 观测数据 observe(data, true /* asRootData */)&#125;export function getData (data: Function, vm: Component): any &#123; // 2. 调用数据获取器时通过push一个null值 禁用 Dep 收集 pushTarget() try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `data()`) return &#123;&#125; &#125; finally &#123; // 3. 完成数据获取后 pop 出 null popTarget() &#125;&#125; 除开最后一行，实际上是做了一些数据初始化、清空Dep对象和_data数据代理的的工作，接着往下看 observe(data, true /* asRootData */) 1234567891011/** *尝试为一个值创建一个观察者实例， *如果成功观察，则返回新的观察者， *或现有的观察者，如果该值已经有一个 */export function observe (value: any, asRootData: ?boolean): Observer | void &#123; // 省略类型判断、监听判断后，这个方法实际上是new了一个Observer实例 ob = new Observer(value) return ob&#125; 接着找到 Observer 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** *附加到每个观察到的观察者类 *目的。连接后，观察者转换目标 *对象的属性键到 getter/setter 中 *收集依赖并调度更新。*/export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; // 初始化 this.value this.value = value // new 一个 Dep 对象用来记录依赖 this.dep = new Dep() // this.vmCount = 0 // 往 value.__ob__ 上指向当前的对象，避免重复监听 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; // 如果是数组，走数组观测方法，劫持数组改变方法 if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; // 如果数组，每一项都进行递归 observe this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * 遍历所有属性并将它们转换为获取器/设置器。 * 此方法仅应在以下情况下调用：值类型是对象。 */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; // 对每一个 key 进行 defineReactive defineReactive(obj, keys[i]) &#125; &#125; /** * 观测数组每一项，递归调用 */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 由上面可知，如果对象类型，直接对所有的key执行defineReactive方法，数组则通过劫持数组原型上的方法进行观测 1234567891011121314151617181920212223242526272829303132333435363738394041424344// /src/core/observer/array.jsimport &#123; def &#125; from &#x27;../util/index&#x27;// 复制一份原型对象const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)// 被监听方法数组const methodsToPatch = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;]/** * 拦截变异方法并发出事件 */methodsToPatch.forEach(function (method) &#123; // 缓存原方法 const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; // 原型上重新定义方法 const result = original.apply(this, args) // 取到实例 const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; // 如果新增项，接着监听 if (inserted) ob.observeArray(inserted) // 通知！ ob.dep.notify() return result &#125;)&#125;) 接着来看最重要的defineReactive 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 在对象上整一个响应式的key */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 创建一个 dep 实例进行依赖收集 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // 如果这个值是个对象则会返回 ob 如果是普通类型的则会返回 undefined // 这里处理后才能对孩子进行监听 let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; // 这里通过原来的getter(如果存在取值函数的话)取到值 // 否则取val const value = getter ? getter.call(obj) : val // 这里非常重要！！！ // 这里的 Dep.target 其实是 Watcher 的实例 if (Dep.target) &#123; dep.depend() /* 这里其实等于 watcher.deps.push(dep) depend() ==&gt; if (Dep.target) &#123; Dep.target.addDep(this) &#125; */ if (childOb) &#123; // 这里其实等于 watcher.deps.push(childOb.dep) childOb.dep.depend() if (Array.isArray(value)) &#123; // 如果当前值为数组，则需要遍历递归增加依赖 dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val // 过滤一些特例 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; // 忽略 // 对于没有setter的访问器属性直接返回 if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; // 如果对象，接着递归处理 childOb = !shallow &amp;&amp; observe(newVal) // 通知变化 dep.notify() &#125; &#125;)&#125; Observer 通过 getter/setter监听数据的读写。在getter中收集依赖，在setter中通知依赖更新","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（五） Watcher","slug":"Vue/05/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/05/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/05/README/","excerpt":"","text":"Watcher那么现在万事俱备，会在哪里触发getter中的依赖收集 ? $mount 的时候 12345678// 如果有 el 且浏览器环境，进行挂载操作Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; $mount 实际上是执行mountComponent函数 12345678910111213141516171819202122232425262728293031323334353637383940414243// src/core/instance/lifecycle.jsexport function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; // 如果没有渲染函数 提供一个空的vnode节点渲染函数，开发模式下发出警告 vm.$options.render = createEmptyVNode &#125; // 触发beforeMount钩子 callHook(vm, &#x27;beforeMount&#x27;) /* 忽略开发模式性能相关的埋点 */ let updateComponent = () =&gt; &#123; // vm._render() 返回一个 vnode vm._update(vm._render(), hydrating) &#125; // 我们在观察者的构造函数中将它设置为 vm._watcher // 因为观察者的初始补丁可能会调用 $forceUpdate （例如在子 // 组件的挂载钩子），它依赖于已定义的 vm._watcher // 在这里创建一个watcher对象进行观察 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125; // 这里lazy = false 所以在Watcher中会调用this.get()求值 // get 方法会执行 pushTarget(this) 则将 watcher 绑定到了 Dep.target 上 &#125;, true /* isRenderWatcher */) hydrating = false // 手动挂载实例，调用自身挂载 触发钩子 if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;) &#125; return vm&#125; 现在通过computed深入看下 Watcher，我们知道计算属性一般是依赖于我们data 中的值做的惰性更新，在之前的代码中，我们知道是通过initComputed去初始化计算属性的，接着往下看 1234567891011121314151617181920212223242526272829303132333435363738394041424344// src/core/instance/state.jsfunction initComputed (vm: Component, computed: Object) &#123; const watchers = vm._computedWatchers = Object.create(null) for (const key in computed) &#123; const userDef = computed[key] // 求值函数 const getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get // 为每一个内部属性都创建一个观察者实例 &#123; lazy: true &#125; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) // 这里把每个计算属性绑定到vm上 if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; &#125;&#125;export function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; // 处理设值函数 const shouldCache = !isServerRendering() if (typeof userDef === &#x27;function&#x27;) &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop &#125; // 最后把属性绑定到vm上 Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 接下来就要去看Watcher到底干了些什么啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* /src/core/observer/watcher.js */import &#123; warn, remove, isObject, parsePath, _Set as Set, handleError, invokeWithErrorHandling, noop&#125; from &#x27;../util/index&#x27;import &#123; traverse &#125; from &#x27;./traverse&#x27;import &#123; queueWatcher &#125; from &#x27;./scheduler&#x27;import Dep, &#123; pushTarget, popTarget &#125; from &#x27;./dep&#x27;import type &#123; SimpleSet &#125; from &#x27;../util/index&#x27;let uid = 0/** *一个观察者解析一个表达式，收集依赖， *并在表达式值更改时触发回调。 *这用于 $watch() api 和指令 */export default class Watcher &#123; vm: Component; expression: string; cb: Function; id: number; // deep 是否深度观察 deep: boolean; user: boolean; // lazy 设置为true的话。第一个get的时候才计算值，初始化时不计算 lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, // 表达式或方法 cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; // 绑定传入的组件实例 this.vm = vm if (isRenderWatcher) &#123; vm._watcher = this &#125; // 把组件实例的watchers中添加当前实例 vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync this.before = options.before &#125; else &#123; // 不传配置 默认为 false this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() // 避免依赖更新时 求值产生重复依赖 this.newDepIds = new Set() // 避免求值过程中的重复依赖 this.expression = process.env.NODE_ENV !== &#x27;production&#x27; ? expOrFn.toString() : &#x27;&#x27; // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` + &#x27;Watcher only accepts simple dot-delimited paths. &#x27; + &#x27;For full control, use a function instead.&#x27;, vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; /** * 求值函数，收集依赖 */ get () &#123; // Dep.target = 当前实例 pushTarget(this) let value const vm = this.vm try &#123; // 求值函数中 触发 this.name 时 // 触发依赖收集，此时Dep.target = 当前实例 // name 属性上的 dep.depend() 当前 实例会调用 addDep(dep) // value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; // 清空 popTarget() this.cleanupDeps() &#125; // 返回值 return value &#125; /** * 添加依赖 */ addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) // 两次去重避免 this.name + this.name 这种情况 if (!this.depIds.has(id)) &#123; // 订阅变化 dep.addSub(this) &#125; &#125; &#125; /** * 清理依赖收集 */ cleanupDeps () &#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125; /** 触发更新 */ update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125; &#125; ...&#125; 配合着图再走一遍流程","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（六） 模板编译","slug":"Vue/06/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/06/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/06/README/","excerpt":"","text":"模板编译模板编译入口在$mount中 1234567891011121314151617181920212223242526272829303132333435363738394041// src/platform/web/entry-runtime-with-compilerconst mount = Vue.prototype.$mountVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) const options = this.$options if (!options.render) &#123; // 解析模板 let template = options.template // 将模板处理成字符串 if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; // 生成render函数 const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns &#125; &#125; return mount.call(this, el, hydrating)&#125; 代码中可以看出编译模板之后才执行原来的$mount方法 接着看 compileToFunctions 函数 1234567// /src/platforms/web/compiler/index.jsimport &#123; baseOptions &#125; from &#x27;./options&#x27;import &#123; createCompiler &#125; from &#x27;compiler/index&#x27;const &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)export &#123; compile, compileToFunctions &#125; 顺着 createCompiler 接着找 123456789101112131415161718192021222324// src/compilerimport &#123; parse &#125; from &#x27;./parser/index&#x27;import &#123; optimize &#125; from &#x27;./optimizer&#x27;import &#123; generate &#125; from &#x27;./codegen/index&#x27;import &#123; createCompilerCreator &#125; from &#x27;./create-compiler&#x27;//`createCompilerCreator` 允许创建使用替代的编译器// parser/optimizer/codegen，例如 SSR 优化编译器。// 这里我们只是使用默认部分导出一个默认编译器。export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions): CompiledResult &#123; const ast = parse(template.trim(), options) if (options.optimize !== false) &#123; optimize(ast, options) &#125; const code = generate(ast, options) return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns &#125;&#125;) createCompilerCreator 123456789101112131415161718192021222324252627282930// src/platforms/web/entry-runtime-with-compiler.jsimport &#123; extend &#125; from &#x27;shared/util&#x27;import &#123; detectErrors &#125; from &#x27;./error-detector&#x27;import &#123; createCompileToFunctionFn &#125; from &#x27;./to-function&#x27;export function createCompilerCreator (baseCompile: Function): Function &#123; return function createCompiler (baseOptions: CompilerOptions) &#123; function compile ( template: string, options?: CompilerOptions ): CompiledResult &#123; ... // 通过baseCompile进行模板编译 由之前的代码可以看出返回结果为 /* &#123; ast, // 抽象语法树 render: code.render, // render字符串 staticRenderFns: code.staticRenderFns // 编译辅助函数 &#125; */ const compiled = baseCompile(template.trim(), finalOptions) return compiled &#125; return &#123; compile, compileToFunctions: createCompileToFunctionFn(compile) &#125; &#125;&#125; 千辛万苦终于拿到render函数，这里之所以那么绕时因为在不同平台下都会有编译过程，编译过程中的 baseOptions 会有所不同，而编译过程会多次执行，但是在同一平台下的编译配置优势相同的，为了不让这些配置在每次编译过程中通过参数传入，这里使用了柯里化计数实现了baseOptions的保留，通过createCompilerCreator(baseCompile) 的方法把真正的编译过程和其他逻辑剥离开。 编译的入口其实为 123456789101112131415161718export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions): CompiledResult &#123; // 解析模板字符串生成 AST const ast = parse(template.trim(), options) // 优化语法树 if (options.optimize !== false) &#123; optimize(ast, options) &#125; // 生成目标代码 const code = generate(ast, options) return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns &#125;&#125;) parse 生成AST123456789101112131415161718192021222324252627282930313233343536/** * 把HTML转化成AST抽象语法树. */export function parse ( template: string, options: CompilerOptions): ASTElement | void &#123; /* 这一段为获取平台配置跟定义方法 */ ... // 这里开始解析HTML模板 const stack = [] // 这个栈暂存对parseHTML返回的结果 let root // 语法树的根节点 // 通过 parseHTML 循环解析 template 用正则做各种匹配，直到整个 template 被解析完毕 parseHTML(template, &#123; // 上面是一些配置 // 匹配到开始标签时触发 start (tag, attrs, unary, start, end) &#123; // ...往栈中放节点，生成结构 &#125;, // 匹配到结束标签时触发 end (tag, start, end) &#123; // 闭合标签出栈 &#125;, chars (text: string, start: number, end: number) &#123; // 处理文本内容 &#125;, // 匹配到注释节点触发 comment (text: string, start, end) &#123; // 处理注释节点 &#125; &#125;) return root&#125; optimize模板生成为AST树后，会对树进行优化。主要是对于一些首次渲染后不会再变化的数据可以在patch中跳过比对 1234567891011121314151617181920212223242526272829// src/compiler/optimizer.js/** * 优化器的目标：遍历生成的模板 AST 树 * 并检测纯静态的子树，即 * 永远不需要改变的 DOM。 *一旦我们检测到这些子树，我们可以： *1. 将它们提升为常量，这样我们就不再需要在每次重新渲染时为它们创建新节点； *2.在补丁过程中完全跳过它们 */export function optimize (root: ?ASTElement, options: CompilerOptions) &#123; if (!root) return isStaticKey = genStaticKeysCached(options.staticKeys || &#x27;&#x27;) isPlatformReservedTag = options.isReservedTag || no // 标记所有静态节点 递归调用 // 静态节点： /* 1. 非表达式 2. 纯文本节点 3. 没有v-if 、v-for 4. 非内置组件 5. 是平台保留标签 */ markStatic(root) // 标记静态根 /* 1. 已经是静态节点，且有子节点 */ markStaticRoots(root, false)&#125; 整个 AST 树中的每一个元素节点标记了 static 和 staticRoot generatecodegen 是一个有限自动机DFA，他会从一个状态开始，根据条件向下一个状态转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export function generate ( ast: ASTElement | void, options: CompilerOptions): CodegenResult &#123; const state = new CodegenState(options) // fix #11483, Root level &lt;script&gt; tags should not be rendered. const code = ast ? (ast.tag === &#x27;script&#x27; ? &#x27;null&#x27; : genElement(ast, state)) : &#x27;_c(&quot;div&quot;)&#x27; return &#123; render: `with(this)&#123;return $&#123;code&#125;&#125;`, staticRenderFns: state.staticRenderFns &#125;&#125;export function genElement (el: ASTElement, state: CodegenState): string &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element let code if (el.component) &#123; code = genComponent(el.component, el, state) &#125; else &#123; let data if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData(el, state) &#125; const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c(&#x27;$&#123;el.tag&#125;&#x27;$&#123; data ? `,$&#123;data&#125;` : &#x27;&#x27; // data &#125;$&#123; children ? `,$&#123;children&#125;` : &#x27;&#x27; // children &#125;)` &#125; // module transforms for (let i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code) &#125; return code &#125;&#125;","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"Vue 源码阅读（七） 手写响应式原理","slug":"Vue/07/README","date":"2022-03-02T16:00:00.000Z","updated":"2022-03-02T16:00:00.000Z","comments":true,"path":"2022/03/02/Vue/07/README/","link":"","permalink":"https://luoyuda.github.io/2022/03/02/Vue/07/README/","excerpt":"","text":"手写响应式原理根据之前整理的流程 使用123456789...&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;value&quot;&gt;&lt;br&gt;&lt;button id=&quot;push&quot;&gt;push&lt;/button&gt;&lt;button id=&quot;pop&quot;&gt;pop&lt;/button&gt;&lt;script type=&quot;module&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;... 123456789101112131415161718192021222324252627282930313233343536373839404142434445import MyVue from &#x27;./source/MyVue&#x27;const vm = window.vm = new MyVue(&#123; el: &#x27;#app&#x27;, template: ` &lt;p&gt;name: &#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;name: &#123;&#123;computedName&#125;&#125;&lt;/p&gt; &lt;p&gt;name: &#123;&#123;watchName&#125;&#125;&lt;/p&gt; &lt;p&gt;inner.name: &#123;&#123;inner.name&#125;&#125;&lt;/p&gt; &lt;p&gt;dataList[0].name: &#123;&#123;dataList[0].name&#125;&#125;&lt;/p&gt; &lt;p&gt;list: &#123;&#123;list.join(&#x27;,&#x27;)&#125;&#125;&lt;/p&gt; `, data()&#123; return &#123; name: &#x27;xy&#x27;, inner: &#123; name: &#x27;inner-xy&#x27; &#125;, list: [0, 1], dataList: [&#123; name: &#x27;deep-xy&#x27;&#125;], watchName: &#x27;2&#x27;, &#125; &#125;, computed: &#123; computedName()&#123; return `computed $&#123;this.name&#125; $&#123;this.name&#125;` &#125; &#125;, watch:&#123; name(val)&#123; this.watchName = `watch $&#123;val&#125;` console.log(this); &#125; &#125;&#125;);document.getElementById(&#x27;value&#x27;).addEventListener(&#x27;input&#x27;, (e) =&gt; &#123; const value = e.target.value vm.name = vm.inner.name = vm.dataList[0].name = value&#125;)document.getElementById(&#x27;push&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; vm.list.push(vm.list.length)&#125;)document.getElementById(&#x27;pop&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; vm.list.pop()&#125;) Vue 类入口书写方法并且暴露出去，这里预计实现state、computed、watch 功能 12345678910111213141516export default function MyVue(options)&#123; // vm 指向自己 const vm = this.vm = this // 使用$options存下入参 vm.$options = options // 初始化 data initState(vm) // 初始化计算属性 initComputed(vm) // 初始化观察属性 initWatch(vm) // 挂载 if(vm.$options.el)&#123; vm.$mount() &#125;&#125; 接下来实现 initState 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 初始化数据function initState(vm)&#123; // 这里取出 fn const fn = vm.$options.data const data = vm._data = getData(fn, vm) // 代理 for (const key of Object.keys(data)) &#123; proxy(vm, &#x27;_data&#x27;, key) &#125; // 观测数据 observe(data) return vm // 获取 data function getData(data, vm)&#123; if(typeof data !== &#x27;function&#x27;) return &#123;&#125; // 这里是清空 Dep.target 令其为 null pushTarget() try &#123; return data.call(vm, vm) &#125; catch (error) &#123; console.log(error) &#125; finally &#123; // 弹出 null 值 popTarget() &#125; &#125; // 代理 // vm._data.name =&gt; vm.name // vm.name = vm._data.name = val function proxy(target, sourceKey, key)&#123; Object.defineProperty(target, key, &#123; get()&#123; return this[sourceKey][key] &#125;, set(val)&#123; this[sourceKey][key] = val &#125;, enumerable: true, configurable: true &#125;) &#125;&#125; 这段代码最核心的部分是 observe(data) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// source/Observe.jsimport &#123; Dep &#125; from &#x27;./Dep&#x27;;import &#123; arrayMethods, dependArray &#125; from &#x27;./Array&#x27;;// 观测数据export function observe(value)&#123; // 如果非对象类型 或者已经完成观测过的对象忽略 if(!value || typeof value !== &#x27;object&#x27; || value.__ob__) return // new 一个 Observer 实例返回 let ob = new Observer(value); return ob&#125;export class Observer&#123; constructor(value)&#123; // value =&gt; 指向 vm 实例 this.value = value // new 一个 dep 实例 this.dep = new Dep() // 给 vm 实例生成 __ob__属性指向当前ob实例，且不能被遍历 Object.defineProperty(value, &#x27;__ob__&#x27;, &#123; value: this, enumerable: false, writable: true, configurable: true &#125;) // 如果是数组，走数组的观测方法 if(Array.isArray(value))&#123; // 将数组原型对象上的方法劫持后替换数组实例上的__proto__属性 value.__proto__ = arrayMethods // 开始数组的依赖收集 this.observeArray(value) &#125;else&#123; // 开始对对象每一项进行get/set劫持 this.walk(value) &#125; &#125; walk(obj)&#123; for (const [key, val] of Object.entries(obj)) &#123; // 设置为响应式数据 defineReactive(obj, key, val) &#125; &#125; observeArray (items) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125;export function defineReactive(obj, key, val)&#123; // 每一个属性都生成一个 dep 实例 const dep = new Dep() // 递归解决多层监听的问题 let childOb = observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; if(Dep.target)&#123; // 如果存在值，让当前的watcher订阅这个 dep 实例 dep.depend() if(childOb)&#123; // 如果 childOb 是一个 ob 实例需要接着往下监听 childOb.dep.depend(); if(Array.isArray(val))&#123; // 如果当前值为数组，则需要遍历递归增加依赖 dependArray(val); &#125; &#125; &#125; return val &#125;, set(newVal)&#123; if(val === newVal) return val = newVal // 如果变成对象接着监听 childOb = observe(newVal) // 值变动，发出通知 dep.notify() &#125; &#125;)&#125; 这里面需要注意的是对数组的通知变化方式，是通过劫持原原型上方法实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445// source/Array.js// 取出原型方法export const arrayMethods = Object.create(Array.prototype)// 劫持变动方法export const methods = [&#x27;push&#x27;, &#x27;shift&#x27;, &#x27;pop&#x27;, &#x27;unshift&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;, &#x27;splice&#x27;]// 遍历实现劫持methods.forEach(method =&gt; &#123; arrayMethods[method] = function (...args) &#123; // 原方法执行 const res = Array.prototype[method].apply(this, args) // 取出当前的 ob 实例 const ob = this.__ob__ // 通过方法/ 参数判断是否变动 let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) &#125; if(inserted) &#123; // 变动接着监听数组增加的项 ob.observeArray(inserted) &#125; // 通知变化 ob.dep.notify() return res &#125;&#125;)export function dependArray(value)&#123; for (let i = 0; i &lt; value.length; i++) &#123; const e = value[i]; // 如果存在，直接收集依赖 if(e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep)&#123; e.__ob__.dep.depend() &#125; if(Array.isArray(e))&#123; // 如果数组，接着递归 dependArray(e) &#125; &#125;&#125; Dep类实现了收集依赖和派发通知 12345678910111213141516171819202122232425262728293031323334353637383940414243// source/Dep.js// 唯一idlet id = 0export class Dep &#123; constructor()&#123; this.id = id++ // 订阅数组 this.subs = [] &#125; addSub(watcher)&#123; // 添加一个Watcher实例到订阅数组中 this.subs.push(watcher) &#125; removeSub(watcher)&#123; // 从订阅数组中删除某个Watcher实例 this.subs = this.subs.filter(w =&gt; w !== watcher) &#125; depend()&#123; // 依赖收集 if(Dep.target)&#123; // 在当前的Watcher实例中添加当前dep实例 Dep.target.addDep(this) &#125; &#125; notify()&#123; // 通知watcher更新 this.subs.forEach(sub =&gt; sub.update()) &#125;&#125;// 用于标识全局唯一的Watcher实例Dep.target = null// Dep.target栈 初始化父组件 -&gt; 初始化子组件 -&gt; 子组件完成观测，弹出 -&gt; 父组件完成观测const stack = []// push Watcher 实例export function pushTarget(target)&#123; stack.push(target) Dep.target = target&#125;// pop Watcher实例export function popTarget()&#123; stack.pop() Dep.target = stack[stack.length - 1]&#125; 接着来实现Watcher 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import &#123; pushTarget, popTarget &#125; from &#x27;./Dep&#x27;;import &#123; util &#125; from &#x27;./Compiler&#x27;;// 唯一idlet id = 0export class Watcher&#123; constructor(vm, expOrFn, cb, opts = &#123;&#125;) &#123; // watcher.vm 指向 vm 实例 this.vm = vm this.id = ++id // 是否惰性 computed this.lazy = !!opts.lazy this.dirty = this.lazy // 数据变化后触发钩子 watch this.cb = cb || (() =&gt; &#123;&#125;) // 取值函数 this.getter = typeof expOrFn === &#x27;function&#x27; ? expOrFn : () =&gt; &#123; return util.getValue(vm, expOrFn) &#125; this.depIds = new Set() this.newDepIds = new Set() // 避免求值过程中的重复依赖 this.deps = [] this.newDeps = [] // 求值 this.value = this.lazy ? undefined : this.get() &#125; get()&#123; // 触发依赖收集 pushTarget(this) // 将自身作为全局Dep.target的watcher实例 let value const vm = this.vm try &#123; // 执行求值函数进行求值 value = this.getter.call(vm, vm) &#125; catch (error) &#123; console.log(error) &#125; finally &#123; // 清除 deps this.cleanupDeps() // 弹出 popTarget() &#125; return value &#125; run()&#123; // 执行求值 let value = this.get() if(this.value !== value)&#123; // 如果值发生变动，触发 watch this.cb.call(this.vm, value, this.value) this.value = value &#125; &#125; addDep(dep)&#123; let id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) // 两次去重避免 this.name + this.name 这种情况 if (!this.depIds.has(id)) &#123; // 订阅变化 dep.addSub(this) &#125; &#125; &#125; update()&#123; // 更新方法 if(this.lazy)&#123; // computed 只有在 dirty 为真的时候去求值 this.dirty = true &#125;else&#123; // 进入队列等待一起执行 queueWatcher(this) &#125; &#125; evalValue()&#123; // computed 的求值方法 this.value = this.get() this.dirty = false &#125; depend()&#123; // computed 收集依赖触发 let i = this.deps.length while(i--)&#123; this.deps[i].depend() &#125; &#125; /** * 清理依赖收集 */ cleanupDeps () &#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125;&#125;let has = &#123;&#125; // 去重let queue = [] // 执行队列function queueWatcher(watcher)&#123; let id = watcher.id if(!has[id])&#123; has[id] = true // 收集watcher实例 queue.push(watcher) &#125; // 下一个微任务循环统一执行 nextTick(flushQueue)&#125;function flushQueue()&#123; // 这里watch可能存在异步加入的情况 for (let i = 0; i &lt; queue.length; i++) &#123; let watcher = queue[i] let id = watcher.id has[id] = null // 依次触发 watcher.run() &#125; // 重置 queue = [] has = &#123;&#125;&#125;// 回调队列let callbacks = []function flushCallbacks()&#123; callbacks.forEach(cb =&gt; cb()) callbacks = []&#125;function nextTick(flushQueue)&#123; callbacks.push(flushQueue) // Promise.resolve().then 创建一个微任务 return Promise.resolve().then(flushCallbacks)&#125; watcher 实例实在$mounted之前完成的 123456789101112131415161718192021222324252627282930313233343536373839404142// mountMyVue.prototype.$mount = function()&#123; const vm = this vm.$el = query(vm.$options.el) // 创建实例 new Watcher(vm, () =&gt; &#123; console.log(&#x27;渲染&#x27;) vm._update() &#125;) return vm // 获取el进行挂载 function query(el) &#123; if (typeof el === &#x27;string&#x27;)&#123; return document.querySelector(el) &#125; return el &#125;&#125;MyVue.prototype._update = function()&#123; const vm = this const el = vm.$el // 实际上这里会去patch vNode 这里直接简单点替换模板了 el.innerHTML = compiler(vm)&#125;// source/Compiler.js// 这里简单的做模板数据替换const Reg = /\\&#123;\\&#123;((?:.|\\r?\\n)+?)\\&#125;\\&#125;/gexport const util = &#123; getValue(vm, exp)&#123; let val eval(`val = vm.$&#123;exp&#125;`) return val &#125;, compilerText(vm)&#123; return vm.$options.template.replace(Reg, (...args) =&gt; &#123; return util.getValue(vm, args[1]) &#125;) &#125;&#125;export function compiler(vm)&#123; return util.compilerText(vm) 至此，响应式的原理已经写完了，接下去写computed的逻辑 12345678910111213141516171819202122232425262728293031323334// 计算属性相关function initComputed(vm)&#123; // 获取计算属性 const computed = vm.$options.computed || Object.create(null) // 初始化watcher实例的容器 let watcher = vm._watcherComputed = Object.create(null) for (const [key, userDef] of Object.entries(computed)) &#123; // 创建 watcher 实例 watcher[key] = new Watcher(vm, userDef, () =&gt; &#123;&#125;, &#123; lazy: true &#125;) // 在 vm 实例创建对应属性和取值函数，进行依赖收集和数据更新 Object.defineProperty(vm, key, &#123; // 这里用了个闭包保存了引用 get:((vm, key) =&gt; &#123; let watcher = vm._watcherComputed[key] return function()&#123; if(watcher)&#123; if(watcher.dirty)&#123; // 如果有需要更新再进行更新操作 watcher.evalValue() &#125; if(Dep.target)&#123; // 依赖收集 watcher.depend() &#125; // 返回值 return watcher.value &#125; &#125; &#125;)(vm, key) &#125;) &#125;&#125; 最后把watch补完 1234567891011121314151617// 观察方法MyVue.prototype.$watch = function(key, handler)&#123; let vm = this // 直接创建一个 watcher 实例 const watcher = new Watcher(vm, key, handler) // immediate handler.call(vm, watcher.value); return&#125;function initWatch(vm)&#123; const watch = vm.$options.watch || Object.create(null) // 监听每一项 for (const [key, handler] of Object.entries(watch))&#123; vm.$watch(key, handler) &#125;&#125;","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"}]},{"title":"重构：改善既有代码的设计-笔记(三)","slug":"refactor/03","date":"2021-08-11T13:23:00.000Z","updated":"2021-08-11T13:23:00.000Z","comments":true,"path":"2021/08/11/refactor/03/","link":"","permalink":"https://luoyuda.github.io/2021/08/11/refactor/03/","excerpt":"","text":"重构：改善既有代码的设计-购书链接 重新组织数据 拆分变量 一个变量只承担一种责任 1234function distanceTravelled()&#123; let acc = 0 acc = &#x27;&#x27;&#125; 1234function distanceTravelled()&#123; let acc = 0 let str = &#x27;&#x27;&#125; 做法 在待分解变量的声明及其第一次被赋值处，修改其名称 如果可能的话，把新变量声明为不可修改 以该变量的第二次赋值动作为分解，修改此前对该变量的引用，引用新变量 12345678910111213function distanceTravelled(scenario, time)&#123; let result let acc = scenario.primaryForce / scenario.mass let primaryTime = Math.min(time, scenario.delay) result = 0.5 * acc * primaryTime * primaryTime let secondTime = time - scenario.delay if(secondTime &gt; 0)&#123; let primaryVelocity = acc * scenario.delay acc = (scenario.primaryForce + scenario.secondForce) / scenario.mass result += primaryVelocity * secondTime + 0.5 * acc * secondTime * secondTime &#125; return result&#125; 12345678910111213function distanceTravelled(scenario, time)&#123; let result let primaryAcceleration = scenario.primaryForce / scenario.mass let primaryTime = Math.min(time, scenario.delay) result = 0.5 * primaryAcceleration * primaryTime * primaryTime let secondTime = time - scenario.delay if(secondTime &gt; 0)&#123; let primaryVelocity = primaryAcceleration * scenario.delay let secondaryAcceleration = (scenario.primaryForce + scenario.secondForce) / scenario.mass result += primaryVelocity * secondTime + 0.5 * secondaryAcceleration * secondTime * secondTime &#125; return result&#125; 字段改名 将不符合语义的字段名改为更加贴切的名字 1const organization = &#123; name: &#x27;Acme&#x27;, country: &#x27;GB&#x27; &#125; 1234567class Organization &#123; constructor(data)&#123; this._title = data.title || data.name &#125; get title() &#123;return this._title &#125; set title(title) &#123;this._title = title&#125;&#125; 做法 如果记录未封装，则先封装记录 对字段改名，并将引用处同步更新 1const organization = &#123; name: &#x27;Acme&#x27;, country: &#x27;GB&#x27; &#125; 1234567891011class Organization &#123; constructor(data)&#123; this._title = data.title || data.name this._country = data.country &#125; get title() &#123;return this._title &#125; set title(title) &#123;this._title = title&#125; get country() &#123;return this._country&#125; set country(country) &#123;this._country = country&#125;&#125;const organization = new Organization(&#123; name: &#x27;Acme&#x27;, country: &#x27;GB&#x27; &#125;) 以查询取代派生变量 可变对数据是软件中最大对错误源头，对数据对修改常常导致代码各个部分以丑陋的形式互相耦合 1234567891011class ProductionPlan &#123; constructor(adjustments)&#123; this._adjustments = adjustments this._production = this._adjustments.reduce((prev, item) =&gt; prev + item.amount, 0) &#125; get production()&#123;return this._production&#125; applyAdjustment(anAdjustment)&#123; this._adjustments.push(anAdjustment) this._production += anAdjustment.amount &#125;&#125; 123456789class ProductionPlan &#123; constructor(adjustments)&#123; this._adjustments = adjustments &#125; get production()&#123;return this._adjustments.reduce((prev, item) =&gt; prev + item.amount, 0)&#125; applyAdjustment(anAdjustment)&#123; this._adjustments.push(anAdjustment) &#125;&#125; 做法 识别出所有对变量做更新的地方 新建一个函数用于计算该变量的值 1234567891011class ProductionPlan &#123; constructor(adjustments)&#123; this._adjustments = adjustments this._production = this._adjustments.reduce((prev, item) =&gt; prev + item.amount, 0) &#125; get production()&#123;return this._production&#125; applyAdjustment(anAdjustment)&#123; this._adjustments.push(anAdjustment) this._production += anAdjustment.amount &#125;&#125; 123456789class ProductionPlan &#123; constructor(adjustments)&#123; this._adjustments = adjustments &#125; get production()&#123;return this._adjustments.reduce((prev, item) =&gt; prev + item.amount, 0)&#125; applyAdjustment(anAdjustment)&#123; this._adjustments.push(anAdjustment) &#125;&#125; 将引用对象改为值对象（将值对象改成引用对象） 更新一个引用对象的属性值，直接替换整个内部对象 123456class Person &#123; constructor()&#123; this._tele = new TelephoneNumber() &#125;&#125;class Tele&#123;...&#125; 12345class Person &#123; set officeAreaCode(arg)&#123;return this._tele = new Tele() &#125; set officeNumber(arg)&#123;return this._tele = new Tele() &#125;&#125;class Tele&#123;...&#125; 做法 检查重构目标是否为不可变的对象，或者是否修改为不可变对象 修改对象中的设值函数，创建一个新的对象 12345678910111213141516171819class Person &#123; constructor(name)&#123; this._name = name this._telephoneNumber = new TelephoneNumber() &#125; get name()&#123;return this._name &#125; get telephoneNumber()&#123;return this._telephoneNumber.toString() &#125; get officeAreaCode()&#123;return this._telephoneNumber.areaCode &#125; set officeAreaCode(arg)&#123;return this._telephoneNumber.areaCode = arg &#125; get officeNumber()&#123;return this._telephoneNumber.number &#125; set officeNumber(arg)&#123;return this._telephoneNumber.number = arg &#125;&#125;class TelephoneNumber&#123; get number()&#123;return this._number&#125; set number(arg)&#123;return this._number = arg&#125; get areaCode()&#123;return this._areaCode &#125; set areaCode(arg)&#123;return this._areaCode = arg&#125; toString()&#123;return `($&#123;this._areaCode&#125;) $&#123;this._number&#125;`&#125;&#125; 1234567891011121314151617181920class Person &#123; constructor(name)&#123; this._name = name &#125; get name()&#123;return this._name &#125; get telephoneNumber()&#123;return this._telephoneNumber.toString() &#125; get officeAreaCode()&#123;return this._telephoneNumber.areaCode &#125; set officeAreaCode(arg)&#123;return this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber) &#125; get officeNumber()&#123;return this._telephoneNumber.number &#125; set officeNumber(arg)&#123;return this._telephoneNumber = new TelephoneNumber(this.areaCode, arg) &#125;&#125;class TelephoneNumber&#123; constructor(areaCode, number)&#123; this._areaCode = areaCode this._number = number &#125; get number()&#123;return this._number&#125; get areaCode()&#123;return this._areaCode &#125; toString()&#123;return `($&#123;this._areaCode&#125;) $&#123;this._number&#125;`&#125;&#125; 将值对象改成引用对象（将引用对象改为值对象） 过多的副本会难以维护，可以创建一个仓库存储 123456class Order &#123; constructor(data)&#123; this._customer = new Customer(data.customer) &#125;&#125;class Customer &#123;&#125; 1234567891011121314151617let _repository = &#123;&#125;_repository.customer = new Map()function registerCustomer(id)&#123; if(!_repository.customer.has(id))&#123; _repository.customer.set(id, new Customer(id)) &#125; return findCustomer(id)&#125;function findCustomer(id)&#123; return _repository.customer.get(id)&#125;class Order &#123; constructor(data)&#123; this._customer = registerCustomer(data.customer) &#125;&#125;class Customer &#123;&#125; 做法 为相关的对象创建一个仓库 确保构造函数有办法找到关联对象的正确实例 修改宿主对象的构造函数，令其从仓库中获取关联对象 12345678910111213class Order &#123; constructor(data)&#123; this._number = data.number; this._customer = new Customer(data.customer) &#125; get customer()&#123;return this._customer&#125;&#125;class Customer &#123; constructor(id)&#123; this._id = id &#125; get id()&#123;return this._id&#125;&#125; 12345678910111213141516171819202122232425262728let _repositoryDatafunction initialize()&#123; _repositoryData = &#123;&#125; _repositoryData.customer = new Map()&#125;function registerCustomer(id)&#123; if(!_repositoryData.customer.has(id))&#123; _repositoryData.customer.set(id, new Customer(id)) &#125; return findCustomer(id)&#125;function findCustomer(id)&#123; return _repositoryData.customer.get(id)&#125;initialize()class Order &#123; constructor(data)&#123; this._number = data.number; this._customer = registerCustomer(data.customer) &#125; get customer()&#123;return this._customer&#125;&#125;class Customer &#123; constructor(id)&#123; this._id = id &#125; get id()&#123;return this._id&#125;&#125; 简化条件逻辑 分解条件表达式 把复杂的条件表达式分解成多个独立的函数 123456789function price()&#123; ... if(aDate.isSummer || aDate.isSpring)&#123; charge = quantity * aPlan.summerRate &#125;else&#123; charge = quantity * aPlan.rate &#125; ...&#125; 1234567function price(aDate, aPlan)&#123; ... return summerOrSpring() ? summerCharge() : orderCharge() function summerOrSpring()&#123;...&#125; function summerCharge()&#123;...&#125; function orderCharge()&#123;...&#125;&#125; 做法 对条件判断和每个条件分支都使用提炼函数 12345678910function price(aDate, aPlan)&#123; let charge let quantity = 100 if(aDate.isSummer || aDate.isSpring)&#123; charge = quantity * aPlan.summerRate &#125;else&#123; charge = quantity * aPlan.rate &#125; return charge&#125; 12345678910111213function price(aDate, aPlan)&#123; let quantity = 100 return summerOrSpring() ? summerCharge() : orderCharge() function summerOrSpring()&#123; return aDate.isSummer || aDate.isSpring &#125; function summerCharge()&#123; return quantity * aPlan.summerRate &#125; function orderCharge()&#123; return quantity * aPlan.rate &#125;&#125; 合并条件表达式 把相同返回的条件合并成一处 123if(state == 1) return 0if(start == 2) return 0return 1 12if(state == 1 || start == 2) return 0return 1 做法 确定条件表达式没有副作用 使用适当的运算符合并 1234if(state == 1) return 0if(start == 2) return 0if(end == 3) return 0return 1 12if(state == 1 || start == 2 || end == 3) return 0return 1 以卫语句取代嵌套条件表达式 多层的嵌套判断会减低可读性，可以使用卫语句进行提前返回 1234567891011function payAmount(employee)&#123; if(employee.isSeparated)&#123; ... &#125;else&#123; if(employee.isRetired)&#123; ... &#125;else&#123; ... &#125; &#125;&#125; 12345function payAmount(employee)&#123; if(employee.isSeparated) return if(employee.isRetired) return return &#125; 做法 选中外层需要被替换的条件逻辑，替换成卫语句 12345678910111213function payAmount(employee)&#123; let result if(employee.isSeparated)&#123; result = &#123;amount: 0, reasonCode: &#x27;SEP&#x27;&#125; &#125;else&#123; if(employee.isRetired)&#123; result = &#123;amount: 0, reasonCode: &#x27;RET&#x27;&#125; &#125;else&#123; result = &#123;amount: 1000, reasonCode: &#x27;&#x27;&#125; &#125; &#125; return result&#125; 12345function payAmount(employee)&#123; if(employee.isSeparated) return &#123;amount: 0, reasonCode: &#x27;SEP&#x27;&#125; if(employee.isRetired) return &#123;amount: 0, reasonCode: &#x27;RET&#x27;&#125; return &#123;amount: 1000, reasonCode: &#x27;&#x27;&#125;&#125; 以多态取代条件表达式 通过类的多态去改善比较复杂的条件表达式 123456789class Bird &#123; constructor(name, type)&#123; switch (bird.type)&#123; case &#x27;E&#x27;: this.plumage = &#x27;e&#x27; case &#x27;N&#x27;: this.plumage = &#x27;n&#x27; default: this.plumage = &#x27;unknown&#x27; &#125; &#125;&#125; 12345678910111213141516171819202122class Bird &#123; get plumage()&#123; return &#x27;unknown&#x27; &#125;&#125;class E extends Bird&#123; get plumage()&#123; return &#x27;e&#x27; &#125;&#125;class N extends Bird&#123; get plumage()&#123; return &#x27;n&#x27; &#125;&#125;function createBird(...arg)&#123; switch (arg[1])&#123; case &#x27;E&#x27;: return new E(...arg); case &#x27;N&#x27;: return new N(...arg); default: return new Bird(...arg); &#125;&#125; 做法 如果现有的类不具备多态行为，就用工厂模式创建 在调用方代码中使用工程函数获得对象实例 将带有条件逻辑的函数移动到超类中 任选一个子类，在其中创建一个函数，使其复写超类中容纳条件表达式的那个函数 将于该子类相关的条件表达式分支复制到新函数中 处理完后将超类的函数声明为抽象函数 12345678910111213141516171819202122232425262728293031function plumages(birds)&#123; return new Map(birds.map(b =&gt; [b.name, b.plumage]))&#125;function speeds(birds)&#123; return new Map(birds.map(b =&gt; [b.name, airSpeedVelocity(b)]))&#125;function plumage(bird)&#123; switch (bird.type)&#123; case &#x27;E&#x27;: return &#x27;a&#x27; case &#x27;A&#x27;: return bird.counts &gt; 2 ? &#x27;t&#x27; : &#x27;a&#x27; case &#x27;N&#x27;: return bird.voltage &gt; 100 ? &#x27;s&#x27; : &#x27;b&#x27; default: return &#x27;unknown&#x27; &#125;&#125;function airSpeedVelocity(bird)&#123; switch (bird.type)&#123; case &#x27;E&#x27;: return 35 case &#x27;A&#x27;: return 40 - bird.counts case &#x27;N&#x27;: return bird.voltage / 10 + 10 default: return null &#125;&#125;class Bird &#123; constructor(name, type, counts, voltage)&#123; this.name = name this.type = type this.counts = counts this.voltage = voltage this.plumage = plumage(this) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function plumages(birds)&#123; return new Map(birds.map(b =&gt; [b.name, b.plumage]))&#125;function speeds(birds)&#123; return new Map(birds.map(b =&gt; [b.name, b.airSpeedVelocity]))&#125;class Bird &#123; constructor(name, type, counts, voltage)&#123; this.name = name this.type = type this.counts = counts this.voltage = voltage &#125; get plumage()&#123; return &#x27;unknown&#x27; &#125; get airSpeedVelocity()&#123; return null &#125;&#125;class E extends Bird&#123; get plumage()&#123; return &#x27;a&#x27; &#125; get airSpeedVelocity()&#123; return 35 &#125;&#125;class A extends Bird&#123; get plumage()&#123; return this.counts &gt; 2 ? &#x27;t&#x27; : &#x27;a&#x27; &#125; get airSpeedVelocity()&#123; return 40 - this.counts &#125;&#125;class N extends Bird&#123; get plumage()&#123; this.voltage &gt; 100 ? &#x27;s&#x27; : &#x27;b&#x27; &#125; get airSpeedVelocity()&#123; return this.voltage / 10 + 10 &#125;&#125;function createBird(...arg)&#123; switch (arg[1])&#123; case &#x27;E&#x27;: return new E(...arg); case &#x27;A&#x27;: return new A(...arg); case &#x27;N&#x27;: return new N(...arg); default: return new Bird(...arg); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function rating(voyage, history)&#123; const vpf = voyageProfitFactor(voyage, history) const vr = voyageRisk(voyage) const chr = captainHistoryRisk(voyage, history) if(vpf * 3 &gt; (vr + chr * 2)) return &#x27;A&#x27; return &#x27;B&#x27;&#125;function voyageRisk(voyage)&#123; let result = 1 if(voyage.length &gt; 4) result += 2 if(voyage.length &gt; 8) result += voyage.length - 8 if([&#x27;china&#x27;, &#x27;east-indies&#x27;].includes(voyage.zone)) result += 4 return Math.max(result, 0)&#125;function captainHistoryRisk(voyage, history)&#123; let result = 1 if(history.length &lt; 5) result += 4 result += history.filter(v =&gt; v.profit &lt; 0).length if(voyage.zone === &#x27;china&#x27; &amp;&amp; hasChina(history)) result -= 2 return Math.max(result, 0)&#125;function hasChina(history) &#123; return history.some(v =&gt; v.zone === &#x27;china&#x27;)&#125;function voyageProfitFactor(voyage, history)&#123; let result = 2 if(voyage.zone === &#x27;china&#x27;) result += 1 if(voyage.zone === &#x27;east-indies&#x27;) result += 1 if(voyage.zone === &#x27;china&#x27; &amp;&amp; hasChina(history))&#123; result += 3 if(history.length &gt; 10) result += 1 if(voyage.length &gt; 12) result += 1 if(voyage.length &gt; 18) result -= 1 &#125;else&#123; if(history.length &gt; 8) result += 1 if(voyage.length &gt; 14) result -= 1 &#125; return result&#125;const voyage = &#123; zone: &#x27;west-indies&#x27;, length: 10 &#125;const history = [ &#123; zone: &#x27;east-indies&#x27;, profit: 5 &#125;, &#123; zone: &#x27;west-indies&#x27;, profit: 15 &#125;, &#123; zone: &#x27;china&#x27;, profit: -2 &#125;, &#123; zone: &#x27;west-africa&#x27;, profit: 7 &#125;]console.log(rating(voyage, history)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function rating(voyage, history)&#123; return createRating(voyage, history).value&#125;function createRating(voyage, history)&#123; if(voyage.zone === &#x27;china&#x27; &amp;&amp; history.some(v =&gt; v.zone === &#x27;china&#x27;)) return new ExperienceChinaRating(voyage, history) return new Rating(voyage, history)&#125;class Rating &#123; constructor(voyage, history)&#123; this.voyage = voyage this.history = history &#125; get value()&#123; const vpf = this.voyageProfitFactor const vr = this.voyageRisk const chr = this.captainHistoryRisk if(vpf * 3 &gt; (vr + chr * 2)) return &#x27;A&#x27; return &#x27;B&#x27; &#125; get voyageProfitFactor()&#123; let result = 2 if(this.voyage.zone === &#x27;china&#x27;) result += 1 if(this.voyage.zone === &#x27;east-indies&#x27;) result += 1 result += this.historyLengthFactor result += this.voyageLengthFactor return result &#125; get voyageLengthFactor()&#123; return this.voyage.length &gt; 14 ? 1 : 0 &#125; get historyLengthFactor()&#123; return this.history.length &gt; 8 ? 1 : 0 &#125; get voyageRisk()&#123; let result = 1 if(this.voyage.length &gt; 4) result += 2 if(this.voyage.length &gt; 8) result += this.voyage.length - 8 if([&#x27;china&#x27;, &#x27;east-indies&#x27;].includes(this.voyage.zone)) result += 4 return Math.max(result, 0) &#125; get captainHistoryRisk()&#123; let result = 1 if(this.history.length &lt; 5) result += 4 result += this.history.filter(v =&gt; v.profit &lt; 0).length return Math.max(result, 0) &#125;&#125;class ExperienceChinaRating extends Rating&#123; get captainHistoryRisk()&#123; const result = super.captainHistoryRisk - 2 return result &#125; get voyageProfitFactor()&#123; return super.voyageProfitFactor + 3 &#125; get voyageLengthFactor()&#123; let result = 0 if(this.voyage.length &gt; 12) result += 1 if(this.voyage.length &gt; 18) result -= 1 return result &#125; get historyLengthFactor()&#123; return this.history.length &gt; 10 ? 1 : 0 &#125;&#125;const voyage = &#123; zone: &#x27;west-indies&#x27;, length: 10 &#125;const history = [ &#123; zone: &#x27;east-indies&#x27;, profit: 5 &#125;, &#123; zone: &#x27;west-indies&#x27;, profit: 15 &#125;, &#123; zone: &#x27;china&#x27;, profit: -2 &#125;, &#123; zone: &#x27;west-africa&#x27;, profit: 7 &#125;]console.log(rating(voyage, history)) 引入特例 将多个相同的特殊情况取值收拢于一处 123456789function customerName(aCustomer)&#123; if(aCustomer.toString() === &#x27;unknown&#x27;) return &#x27;occupant&#x27; return aCustomer.name&#125;class Customer &#123; toString() &#123; return this.name || &#x27;unknown&#x27; &#125;&#125; 12345678910111213141516function customerName(aCustomer)&#123; return aCustomer.name&#125;class Customer &#123; toString() &#123; return this.name || &#x27;unknown&#x27; &#125;&#125;const customer = enrichCustomer(new Customer())function enrichCustomer(aCustomer)&#123; const unknownCustomer = &#123; name: &#x27;occupant&#x27;, &#125; if(aCustomer.toString() === &#x27;unknown&#x27;) return unknownCustomer return aCustomer&#125; 做法 给重构目标添加检查特例的属性，令其返回false 创建一个特例对象，其中只有检查特例的属性，返回true 对“与特例值做对比”提炼函数，并确保客户端使用这个新函数 将新的特例对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成 修改特例对比函数的主题，在其直接使用检查特例的属性 使用函数组合成类、函数组合成变换，把通用的特例处理逻辑搬移到新建的特例对象中 对特例对比函数使用内联函数，将其内联到仍然需要的地方 1234567891011121314151617function customerName(aCustomer)&#123; if(aCustomer.toString() === &#x27;unknown&#x27;) return &#x27;occupant&#x27; return aCustomer.name&#125;function customerPlan(aCustomer)&#123; if(aCustomer.toString() === &#x27;unknown&#x27;) return &#x27;basic plan&#x27; return aCustomer.plan&#125;class Customer &#123; constructor(name, plan) &#123; this.name = name this.plan = plan &#125; toString() &#123; return this.name || &#x27;unknown&#x27; &#125;&#125; 123456789101112131415161718192021222324function customerName(aCustomer)&#123; return aCustomer.name&#125;function customerPlan(aCustomer)&#123; return aCustomer.plan&#125;class Customer &#123; constructor(name, plan) &#123; this.name = name this.plan = plan &#125; toString() &#123; return this.name || &#x27;unknown&#x27; &#125;&#125;const customer = enrichCustomer(new Customer())function enrichCustomer(aCustomer)&#123; const unknownCustomer = &#123; name: &#x27;occupant&#x27;, plan: &#x27;basic plan&#x27; &#125; if(aCustomer.toString() === &#x27;unknown&#x27;) return unknownCustomer return aCustomer&#125; 引入断言 通过断言告诉阅读者，程序执行到这一点是，对当前状态做了何种假设 做法 如果你发现代码假设的某个条件始终为真，就可以加入一个断言说明情况 重构API 将查询函数和修改函数分离 区分处有副作用和无副作用的函数 12345678910function setOffAlarms()&#123;//setTimeout&#125;function alertForMiscreant(people) &#123; for (const p of people) &#123; if(p === &#x27;oo&#x27;)&#123; setOffAlarms() return p &#125; &#125; return &#x27;&#x27;&#125; 1234function alertForMiscreant(people) &#123; if(findMiscreant(people) !== &#x27;&#x27;) setOffAlarms()&#125;function findMiscreant(people) &#123;// find &#125; 做法 复制整个函数，将其作为一个查询命名 从新建的查询中去掉所有存在副作用的语句 查找调用函数的地方，替换 12345678910111213141516171819const people = [&#x27;xx&#x27;, &#x27;yy&#x27;, &#x27;zz&#x27;, &#x27;oo&#x27;, &#x27;zzz&#x27;, &#x27;cc&#x27;]function setOffAlarms()&#123; setTimeout(() =&gt; &#123; console.log(&#x27;!!!&#x27;) &#125;, 100)&#125;function alertForMiscreant(people) &#123; for (const p of people) &#123; if(p === &#x27;oo&#x27;)&#123; setOffAlarms() return p &#125; if(p === &#x27;cc&#x27;)&#123; setOffAlarms() return p &#125; &#125; return &#x27;&#x27;&#125; 12345678910111213function alertForMiscreant(people) &#123; if(findMiscreant(people) !== &#x27;&#x27;) setOffAlarms()&#125;function findMiscreant(people) &#123; for (const p of people) &#123; if(p === &#x27;oo&#x27; || p === &#x27;cc&#x27;)&#123; return p &#125; &#125; return &#x27;&#x27;&#125;const found = findMiscreant(people)alertForMiscreant(people) 函数参数化 如果两个函数逻辑相似，只是字面量值不同，则可以合成一个函数，以参数的形式传入不同的值消除重复 123456function tenPercentRaise(salary)&#123; return salary * 1.1&#125;function fivePercentRaise(salary)&#123; return salary * 1.05&#125; 123456789function raise(salary, factor=0)&#123; return salary * (factor + 1)&#125;function tenPercentRaise(salary)&#123; return raise(salary, 0.1)&#125;function fivePercentRaise(salary)&#123; return raise(salary, 0.05)&#125; 做法 从一组相似的函数中选择一个 把需要作为参数传入的字面量添加到参数列表中 修改函数所有的调用处，更新参数传入 修改函数体，使其使用新的参数 12345678910111213function baseCharge(usage)&#123; if(usage &lt; 0) return 0 return topBand(usage) * 0.07 + bottomBand(usage) * 0.03 + middleBand(usage) * 0.05&#125;function bottomBand(usage)&#123; return Math.min(usage, 100)&#125;function topBand(usage)&#123; return usage &gt; 200 ? usage - 200 : 0&#125;function middleBand(usage)&#123; return usage &gt; 100 ? Math.min(usage, 200) - 100 : 0&#125; 123456789function baseCharge(usage)&#123; if(usage &lt; 0) return 0 return withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + withinBand(usage, 200, Infinity) * 0.07 &#125;function withinBand(usage, bottom, top)&#123; return usage &gt; bottom ? Math.min(usage, top) - bottom : 0&#125; 移除标记参数 标记参数有时候会让人难以理解那些函数可以调用 1234567function deliveryDate(anOrder, isRush)&#123; if(isRush)&#123; ... &#125;else&#123; ... &#125;&#125; 123456function rushDeliveryDate(anOrder)&#123; ...&#125;function regularDeliveryDate(anOrder)&#123; ...&#125; 做法 针对参数的每一种可能值新建一个函数 对于字面量作为参数的函数调用者，改为调用新建的明确函数 123456789101112131415function deliveryDate(anOrder, isRush)&#123; if(isRush)&#123; let deliveryTime if([&#x27;MA&#x27;, &#x27;CT&#x27;].includes(anOrder.deliveryState)) deliveryTime = 1 else if([&#x27;NY&#x27;, &#x27;NH&#x27;].includes(anOrder.deliveryState)) deliveryTime = 2 else deliveryTime = 3 return deliveryTime &#125;else&#123; let deliveryTime if([&#x27;MA&#x27;, &#x27;CT&#x27;, &#x27;NY&#x27;].includes(anOrder.deliveryState)) deliveryTime = 2 else if([&#x27;ME&#x27;, &#x27;NH&#x27;].includes(anOrder.deliveryState)) deliveryTime = 3 else deliveryTime = 4 return deliveryTime &#125;&#125; 1234567891011121314function rushDeliveryDate(anOrder)&#123; let deliveryTime if([&#x27;MA&#x27;, &#x27;CT&#x27;].includes(anOrder.deliveryState)) deliveryTime = 1 else if([&#x27;NY&#x27;, &#x27;NH&#x27;].includes(anOrder.deliveryState)) deliveryTime = 2 else deliveryTime = 3 return deliveryTime&#125;function regularDeliveryDate(anOrder)&#123; let deliveryTime if([&#x27;MA&#x27;, &#x27;CT&#x27;, &#x27;NY&#x27;].includes(anOrder.deliveryState)) deliveryTime = 2 else if([&#x27;ME&#x27;, &#x27;NH&#x27;].includes(anOrder.deliveryState)) deliveryTime = 3 else deliveryTime = 4 return deliveryTime&#125; 保持对象完整 把一个对象内的字段拆成几个变量，再传入函数中，不如保持完整传入函数中去解析 123const low = dayTempRange.lowconst high = dayTempRange.highfunction withinRange(low, high)&#123;...&#125; 1function withinRange(aNumberRange)&#123;...&#125; 做法 新建一个空函数，给它期望的参数列表 再新函数中调用旧函数，并将新参数映射到旧的参数列表中 逐一修改旧函数的调用者，令其使用新函数 使用内联函数将旧函数内联到新函数中，给新函数改名后，同时修改所有的引用点 123456789const dayTempRange = &#123; low: 10, high: 40 &#125;const low = dayTempRange.lowconst high = dayTempRange.highif(withinRange(low, high))&#123; console.log(&#x27;123&#x27;)&#125;function withinRange(low, high)&#123; return low &gt; 9 &amp;&amp; 41 &gt; high&#125; 123456if(withinRange(dayTempRange))&#123; console.log(&#x27;123&#x27;)&#125;function withinRange(aNumberRange)&#123; return aNumberRange.low &gt; 9 &amp;&amp; 41 &gt; aNumberRange.high&#125; 以查询取代参数 频繁的传递参数会让函数看起来变得复杂 123456class Order &#123; get finalPrice()&#123; return this.discountedPrice(basePrice, discount) &#125; discountedPrice(price, discount)&#123;...&#125;&#125; 12345678class Order &#123; get finalPrice()&#123; return this.discountedPrice() &#125; get basePrice() &#123;...&#125; get discount() &#123;...&#125; discountedPrice()&#123;...&#125;&#125; 做法 使用提炼函数将参数的计算过程提炼到一个独立的函数中 将函数体内引用该参数的地方改为调用新建的函数 12345678910111213141516171819class Order &#123; constructor(quantity, price)&#123; this.quantity = quantity; this.price = price; &#125; get finalPrice()&#123; const basePrice = this.price * this.quantity let discount if(this.quantity &gt; 100) discount = 2 else discount = 1 return this.discountedPrice(basePrice, discount) &#125; discountedPrice(price, discount)&#123; switch(discount)&#123; case 1: return price * 0.9 case 2: return price * 0.8 &#125; &#125;&#125; 1234567891011121314151617class Order &#123; constructor(quantity, price)&#123; this.quantity = quantity; this.price = price; &#125; get finalPrice()&#123; return this.discountedPrice() &#125; get basePrice() &#123; return this.price * this.quantity &#125; get discount() &#123; return this.quantity &gt; 100 ? 2 : 1 &#125; discountedPrice()&#123; switch(this.discount)&#123; case 1: return this.basePrice * 0.9 case 2: return this.basePrice * 0.8 &#125; &#125;&#125; 以参数取代查询 当遇到引用复杂，需要调用者弄清参数意义时，需要用参数取代查询 12345678const thermostat = &#123;&#125;class HeatingPlan &#123; get targetTemperature()&#123; if(thermostat.t &gt; this.max) return this.max else if(thermostat.t &lt; this.min) return this.min return thermostat.t &#125;&#125; 1234567class HeatingPlan &#123; targetTemperature(t)&#123; if(t &gt; this.max) return this.max else if(t &lt; this.min) return this.min return t &#125;&#125; 做法 对执行查询操作对代码提炼变量，将其从函数体中剥离出来 现有的函数体不再执行查询操作 1234567891011121314151617181920const thermostat = &#123; selectTemperature: 20&#125;function setToHeat()&#123; thermostat.selectTemperature += 10&#125;function setToCool()&#123; thermostat.selectTemperature -= 10&#125;class HeatingPlan &#123; constructor(max, min)&#123; this.max = max; this.min = min; &#125; get targetTemperature()&#123; if(thermostat.selectTemperature &gt; this.max) return this.max else if(thermostat.selectTemperature &lt; this.min) return this.min return thermostat.selectTemperature &#125;&#125; 1234567891011121314151617function setToHeat()&#123; thermostat.selectTemperature += 10&#125;function setToCool()&#123; thermostat.selectTemperature -= 10&#125;class HeatingPlan &#123; constructor(max, min)&#123; this.max = max; this.min = min; &#125; targetTemperature(selectTemperature)&#123; if(selectTemperature &gt; this.max) return this.max else if(selectTemperature &lt; this.min) return this.min return selectTemperature &#125;&#125; 移除设值函数 如果不可变的数据，不暴露修改的方法 1234class Person &#123; get name()&#123;return this._name &#125; set name(arg)&#123; return this._name = arg &#125;&#125; 123class Person &#123; get name()&#123;return this._name &#125;&#125; 做法 使用私有字段的实现方式 移除设值函数 1234567class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125; set name(arg)&#123; return this._name = arg &#125;&#125; 123456class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125;&#125; 以工厂函数取代构造函数 构造函数在部分普通场合难以适用时，可以将其改为工厂函数 123456class Employee&#123; constructor(name, typeCode)&#123; this. _name = name this._typeCode = typeCode &#125;&#125; 123function createEngineer(name)&#123; return new Employee(name, &#x27;E&#x27;)&#125; 做法 新建一个工厂函数，让它地道用现有的构造函数 把调用构造函数的方法改为调用工厂函数 尽量修改构造函数的可见范围 1234567891011class Employee&#123; constructor(name, typeCode)&#123; this. _name = name this._typeCode = typeCode &#125; get name()&#123;return this._name &#125; get type()&#123;return Employee.legalTypeCode[this._typeCode] &#125; static get legalTypeCode()&#123; return &#123; &#x27;E&#x27;: &#x27;Engineer&#x27;, &#x27;M&#x27;: &#x27;Manager&#x27;, &#x27;S&#x27;: &#x27;Salesman&#x27; &#125; &#125;&#125; 1234567891011121314class Employee&#123; constructor(name, typeCode)&#123; this. _name = name this._typeCode = typeCode &#125; get name()&#123;return this._name &#125; get type()&#123;return Employee.legalTypeCode[this._typeCode] &#125; static get legalTypeCode()&#123; return &#123; &#x27;E&#x27;: &#x27;Engineer&#x27;, &#x27;M&#x27;: &#x27;Manager&#x27;, &#x27;S&#x27;: &#x27;Salesman&#x27; &#125; &#125;&#125;function createEngineer(name)&#123; return new Employee(name, &#x27;E&#x27;)&#125; 以命令取代函数 当函数里拥有许多复杂操作时，可以改成命令对象模式去处理 123function score() &#123; ...&#125; 1234567891011function score() &#123; return new Score().execute()&#125;class Scorer&#123; execute()&#123; this.scoreSmoking() this.stateWithLowCertification() &#125; scoreSmoking()&#123;&#125; stateWithLowCertification()&#123;&#125;&#125; 做法 创建一个空类，包含其目标函数 给每个参数都创建一个字段 12345678910111213141516function score(candidate, medicalExam, scoringGuide) &#123; let result = 0 let healthLevel = 0 let highMedicalRiskFlag = false if(medicalExam.isSmoker)&#123; healthLevel += 10 highMedicalRiskFlag = true &#125; let certificationGrade = &#x27;regular&#x27; if(scoringGuide.stateWithLowCertification(candidate.originState))&#123; certificateGrade = &#x27;low&#x27; result -= 5 &#125; result -= Math.max(healthLevel - 5, 0) return result&#125; 1234567891011121314151617181920212223242526272829303132function score(candidate, medicalExam, scoringGuide) &#123; return new Score(candidate, medicalExam, scoringGuide).execute()&#125;class Scorer&#123; constructor(candidate, medicalExam, scoringGuide)&#123; this._candidate = candidate this._medicalExam = medicalExam this._scoringGuide = scoringGuide &#125; execute()&#123; this._result = 0 this._healthLevel = 0 this._highMedicalRiskFlag = false this.scoreSmoking() this.stateWithLowCertification() this._result -= Math.max(this._healthLevel - 5, 0) return this._result &#125; scoreSmoking()&#123; if(this._medicalExam.isSmoker)&#123; this._healthLevel += 10 this._highMedicalRiskFlag = true &#125; &#125; stateWithLowCertification()&#123; this._certificationGrade = &#x27;regular&#x27; if(this._scoringGuide.stateWithLowCertification(this._candidate.originState))&#123; this._certificationGrade = &#x27;low&#x27; this._result -= 5 &#125; &#125;&#125; 以函数取代命令 使用函数去完成比较简单的任务 1234567class ChargeCalculator&#123; get basePrice()&#123;&#125; get charge()&#123;&#125;&#125;function charge()&#123; return new ChargeCalculator().charge&#125; 123function charge()&#123; ...&#125; 做法 对命令对象在执行阶段用到的函数使用内联函数 将构造函数中的参数转移到执行函数 对所有的字段在执行函数中找到引用的地方，并改为参数 12345678910111213141516class ChargeCalculator&#123; constructor(customer, usage, provider)&#123; this.customer = customer this.usage = usage this.provider = provider &#125; get basePrice()&#123; return this.customer.baseRate * this.usage &#125; get charge()&#123; return this.basePrice + this.provider.connectionCharge &#125;&#125;function charge(customer, usage, provider)&#123; return new ChargeCalculator(customer, usage, provider).charge&#125; 1234function charge(customer, usage, provider)&#123; const basePrice = customer.baseRate * usage return basePrice + provider.connectionCharge&#125; 处理继承关系 函数上移 如果某个函数在各个子类的函数体中相同，则将函数上移 12345678class Party &#123;&#125;class Employee extends Party &#123; annualCost()&#123; ... &#125;&#125;class Department extends Party &#123; annualCost()&#123; ... &#125;&#125; 1234567class Party &#123; annualCost()&#123; ... &#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 做法 检查待提升函数，确定完全一致 检查函数体内引用的所有函数调用和字段都能从超类调用 如果待提升签名不同，则都需要修改成超类的字段名 在超类中新建一个函数，将某个待提升函数的代码复制到超类中 移除待提升的函数 1234567891011class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125;&#125;class Employee extends Party &#123; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Department extends Party &#123; get totalAnnualCost()&#123; return this.monthlyCost * 12 &#125;&#125; 12345678910class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 字段上移 如果字段在各个子类中，字段可提升到超类 12345678class Party &#123;&#125;class Employee extends Party &#123; get annualCost()&#123; ... &#125;&#125;class Department extends Party &#123; get annualCost()&#123; ... &#125;&#125; 1234567class Party &#123; get annualCost()&#123; ... &#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 做法 针对待提升的字段，检查他们的所有使用点，确定以同样的方式使用 如果字段名称不同，则先用变量改名 在超类中新增字段 1234567891011class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125;&#125;class Employee extends Party &#123; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Department extends Party &#123; get totalAnnualCost()&#123; return this.monthlyCost * 12 &#125;&#125; 12345678910class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 构造函数本体上移 子类中存在共同实例属性，则可以提升到超类 1234567891011121314class Party &#123;&#125;class Employee extends Party &#123; constructor()&#123; super() this.name = name &#125;&#125;class Department extends Party &#123; constructor()&#123; super() this.name = name &#125;&#125; 123456789class Party &#123; constructor(name)&#123; this.name = name &#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 做法 如果超类不存在构造函数，直接定义一个。确保子类调用超类到构造函数 使用移动语句将子类中构造函数中的公共语句，移动到超类到构造函数调用的语句 逐一移除子类间的公共代码，将其提升到超类的构造函数中 1234567891011121314151617class Party &#123;&#125;class Employee extends Party &#123; constructor(name, id, monthlyCost)&#123; super() this.name = name this.id = id this.monthlyCost = monthlyCost &#125;&#125;class Department extends Party &#123; constructor(name, staff)&#123; super() this.name = name this.staff = staff &#125;&#125; 123456789101112131415161718class Party &#123; constructor(name)&#123; this.name = name &#125;&#125;class Employee extends Party &#123; constructor(name, id, monthlyCost)&#123; super(name) this.id = id this.monthlyCost = monthlyCost &#125;&#125;class Department extends Party &#123; constructor(name, staff)&#123; super(name) this.staff = staff &#125;&#125; 函数下移 如果某个函数只一个或者几个子类调用，则将函数下移到子类中 12345class Party &#123; annualCost()&#123;...&#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 12345class Party &#123;&#125;class Employee extends Party &#123; annualCost()&#123;...&#125;&#125;class Department extends Party &#123;&#125; 做法 将超类的函数移动到目标子类中 12345678910111213class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125; annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party &#123; get cost()&#123; return this.annualCost() * 10 &#125;&#125;class Department extends Party &#123;&#125; 12345678910111213class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125;&#125;class Employee extends Party &#123; annualCost()&#123; return this.monthlyCost * 12 &#125; get cost()&#123; return this.annualCost() * 10 &#125;&#125;class Department extends Party &#123;&#125; 字段下移 如果某个字段只被一个子类用到，就将其搬移到需要该字段到子类中 12345class Party &#123; get annualCost()&#123;...&#125;&#125;class Employee extends Party &#123;&#125;class Department extends Party &#123;&#125; 12345class Party &#123;&#125;class Employee extends Party &#123; get annualCost()&#123;...&#125;&#125;class Department extends Party &#123;&#125; 做法 将超类中到字段移动到目标子类 12345678910111213class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party &#123; get cost()&#123; return this.annualCost() * 10 &#125;&#125;class Department extends Party &#123;&#125; 12345678910111213class Party &#123; constructor(monthlyCost)&#123; this.monthlyCost = monthlyCost &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party &#123; get cost()&#123; return this.annualCost * 10 &#125;&#125;class Department extends Party &#123;&#125; 以子类取代类型码 用多种子类替代类型码判断 123class Employee &#123; validateType(type)&#123;...&#125;&#125; 12345678910111213class Employee &#123;&#125;class Engineer extends Employee&#123; get type()&#123;&#125;&#125;class Salesman extends Employee&#123; get type()&#123;&#125;&#125;function createEmployee(name, type)&#123; switch(type)&#123; case &#x27;engineer&#x27;: return new Engineer(name) case &#x27;salesman&#x27;: return new Salesman(name) &#125;&#125; 做法 封装类型码字段 任选一个类型码取值，创建一个子类，复写类型码类的取值函数，令其返回类型码的字面量 创建一个选择器的逻辑，把类型码参数映射到新的子类 正对每个类型码都重复创建子类 12345678910111213class Employee &#123; constructor(name, type)&#123; this.validateType(type) this._name = name this._type = type &#125; validateType(type)&#123; if(![&#x27;engineer&#x27;, &#x27;salesman&#x27;, &#x27;manager&#x27;].includes(type))&#123; throw new Error(&#x27;Invalid type&#x27;) &#125; &#125; toString() &#123; return `$&#123;this._name&#125; ($&#123;this._type&#125;)`&#125;&#125; 1234567891011121314151617181920212223class Employee &#123; constructor(name)&#123; this._name = name &#125; toString() &#123; return `$&#123;this._name&#125; ($&#123;this.type&#125;)`&#125;&#125;class Engineer extends Employee&#123; get type()&#123; return &#x27;engineer&#x27; &#125;&#125;class Salesman extends Employee&#123; get type()&#123; return &#x27;salesman&#x27; &#125;&#125;class Manager extends Employee&#123; get type()&#123; return &#x27;manager&#x27; &#125;&#125;function createEmployee(name, type)&#123; switch(type)&#123; case &#x27;engineer&#x27;: return new Engineer(name) case &#x27;salesman&#x27;: return new Salesman(name) case &#x27;manager&#x27;: return new Manager(name) default: throw new Error(&#x27;Invalid type&#x27;) &#125;&#125; 移除子类 如果子类的用处太小，则可以移除子类，替换成超类的一个字段 12345678910class Person&#123; get genderCode()&#123;&#125;&#125;class Male extends Person&#123; get genderCode()&#123;&#125;&#125;class Female extends Person&#123; get genderCode()&#123;&#125;&#125;function isMale(aPerson)&#123; return aPerson instanceof Male&#125; 123456class Person&#123; constructor()&#123; this.genderCode = genderCode || &#x27;X&#x27; &#125; get isMale()&#123; ... &#125;&#125; 做法 把子类的构造函数包装到超类的工厂中 新建一个字段用于代表子类的类型 将原来针对子类的判断函数修改未使用新建类字段 12345678910111213class Person&#123; constructor(name)&#123; this.name = name &#125; get genderCode()&#123; return &#x27;X&#x27; &#125;&#125;class Male extends Person&#123; get genderCode()&#123; return &#x27;X&#x27; &#125;&#125;class Female extends Person&#123; get genderCode()&#123; return &#x27;F&#x27; &#125;&#125;function isMale(aPerson)&#123; return aPerson instanceof Male&#125; 1234567class Person&#123; constructor(name, genderCode)&#123; this.name = name this.genderCode = genderCode || &#x27;X&#x27; &#125; get isMale()&#123; return this.genderCode === &#x27;X&#x27; &#125;&#125; 提炼超类 如果两个类在做相似的事情，可以继承机制把他们的相似之处提炼到超类中 12class Employee &#123;&#125;class Department &#123;&#125; 1234567class Party&#123; constructor(name)&#123; this.name = name &#125;&#125;class Employee extends Party&#123;&#125;class Department extends Party&#123;&#125; 做法 为原本的类新建一个超类 把共同元素梳理出来移动到超类中 1234567891011121314151617181920class Employee &#123; constructor(name, id, monthlyCost)&#123; this.name = name this.id = id this.monthlyCost = monthlyCost &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Department &#123; constructor(name, staff)&#123; this.name = name this.staff = staff &#125; get totalMonthlyCost()&#123; return this.staff.map(e =&gt; e.monthlyCost).reduce((prev, cur) =&gt; prev + cur, 0) &#125; get totalAnnualCost()&#123; return this.totalMonthlyCost * 12 &#125;&#125; 12345678910111213141516171819202122class Party&#123; constructor(name)&#123; this.name = name &#125; get annualCost()&#123; return this.monthlyCost * 12 &#125;&#125;class Employee extends Party&#123; constructor(name, id, monthlyCost)&#123; super(name) this.id = id this.monthlyCost = monthlyCost &#125;&#125;class Department extends Party&#123; constructor(name, staff)&#123; super(name) this.staff = staff &#125; get monthlyCost()&#123; return this.staff.map(e =&gt; e.monthlyCost).reduce((prev, cur) =&gt; prev + cur, 0) &#125;&#125; 折叠继承体系 当子类与父类没多大差别时，直接折叠子类与超类 做法 选择要移除的类 将其移动到目标类中 以委托取代子类 继承存在局限性，应该用组合与继承相结合的方式去改造 12class Booking&#123;&#125;class PremiumBooking extends Booking&#123;&#125; 123456789class Booking&#123; _bePremium()&#123; this._premium = new PremiumBookingDelegate(this, extra) &#125;&#125;class PremiumBookingDelegate&#123;&#125;function createPremiumBooking(extra)&#123; booking._bePremium(extra)&#125; 做法 如果构造函数由多个调用者，先用工厂函数包裹起来 创建一个空的委托累，这个类的构造函数应该接受所有子类特有的数据项，并以参数的形式接受一个指回超类的引用 在超类中添加一个字段，用于安放委托对象 修改子类的创建逻辑，使其初始化上述的委托字段，放入一个委托对象实例 选择一个子类的函数，使用搬移函数移动函数放入委托类 如果被搬移函数还在子类之外被调用，就把留在源类中的委托代码从子类移到超类，并委托代码前加上卫语句，检查委托对象存在。 如果没有，则直接移除代码，重复上述过程，直到所有函数都移动到委托类1234567891011121314151617181920212223242526272829class Booking&#123; constructor(show, date)&#123; this.show = show this.date = date &#125; get hasTalkBack()&#123; return this.show.talkBack &amp;&amp; !this.isPeakDay &#125; get basePrice()&#123; let result = this.show.price if(this.isPeakDay) result *= 1.15 return result &#125;&#125;class PremiumBooking extends Booking&#123; constructor(show, date, extra)&#123; super(show, date) this.extra = extra &#125; get hasTalkBack()&#123; return this.show.talkBack &#125; get basePrice()&#123; return super.basePrice * this.extra.fee &#125; get hasDinner()&#123; return this.extra.dinner &amp;&amp; !this.isPeakDay &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243class Booking&#123; constructor(show, date)&#123; this.show = show this.date = date &#125; get hasTalkBack()&#123; return this._premiumDelegate ? this._premiumDelegate.hasTalkBack : this.show.talkBack &amp;&amp; !this.isPeakDay &#125; get basePrice()&#123; let result = this.show.price if(this.isPeakDay) result *= 1.15 return this._premiumDelegate ? this._premiumDelegate.extendBasePrice(result) : result &#125; get hasDinner()&#123; return this._premiumDelegate ? this._premiumDelegate.hasDinner : false &#125; _bePremium(extra)&#123; this._premiumDelegate = new PremiumBookingDelegate(this, extra) &#125;&#125;class PremiumBookingDelegate&#123; constructor(hostBooking, extra)&#123; this.host = hostBooking this.extra = extra &#125; get hasTalkBack()&#123; return this.host.show.talkBack &#125; get hasDinner()&#123; return this.extra.dinner &amp;&amp; !this.host.isPeakDay &#125; extendBasePrice(base)&#123; return base * this.extra.fee &#125;&#125;function createBooking(show, date)&#123; return new Booking(show, date)&#125;function createPremiumBooking(show, date, extra)&#123; let result = new Booking(show, date) result._bePremium(extra) return result&#125; 以委托取代超类 优先使用继承，当继承有问题，使用委托取代超类 12class CatalogItem&#123;...&#125;class Scroll extends CatalogItem&#123;...&#125; 123456class CatalogItem&#123;...&#125;class Scroll&#123; constructor(catalogId, catalog)&#123; this.catalogItem = catalog.get(catalogId) // new CatalogItem() &#125;&#125; 做法 在子类中新建一个字段，使其引用超类的一个对象，并将这个委托引用初始化为超类的实例 针对超类每个函数，在子类中创建一个转发函数，将请求转发给委托引用 当所有的超类函数都被转发函数覆盖后，去除继承关系 123456789101112131415161718192021class CatalogItem&#123; constructor(id, title, tags)&#123; this.id = id this.title = title this.tags = tags &#125; hasTag(arg)&#123; return this.tags.includes(arg) &#125;&#125;class Scroll extends CatalogItem&#123; constructor(id, title, tags, dateLastCleaned)&#123; super(id, title, tags) this.lastCleaned = dateLastCleaned &#125; needsCleaning(targetDate)&#123; const threshold = this.hasTag(&#x27;revered&#x27;) ? 700 : 1500 return this.daysSinceLastCleaning(targetDate) &gt; threshold &#125; daysSinceLastCleaning(targetDate)&#123; return this.lastCleaned.until(targetDate) &#125;&#125; 1234567891011121314151617181920212223242526class CatalogItem&#123; constructor(id, title, tags)&#123; this.id = id this.title = title this.tags = tags &#125; hasTag(arg)&#123; return this.tags.includes(arg) &#125;&#125;class Scroll&#123; constructor(id, dateLastCleaned, catalogId, catalog)&#123; this.id = id this.catalogItem = catalog.get(catalogId) this.lastCleaned = dateLastCleaned &#125; get id()&#123;return this.catalogItem.id&#125; get title()&#123;return this.catalogItem.title&#125; get tags()&#123;return this.catalogItem.tags&#125; hasTag(arg)&#123; return this.catalogItem.hasTag(arg) &#125; needsCleaning(targetDate)&#123; const threshold = this.hasTag(&#x27;revered&#x27;) ? 700 : 1500 return this.daysSinceLastCleaning(targetDate) &gt; threshold &#125; daysSinceLastCleaning(targetDate)&#123; return this.lastCleaned.until(targetDate) &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"重构","slug":"重构","permalink":"https://luoyuda.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"重构：改善既有代码的设计-笔记(二)","slug":"refactor/02","date":"2021-08-11T12:23:00.000Z","updated":"2021-08-11T12:23:00.000Z","comments":true,"path":"2021/08/11/refactor/02/","link":"","permalink":"https://luoyuda.github.io/2021/08/11/refactor/02/","excerpt":"","text":"theme: github重构：改善既有代码的设计-购书链接 封装 封装记录 用数据类取代记录型结构 1const organization = &#123; name:&#x27;Acme&#x27;, country: &quot;GB&quot; &#125; 12345678class Organization &#123; constructor(data)&#123; this._name = data.name &#125; get name()&#123; return this._name &#125; set name(name)&#123; this._name = name &#125;&#125;const organization = new Organization(&#123;...&#125;) 做法 对持有记录的变量使用封装变量，将其封装在一个函数中 创建一个类，将记录包装起来，并将记录变量的只替换成该类的一个实例，然后在类上定义访问和修改的函数 新建一个函数，让它返回该类的对象，而非原始记录 替换项目中的使用点 1234567const organization = &#123; name:&#x27;Acme&#x27;, country: &quot;GB&quot; &#125;let result = &#x27;&#x27;result += `&lt;h1&gt;$&#123;organization.name&#125; : $&#123;organization.country&#125;&lt;/h1&gt;\\n`organization.name = &#x27;121&#x27;organization.country = &#x27;121&#x27;result += `&lt;h1&gt;$&#123;organization.name&#125; : $&#123;organization.country&#125;&lt;/h1&gt;`console.log(result) 1234567891011121314151617class Organization &#123; constructor(data)&#123; this._name = data.name this._country = data.country &#125; get name()&#123; return this._name &#125; get country()&#123; return this._country &#125; set name(name)&#123; this._name = name &#125; set country(country)&#123; this._country = country &#125;&#125;const organization = new Organization(&#123; name:&#x27;Acme&#x27;, country: &quot;GB&quot; &#125;)let result = &#x27;&#x27;result += `&lt;h1&gt;$&#123;organization.name&#125; : $&#123;organization.country&#125;&lt;/h1&gt;\\n`organization.name = &#x27;121&#x27;organization.country = &#x27;121&#x27;result += `&lt;h1&gt;$&#123;organization.name&#125; : $&#123;organization.country&#125;&lt;/h1&gt;`console.log(result) 封装集合 对可变数据进行封装，不返回源数据 1234567class Person &#123; get courses() &#123; return this._courses &#125; set courses(courses) &#123; this._courses = courses &#125;&#125;class Course &#123; ...&#125; 123456789class Person &#123; get courses() &#123; return this._courses.slice() &#125; set courses(courses) &#123; this._courses = courses.slice() &#125; addCourse(aCourse) &#123; ... &#125; removeCourse(aCourse) &#123; ... &#125;&#125;class Course &#123; ...&#125; 做法 如果集合对引用尚未封装，则先用封装变量封装 在类上增加用于增删对函数 查找集合的引用点，修改后测试 每次只返回一份只读的副本 123456789101112131415161718192021class Person &#123; constructor(name)&#123; this._name = name this._courses = [] &#125; get name()&#123;return this._name &#125; get courses() &#123; return this._courses &#125; set courses(courses) &#123; this._courses = courses &#125;&#125;class Course &#123; constructor(name, isAdvanced)&#123; this._name = name this._isAdvanced = isAdvanced &#125; get name()&#123;return this._name &#125; get isAdvanced()&#123;return this._isAdvanced &#125;&#125;const CoursesName = [&#123; name:&#x27;Math&#x27;, isAdvanced: true &#125;, &#123; name:&#x27;Chinese&#x27;, isAdvanced: true &#125;, &#123; name:&#x27;English&#x27;, isAdvanced: false &#125;]const p = new Person(&#x27;xy&#x27;)p.courses = CoursesName.map((&#123; name, isAdvanced &#125;) =&gt; new Course(name, isAdvanced))p.courses.push(new Course(&#x27;history&#x27;, true)) // 无法监测的行为！ 1234567891011121314151617181920212223242526272829class Person &#123; constructor(name)&#123; this._name = name this._courses = [] &#125; get name()&#123;return this._name &#125; get courses() &#123; return this._courses.slice() &#125; set courses(courses) &#123; this._courses = courses.slice() &#125; addCourse(aCourse) &#123; this._courses.push(aCourse) &#125; removeCourse(aCourse)&#123; const index = this._courses.indexOf(aCourse) if(index === -1) throw new RangeError(&quot;not in&quot;) this._courses.splice(index, 1) &#125;&#125;class Course &#123; constructor(name, isAdvanced)&#123; this._name = name this._isAdvanced = isAdvanced &#125; get name()&#123;return this._name &#125; get isAdvanced()&#123;return this._isAdvanced &#125;&#125;const CoursesName = [&#123; name:&#x27;Math&#x27;, isAdvanced: true &#125;, &#123; name:&#x27;Chinese&#x27;, isAdvanced: true &#125;, &#123; name:&#x27;English&#x27;, isAdvanced: false &#125;]const history = new Course(&#x27;history&#x27;, true)const p = new Person(&#x27;xy&#x27;)p.courses = CoursesName.map((&#123; name, isAdvanced &#125;) =&gt; new Course(name, isAdvanced))p.addCourse(history)p.removeCourse(history) 以对象取代基本类型 当基本数据类型不满足业务需求时，将其封装成类方便管理 1234class Order&#123; get priority()&#123;return this._priority &#125;&#125;const priorities = [&#x27;low&#x27;, &#x27;normal&#x27;, &#x27;high&#x27;, &#x27;rush&#x27;] 12345678910class Order&#123; constructor(data)&#123; this._priority = new Priority() &#125;&#125;class Priority&#123; toString()&#123;return this._value&#125; static legalValues()&#123;return [&#x27;low&#x27;, &#x27;normal&#x27;, &#x27;high&#x27;, &#x27;rush&#x27;]&#125;&#125;const priorities = Priority.legalValues() 做法 如果变量未被封装起来，则先封装变量 为数据值创建一个简单的类，保存数据并提供取值函数 修改第一步得到的设值函数，令其创建一个新类的对象将其存入字段 修改取值函数，令其调用新类的取值函数 123456789class Order&#123; constructor(data)&#123; this._priority = data.priority &#125; get priority()&#123;return this._priority &#125;&#125;const priorities = [&#x27;low&#x27;, &#x27;normal&#x27;, &#x27;high&#x27;, &#x27;rush&#x27;]let orders = new Array(10).fill(0).map((item, index) =&gt; new Order(&#123; priority: priorities[index % 4] &#125;))console.log(orders.filter(item =&gt; item.priority === &#x27;high&#x27; || item.priority === &#x27;rush&#x27;)) 1234567891011121314151617181920212223242526272829class Order&#123; constructor(data)&#123; this._priority = new Priority(data.priority) &#125; get priorityString()&#123;return this._priority.toString() &#125; get priority()&#123;return this._priority&#125; set priority(aString)&#123;this._priority = new Priority(aString)&#125;&#125;class Priority&#123; constructor(value)&#123; if(value instanceof Priority) return value if(Priority.legalValues().includes(value))&#123; this._value = value &#125;else&#123; throw new Error(&#x27;invalid for Priority&#x27;) &#125; &#125; toString()&#123;return this._value&#125; static legalValues()&#123;return [&#x27;low&#x27;, &#x27;normal&#x27;, &#x27;high&#x27;, &#x27;rush&#x27;]&#125; get _index()&#123; return Priority.legalValues().findIndex(item =&gt; item === this._value) &#125; equals(order) &#123; return this._index === order._index &#125; higherThan(order) &#123; return this._index &gt; order._index &#125; lessThan(order) &#123; return this._index &lt; order._index &#125;&#125;const priorities = Priority.legalValues()const normal = new Priority(&#x27;normal&#x27;)let orders = new Array(10).fill(0).map((item, index) =&gt; new Order(&#123; priority: priorities[index % 4] &#125;))console.log(orders.filter(item =&gt; item.priority.higherThan(normal))) 以查询取代临时变量 将临时变量中的计算逻辑移动到类&#x2F;函数中，通过查询获取 1234567class Order &#123; get price() &#123; let basePrice = ... let discountFactor = ... return basePrice * discountFactor &#125;&#125; 12345class Order &#123; get price() &#123;...&#125; get basePrice() &#123; ... &#125; get discountFactor() &#123;...&#125;&#125; 做法 检查变量在是否完全计算完毕，是否存在副作用 如果变量不是只读的，可以先改造成只读变量 将变量赋值代码提炼成设值函数 123456789101112class Order &#123; constructor(quantity, item)&#123; this._quantity = quantity this._item = item &#125; get price() &#123; let basePrice = this._quantity * this._item.price let discountFactor = 0.98 if(basePrice &gt; 1000) discountFactor -= 0.03 return basePrice * discountFactor &#125;&#125; 123456789101112131415class Order &#123; constructor(quantity, item)&#123; this._quantity = quantity this._item = item &#125; get price() &#123; return this.basePrice * this.discountFactor &#125; get basePrice() &#123; return this._quantity * this._item.price &#125; get discountFactor() &#123; let discountFactor = 0.98 if(this.basePrice &gt; 1000) discountFactor -= 0.03 return discountFactor &#125;&#125; 提炼类（内联类） 将较大的类中的模块分离出去成为独立的类 123class Person &#123; ...&#125; 12345678class Person &#123; constructor(name)&#123; this._telephoneNumber = new TelephoneNumber() &#125;&#125;class TelephoneNumber&#123; ...&#125; 做法 决定如何分解类所负的责任 创建一个新的类，用以表现从旧类中分离出来的责任 构造旧类时创建一个新类的实例，建立联系 搬移字段，函数，去掉不再需要的函数接口 1234567891011class Person &#123; constructor(name)&#123; this._name = name &#125; get name()&#123;return this._name &#125; get telephoneNumber()&#123;return `($&#123;this.officeAreaCode&#125;) $&#123;this.officeNumber&#125;` &#125; get officeAreaCode()&#123;return this._officeAreaCode &#125; set officeAreaCode(arg)&#123;return this._officeAreaCode = arg &#125; get officeNumber()&#123;return this._officeNumber &#125; set officeNumber(arg)&#123;return this._officeNumber = arg &#125;&#125; 12345678910111213141516171819class Person &#123; constructor(name)&#123; this._name = name this._telephoneNumber = new TelephoneNumber() &#125; get name()&#123;return this._name &#125; get telephoneNumber()&#123;return this._telephoneNumber.toString() &#125; get officeAreaCode()&#123;return this._telephoneNumber.areaCode &#125; set officeAreaCode(arg)&#123;return this._telephoneNumber.areaCode = arg &#125; get officeNumber()&#123;return this._telephoneNumber.number &#125; set officeNumber(arg)&#123;return this._telephoneNumber.number = arg &#125;&#125;class TelephoneNumber&#123; get number()&#123;return this._number&#125; set number(arg)&#123;return this._number = arg&#125; get areaCode()&#123;return this._areaCode &#125; set areaCode(arg)&#123;return this._areaCode = arg&#125; toString()&#123;return `($&#123;this._areaCode&#125;) $&#123;this._number&#125;`&#125;&#125; 内联类（提炼类） 当一个类不再承担足够的责任时，将其直接内联到引用其的类中 12345678class Shipment &#123; constructor()&#123; this._trackingInformation = new TrackingInformation(company, number) &#125;&#125;class TrackingInformation &#123; ...&#125; 123456class Shipment &#123; constructor()&#123; ... &#125; ... //TrackingInformation&#125; 做法 对于内联类中的所有函数，在目标类中创建对应的函数 修改源类函数所有的引用点，令其调用目标类对应的委托方法 将所有的函数数据移动到目标类中 12345678910111213141516171819class TrackingInformation &#123; constructor(company, number)&#123; this._shippingCompany = company this._trackingNumber = number &#125; get shippingCompany()&#123;return this._shippingCompany&#125; set shippingCompany(arg) &#123;this._shippingCompany = arg&#125; get trackingNumber()&#123;return this._trackingNumber&#125; set trackingNumber(arg) &#123;this._trackingNumber = arg&#125; get display()&#123; return `$&#123;this.shippingCompany&#125; $&#123;this.trackingNumber&#125;` &#125;&#125;class Shipment &#123; constructor(name, company, number)&#123; this._name = name this._trackingInformation = new TrackingInformation(company, number) &#125; get trackingInfo()&#123;return this._trackingInformation.display&#125; get trackingInformation()&#123;return this._trackingInformation&#125;&#125; 12345678910111213class Shipment &#123; constructor(name, company, number)&#123; this._name = name this._shippingCompany = company this._trackingNumber = number &#125; get shippingCompany()&#123;return this._shippingCompany&#125; set shippingCompany(arg) &#123;this._shippingCompany = arg&#125; get trackingNumber()&#123;return this._trackingNumber&#125; set trackingNumber(arg) &#123;this._trackingNumber = arg&#125; get trackingInfo()&#123; return `$&#123;this.shippingCompany&#125; $&#123;this.trackingNumber&#125;` &#125; get trackingInformation()&#123;return &#123; _shippingCompany: this.shippingCompany, _trackingNumber: this._trackingNumber&#125;&#125;&#125; 隐藏委托关系（移除中间人） 隐藏跨级引用的情况，增加快速访问的接口 123456class Person &#123; get department()&#123;return this._department &#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode &#125;&#125; 123456class Person &#123; get manager()&#123;return this._department.manager &#125;&#125;class Department &#123; get manager()&#123;return this._manager&#125;&#125; 做法 对于每个委托关系的函数，在服务对象端建立一个简单的委托函数 调整客户端，令其调用服务对象提供的函数 1234567891011121314class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125; get department()&#123;return this._department &#125; set department(arg)&#123;this._department = arg&#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode&#125; set chargeCode(arg)&#123;this._chargeCode = arg&#125; get manager()&#123;return this._manager&#125; set manager(arg)&#123;this._manager = arg&#125;&#125; 1234567891011121314class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125; set department(arg)&#123;this._department = arg&#125; get manager()&#123;return this._department.manager &#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode&#125; set chargeCode(arg)&#123;this._chargeCode = arg&#125; get manager()&#123;return this._manager&#125; set manager(arg)&#123;this._manager = arg&#125;&#125; 移除中间人（隐藏委托关系） 类中存在大量的委托函数，服务类变成类一个中间人 123456class Person &#123; get manager()&#123;return this._department.manager &#125;&#125;class Department &#123; get manager()&#123;return this._manager&#125;&#125; 123456class Person &#123; get department()&#123;return this._department &#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode &#125;&#125; 做法 为受托对象创建一个取值函数 对于每个委托函数，是客户端转为连续的调用访问 123456789101112131415class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125; set department(arg)&#123;this._department = arg&#125; get manager()&#123;return this._department.manager &#125; get chargeCode()&#123;return this._department.chargeCode&#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode&#125; set chargeCode(arg)&#123;this._chargeCode = arg&#125; get manager()&#123;return this._manager&#125; set manager(arg)&#123;this._manager = arg&#125;&#125; 1234567891011121314class Person &#123; constructor(name)&#123; this._name = name; &#125; get name()&#123;return this._name &#125; get department()&#123;return this._department &#125; set department(arg)&#123;this._department = arg&#125;&#125;class Department &#123; get chargeCode()&#123;return this._chargeCode&#125; set chargeCode(arg)&#123;this._chargeCode = arg&#125; get manager()&#123;return this._manager&#125; set manager(arg)&#123;this._manager = arg&#125;&#125; 替换算法 使用更清晰的方式替换复杂的方式 123456function findPerson(people)&#123; for(let i = 0; i &lt; people.length; i++)&#123; if(people[i] === &#x27;Don&#x27;) return &#x27;Don&#x27; &#125; return &#x27;&#x27;&#125; 123function findPerson(people) &#123; return people.find(p =&gt; [&#x27;Don&#x27;].includes(p)) || &#x27;&#x27;&#125; 做法 整理代替换的算法，确保它以及被抽取到一个独立的函数中 为函数准备测试，固定其行为 准备好另一个算法进行替换 12345678function findPerson(people)&#123; for(let i = 0; i &lt; people.length; i++)&#123; if(people[i] === &#x27;Don&#x27;) return &#x27;Don&#x27; if(people[i] === &#x27;Join&#x27;) return &#x27;Join&#x27; if(people[i] === &#x27;Kent&#x27;) return &#x27;Kent&#x27; &#125; return &#x27;&#x27;&#125; 1234function findPerson(people) &#123; const candidates = [&#x27;Don&#x27;, &#x27;Join&#x27;, &#x27;Kent&#x27;] return people.find(p =&gt; candidates.includes(p)) || &#x27;&#x27;&#125; 搬移特性 搬移函数 合理的把函数放置在它应该出现的位置 1234function trackSummary(points)&#123; ... function distance(p1, p2)&#123;...&#125;&#125; 12function trackSummary(points)&#123; ... &#125;function distance(p1, p2)&#123;...&#125; 做法 检查函数在当前上下文引用的元素，考虑是否将他们一起搬移 检查待搬移函数是否具有多态性 将函数复制一份到目标的上下文中，调整函数 12345678910111213141516171819202122232425262728293031function trackSummary(points)&#123; const totalTime = calculateTime() const totalDistance = calculateDistance() const pace = totalTime / 60 / totalDistance return &#123; time: totalTime, distance: totalDistance, pace &#125; function calculateDistance()&#123; let result = 0 for(let i = 1; i &lt; points.length; i++)&#123; result += distance(points[i - 1], points[i]) &#125; return result &#125; function distance(p1, p2)&#123; const EARTH_RADIUS = 3959 const dLat = radians(p2.lat) - radians(p1.lat) const dLon = radians(p2.lon) - radians(p1.lon) const a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(radians(p2.lat)) * Math.cos(radians(p1.lat)) * Math.pow(Math.sin(dLon / 2), 2) const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) return EARTH_RADIUS * c &#125; function radians(degrees)&#123; return degrees * Math.PI / 180 &#125; function calculateTime()&#123; return 6 &#125;&#125; 12345678910111213141516171819202122232425262728293031function trackSummary(points)&#123; const totalTime = calculateTime() const distance = totalDistance(points) const pace = totalTime / 60 / distance return &#123; time: totalTime, distance, pace &#125; function calculateTime()&#123; return 6 &#125;&#125;function totalDistance(points)&#123; let result = 0 for(let i = 1; i &lt; points.length; i++)&#123; result += distance(points[i - 1], points[i]) &#125; return result&#125;function distance(p1, p2)&#123; const EARTH_RADIUS = 3959 const dLat = radians(p2.lat) - radians(p1.lat) const dLon = radians(p2.lon) - radians(p1.lon) const a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(radians(p2.lat)) * Math.cos(radians(p1.lat)) * Math.pow(Math.sin(dLon / 2), 2) const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) return EARTH_RADIUS * c&#125;function radians(degrees)&#123; return degrees * Math.PI / 180&#125; 搬移字段 如果更新一个字段，需要同时在几个结构中进行修改，则表明该字段需要被搬移到一个集中的地点 1234567class Customer &#123; constructor(name, discountRate)&#123; this._discountRate = discountRate this._contact = new Contact() &#125;&#125;class Contact &#123; ... &#125; 12345678910class Customer &#123; constructor(name, discountRate)&#123; this._contact = new Contact(discountRate) &#125;&#125;class Contact &#123; constructor(discountRate)&#123; this._discountRate = discountRate &#125;&#125; 做法 确保源字段已经得到良好封装 在目标对象上创建一个字段 确保源对象能正常引用目标对象 调整源对象的访问函数，令其使用目标对象的字段 12345678910111213141516171819class Customer &#123; constructor(name, discountRate)&#123; this._name = name this._discountRate = discountRate this._contact = new Contact() &#125; get discountRate()&#123;return this._discountRate&#125; becomePreferred()&#123; return this._discountRate += 0.03 &#125; applyDiscount(amount)&#123; return amount - amount * this.discountRate &#125;&#125;class Contact &#123; constructor()&#123; this._startDate = new Date() &#125;&#125; 12345678910111213141516171819202122class Customer &#123; constructor(name, discountRate)&#123; this._name = name this._contact = new Contact(discountRate) &#125; get discountRate()&#123;return this._contact.discountRate&#125; _setDiscountRate(aNumber)&#123;return this._contact.discountRate = aNumber&#125; becomePreferred()&#123; return this._setDiscountRate(this._contact.discountRate += 0.03) &#125; applyDiscount(amount)&#123; return amount - amount * this.discountRate &#125;&#125;class Contact &#123; constructor(discountRate)&#123; this._startDate = new Date() this._discountRate = discountRate &#125; get discountRate()&#123;return this._discountRate&#125; set discountRate(arg)&#123;this._discountRate = arg&#125;&#125; 搬移语句到函数（搬移语句到调用者） 某些语句与一个函数放在一起更加像一个整体的时候，就可以将其搬移到函数中 12345678910function renderPerson(person)&#123; [`&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, ...emitPhotoData(person.photo)]&#125;function emitPhotoData(aPhoto)&#123; return [`&lt;p&gt;date: $&#123;aPhoto.date&#125;&lt;/p&gt;`]&#125;function renderPhoto(aPhoto)&#123; return [`&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date&#125;&lt;/p&gt;`].join(&#x27;/n&#x27;)&#125; 123456789function renderPerson(person)&#123; [...emitPhotoData(person.photo)]&#125;function emitPhotoData(aPhoto)&#123; return [`&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date&#125;&lt;/p&gt;`]&#125;function renderPhoto(aPhoto)&#123; return [...emitPhotoData(person.photo)].join(&#x27;/n&#x27;)&#125; 做法 如果重复的代码距离目标函数有些距离，先用移动语句 如果目标函数仅被唯一一个源函数调用，则只需要将源函数中重复的代码段剪切复制到函数中 如果由多个调用点，则先选择对一个调用点应用提炼函数，将待搬移语句与目标函数提炼成一个新函数 12345678910111213141516171819202122232425262728function renderPerson(person)&#123; const result = [] result.push(`&lt;p&gt;$&#123;person.name&#125;&lt;/p&gt;`) result.push(renderPhoto(person.photo)) result.push(`&lt;p&gt;title: $&#123;person.photo.title&#125;&lt;/p&gt;`) result.push(emitPhotoData(person.photo)) return result.join(&#x27;\\n&#x27;)&#125;function emitPhotoData(aPhoto)&#123; const result = [] result.push(`&lt;p&gt;location: $&#123;aPhoto.location&#125;&lt;/p&gt;`) result.push(`&lt;p&gt;date: $&#123;aPhoto.date.toDateString()&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderPhoto(aPhoto)&#123; const result = [] result.push(`&lt;p&gt;name: $&#123;aPhoto.name&#125;&lt;/p&gt;`) result.push(`&lt;p&gt;color: $&#123;aPhoto.color&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderDiv(person)&#123; return [ &quot;&lt;div&gt;&quot;, `&lt;p&gt;title: $&#123;person.photo.title&#125;&lt;/p&gt;`, emitPhotoData(person.photo), &quot;&lt;/div&gt;&quot; ].join(&#x27;\\n&#x27;)&#125; 123456789101112131415161718192021222324function renderPerson(person)&#123; const result = [] result.push(`&lt;p&gt;$&#123;person.name&#125;&lt;/p&gt;`) result.push(renderPhoto(person.photo)) result.push(emitPhotoData(person.photo)) return result.join(&#x27;\\n&#x27;)&#125;function renderPhoto(aPhoto)&#123; const result = [] result.push(`&lt;p&gt;name: $&#123;aPhoto.name&#125;&lt;/p&gt;`) result.push(`&lt;p&gt;color: $&#123;aPhoto.color&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderDiv(person)&#123; const result = [&quot;&lt;div&gt;&quot;, emitPhotoData(person.photo), &quot;&lt;/div&gt;&quot;] return result.join(&#x27;\\n&#x27;)&#125;function emitPhotoData(aPhoto) &#123; return [ `&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;location: $&#123;aPhoto.location&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date.toDateString()&#125;&lt;/p&gt;` ].join(&#x27;\\n&#x27;)&#125; 搬移语句到调用者（搬移语句到函数） 当函数边界发生偏移，在某些调用点表现出不同的行为 123456789101112131415161718192021function renderPerson(person)&#123; [...emitPhotoData(person.photo)]&#125;function emitPhotoData(aPhoto)&#123; return [`&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date&#125;&lt;/p&gt;`]&#125;function renderPhoto(aPhoto)&#123; return [...emitPhotoData(person.photo)].slice(1).join(&#x27;/n&#x27;)&#125;``` ```jsfunction renderPerson(person)&#123; [`&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, ...emitPhotoData(person.photo)]&#125;function emitPhotoData(aPhoto)&#123; return [`&lt;p&gt;date: $&#123;aPhoto.date&#125;&lt;/p&gt;`]&#125;function renderPhoto(aPhoto)&#123; return [...emitPhotoData(aPhoto)].join(&#x27;/n&#x27;)&#125; 做法 如果源函数很简单，且调用者也不多，则只需把要搬移的代码复制回去 若调用点不止一个，则先用提炼函数把不想搬移的代码提炼成一个新函数 对源函数应用内联函数，对提炼函数进行修改 123456789101112131415161718192021222324function renderPerson(person)&#123; const result = [] result.push(`&lt;p&gt;$&#123;person.name&#125;&lt;/p&gt;`) result.push(renderPhoto(person.photo)) result.push(emitPhotoData(person.photo)) return result.join(&#x27;\\n&#x27;)&#125;function renderPhoto(aPhoto)&#123; const result = [] result.push(`&lt;p&gt;name: $&#123;aPhoto.name&#125;&lt;/p&gt;`) result.push(`&lt;p&gt;color: $&#123;aPhoto.color&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderDiv(person)&#123; const result = [&quot;&lt;div&gt;&quot;, emitPhotoData(person.photo), &quot;&lt;/div&gt;&quot;] return result.join(&#x27;\\n&#x27;)&#125;function emitPhotoData(aPhoto) &#123; return [ `&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;location: $&#123;aPhoto.location&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date.toDateString()&#125;&lt;/p&gt;` ].join(&#x27;\\n&#x27;)&#125; 123456789101112131415161718192021222324252627function renderPerson(person)&#123; const result = [] result.push(`&lt;p&gt;$&#123;person.name&#125;&lt;/p&gt;`) result.push(renderPhoto(person.photo)) result.push(emitPhotoData(person.photo)) result.push(`&lt;p&gt;location: $&#123;person.photo.location&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderPhoto(aPhoto)&#123; const result = [] result.push(`&lt;p&gt;name: $&#123;aPhoto.name&#125;&lt;/p&gt;`) result.push(`&lt;p&gt;color: $&#123;aPhoto.color&#125;&lt;/p&gt;`) return result.join(&#x27;\\n&#x27;)&#125;function renderDiv(person)&#123; const result = [&quot;&lt;div&gt;&quot;, emitPhotoData(person.photo), `&lt;p&gt;location: $&#123;person.photo.location&#125;&lt;/p&gt;`, &quot;&lt;/div&gt;&quot;] return result.join(&#x27;\\n&#x27;)&#125;function emitPhotoData(aPhoto) &#123; return [ `&lt;p&gt;title: $&#123;aPhoto.title&#125;&lt;/p&gt;`, `&lt;p&gt;date: $&#123;aPhoto.date.toDateString()&#125;&lt;/p&gt;` ].join(&#x27;\\n&#x27;)&#125; 函数调用取代内联代码 通过函数的方式去消除重复的逻辑 12345let appliesToMass = false;let states = [&#x27;MA&#x27;]for(let s of states) &#123; if(s === &#x27;MA&#x27;) appliesToMass = true;&#125; 12let states = [&#x27;MA&#x27;]let appliesToMass = states.includes(&#x27;MA&#x27;); 做法 内联代码替代为对一个既有函数的调用 12345let appliesToMass = false;let states = [&#x27;MA&#x27;]for(let s of states) &#123; if(s === &#x27;MA&#x27;) appliesToMass = true;&#125; 12let states = [&#x27;MA&#x27;]let appliesToMass = states.includes(&#x27;MA&#x27;); 移动语句 让存在关联的代码一起出现，使代码更加容易理解 1234567if(stack.length === 0)&#123; ... stack.push(i)&#125;else&#123; ... stack.push(i)&#125; 123456if(stack.length === 0)&#123; ...&#125;else&#123; ...&#125;stack.push(i) 做法 确定待移动的代码片段应该搬完何处，搬移后是否会影响正常工作 搬移代码 12345678910let result, stack = []for(let i = 0; i &lt; 5; i++)&#123; if(stack.length === 0)&#123; result = 0 stack.push(i) &#125;else&#123; result = stack[stack.length - 1] stack.push(i) &#125;&#125; 123456789let result, stack = []for(let i = 0; i &lt; 5; i++)&#123; if(stack.length === 0)&#123; result = 0 &#125;else&#123; result = stack[stack.length - 1] &#125; stack.push(i)&#125; 拆分循环 拆分身兼多职的循环，让代码更加易读 1234for (const p of people) &#123; if(p.age &lt; youngest) youngest = p.age totalSalary += p.salary&#125; 12let youngest = Math.min(...people.map(p =&gt; p.age))let totalSalary = people.reduce((prev, item) =&gt; prev + item.salary, 0) 做法 复制一遍循环代码 识别移除循环中的重复代码，使得每个循环只做一件事 拆分后使用提炼函数 12345678910111213const people = [ &#123; age: 20, salary: 10000 &#125;, &#123; age: 30, salary: 10000 &#125;, &#123; age: 25, salary: 20000 &#125;, &#123; age: 22, salary: 50000 &#125;, &#123; age: 26, salary: 60000 &#125;,]let youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0for (const p of people) &#123; if(p.age &lt; youngest) youngest = p.age totalSalary += p.salary&#125; 12let youngest = Math.min(...people.map(p =&gt; p.age))let totalSalary = people.reduce((prev, item) =&gt; prev + item.salary, 0) 管道取代循环 使用管道优化迭代结构，可读性更强 12345function acquireData(input) &#123; for (const line of lines) &#123; ... &#125;&#125; 123function acquireData(input) &#123; lines.slice(1).filter(line =&gt; line.trim() !== &#x27;&#x27;)...&#125; 做法 创建一个新变量，用于存放和参与循环过程的集合 从顶部开始，将循环每一块行为都搬移出来，在上一步创建的集合变量用一种管道运算替代 12345678910111213141516171819202122232425262728const input = `office, country, telephoneChicago, USA, +1 312 373 1000Beijing, China, +86 4000 900 505Chicago, USA, +1 312 373 1000Beijing, China, +86 4000 900 505Chicago, USA, +1 312 373 1000Beijing, China, +86 4000 900 505`;function acquireData(input) &#123; const lines = input.split(&#x27;\\n&#x27;) let firstLine = true const result = [] for (const line of lines) &#123; if(firstLine) &#123; firstLine = false continue &#125; if(line.trim() === &#x27;&#x27;) continue const record = line.split(&#x27;,&#x27;) if(record[1].trim() === &#x27;China&#x27;)&#123; result.push(&#123; city: record[0].trim(), phone: record[2].trim(), &#125;) &#125; &#125; return result&#125; 123456789101112function acquireData(input) &#123; const lines = input.split(&#x27;\\n&#x27;) return lines .slice(1) .filter(line =&gt; line.trim() !== &#x27;&#x27;) .map(line =&gt; line.split(&#x27;,&#x27;)) .filter(record =&gt; record[1].trim() === &#x27;China&#x27;) .map(record =&gt; (&#123; city: record[0].trim(), phone: record[2].trim(), &#125;))&#125; 移除死代码 没用的东西大胆删除了他，不然越来越多","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"重构","slug":"重构","permalink":"https://luoyuda.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"重构：改善既有代码的设计-笔记(一)","slug":"refactor/01","date":"2021-08-11T11:23:00.000Z","updated":"2021-08-11T11:23:00.000Z","comments":true,"path":"2021/08/11/refactor/01/","link":"","permalink":"https://luoyuda.github.io/2021/08/11/refactor/01/","excerpt":"","text":"theme: github重构：改善既有代码的设计-购书链接 重构的第一步：确保重构代码有一组可靠的测试！重构的第一步：确保重构代码有一组可靠的测试！重构的第一步：确保重构代码有一组可靠的测试！ 基本概念重构：对软件内部结构对一种调整，在不改变软件可观察行为对前提下，提高可理解性，降低修改成本 目的 改进软件的设计 使软件更易理解 帮助寻找隐性bug 提高编程速度 重构时机 预备性重构：添加新功能更加容易 帮助理解的重构：使代码更加易懂 捡垃圾式重构：每次清理都让代码更好一点 有计划的重构 替换性的重构：替换一些依赖模块 代码的坏味道 神秘命名：一个好的名字，清晰的表明自己的功能和用法（改变函数声明、变量改名、字段改名） 重复代码：在一个以上的地方看到相同的代码（提炼函数、移动语句、函数上移） 过长函数：函数越长，阅读复杂度越高（提炼函数、以查询取代临时变量、引入参数对象、以命令取代函数） 过长参数列表：参数过长容易使人迷惑（以查询去取代临时变量、参数对象） 全局数据：在项目中任何一处都可能改变它，且无法定位哪里发生改变（封装变量） 可变数据：数据修改容易发生难以预料的bug（封装变量、拆分变量） 发散式的变化：一个函数只负责一种类型的上下文状态（提炼函数） 霰弹式修改：发生变化时需要在不同的类中做修改（内联函数、内联类） 依恋情节：减少模块间的交互（搬移函数） 数据泥团：数据聚合在一起，拆分成粒度更小的方式（提炼类、参数对象） 基本类型偏执：使用错误的数据类型处理数据（以对象取代基本类型） 重复的switch：当你想增加一个选择分支时需要找到所有的分支确认（多态取代条件表达式） 循环语句：需要通读代码才明白循环内的语义（以管道代替循环） 冗赘的元素：程序元素增加代码结构，从而支持变化、促进复用，但有时候只是简单的函数（内联函数、内联类） 夸夸其谈通用性：放弃用不到的情况，比如各种各样的钩子，只做有限开发（移除死代码） 临时字段：仅仅为了某种特殊情况创建的字段 过长的消息链：A对象访问B对象，B对象访问C对象…直到E对象（隐藏委托关系） 中间人：过度委托（移除中间人） 内幕交易：模块之间交换数据（搬移函数、搬移字段、隐藏委托关系） 过大的类：单个类做了太多事情（提炼类） 异曲同工的类：相同类型的类应该保持接口一致（改变函数声明、搬移函数、提炼超类） 纯数据类：拥有一些字段以及用于访问字段的函数（封装记录） 被拒绝的馈赠：子类并不需要超类的大部分字段&#x2F;函数（以委托取代子类） 注释：当你需要写注释的时候，先尝试重构把所有的注释变得多余 重构技术 提炼函数（内联函数） 将代码提炼到一个独立的函数中，当你需要花时间浏览一段代码才能弄清楚它在干什么的时候，就应该提炼函数 1234function printOwing() &#123; ... // printBanner ... // printDetails&#125; 1234567function printOwing() &#123; printBanner() printDetails() return function printBanner()&#123; ... &#125; function printDetails()&#123; ... &#125;&#125; 做法： 创建一个新函数，根据函数意图命名 将代码从源函数复制到新建函数中 仔细查看提炼代码、作用域引用的变量，判断是否需要通过参数传入 所有变量处理完毕后编译 1234567891011121314151617181920212223242526272829303132333435const invoices = [ &#123; customer: &#x27;BigCo&#x27;, outstanding: [ &#123; amount: 10 &#125;, &#123; amount: 20 &#125; ] &#125;, &#123; customer: &#x27;Helle&#x27;, outstanding: [ &#123; amount: 30 &#125;, &#123; amount: 40 &#125; ] &#125;]function printOwing(invoice) &#123; console.log(&#x27;--- ---- ---&#x27;) console.log(&#x27;--- Owes ---&#x27;) console.log(&#x27;--- ---- ---&#x27;) let amounts = 0 for(let &#123; amount &#125; of invoice.outstanding) &#123; amounts += amount &#125; console.log(`name: $&#123;invoice.customer&#125;`) console.log(`amount: $&#123;amounts&#125;`)&#125; 12345678910111213141516171819function printOwing(invoice) &#123; printBanner() let outstanding = amountFor(invoice) printDetails(invoice, outstanding) return function printBanner()&#123; console.log(&#x27;--- ---- ---&#x27;) console.log(&#x27;--- Owes ---&#x27;) console.log(&#x27;--- ---- ---&#x27;) &#125; function amountFor(invoice)&#123; return invoice.outstanding.reduce((prev, item) =&gt; prev + item.amount, 0) &#125; function printDetails(invoice, outstanding)&#123; console.log(`name: $&#123;invoice.customer&#125;`) console.log(`amount: $&#123;outstanding&#125;`) &#125;&#125;invoices.forEach(printOwing) 内联函数（提炼函数） 一些本来就很易读代码可以直接内联在源函数内，可以减少间接层 123456function reportLines(aCustomer)&#123; ... gatherCustomerData(...) return function gatherCustomerData()&#123;...&#125;&#125; 12345function reportLines(aCustomer)&#123; ... ... // gatherCustomerData return lines&#125; 做法 检查函数，确定其不具备多态性 找出这个函数的所有调用点 把调用点替换成函数本体 替换之后执行测试 12345678910111213const customer = &#123; name: &#x27;BigCo&#x27;, location: &#x27;sz&#x27;&#125;function reportLines(aCustomer)&#123; const lines = [] gatherCustomerData(lines, aCustomer) return lines function gatherCustomerData(out, aCustomer)&#123; out.push([&#x27;name&#x27;, aCustomer.name]) out.push([&#x27;location&#x27;, aCustomer.location]) &#125;&#125; 123456function reportLines(aCustomer)&#123; const lines = [] lines.push([&#x27;name&#x27;, aCustomer.name]) lines.push([&#x27;location&#x27;, aCustomer.location]) return lines&#125; 提炼变量（内联变量） 将复杂冗长的表达式拆分成变量更加易读 123function price(order)&#123; return ...&#125; 1234function price(order)&#123; let basePrice return ...&#125; 做法 确认要提炼的表达式没有副作用 声明一个不可修改的变量，把想要提炼的表达式复制一份，以表达式的结果赋值给变量 用新变量取代原来的表达式 123456function price(order)&#123; // price is base price - quantity discount + shipping return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100)&#125; 1234567function price(order)&#123; // price is base price - quantity discount + shipping let basePrice = order.quantity * order.itemPrice let quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 let shipping = Math.min(basePrice * 0.1, 100) return basePrice - quantityDiscount + shipping&#125; 内联变量（内联变量） 可以通过内联变量的方法消除局部变量 1234function price(order)&#123; let basePrice return ...&#125; 123function price(order)&#123; return ...&#125; 做法 检查确认变量赋值语句的右侧表达式是否存在副作用 找到第一处使用该变量的地方，将其替换成赋值语句右侧的表达式 1234function price(order)&#123; let basePrice = order.basePrice; return (basePrice &gt; 1000)&#125; 123function price(order)&#123; return order.basePrice &gt; 1000&#125; 改变函数声明 将函数、变量修改成语义更好的名称 12// beforefunction circum (x)&#123;...&#125; 1234567// 简单做法function circumference (radius)&#123;...&#125;// 复杂做法function circum (radius)&#123; return circumference(radius) function circumference (radius)&#123;...&#125;&#125; 简单做法 迁移一个参数，需要确定函数体内没有使用参数 修改函数声明 找出引用处，替换 迁移做法 如果有必要，先对函数体内部进行重构，使得后面提炼步骤易于展开 使用提炼函数将函数体提炼成一个函数 如果提炼出的函数需要新增参数，则参考简单做法 对旧函数使用内联函数 123function circum (radius)&#123; return 2 * Math.PI * radius&#125; 1234567891011// 简单做法function circumference (radius)&#123; return 2 * Math.PI * radius&#125;// 复杂做法function circum (radius)&#123; return circumference(radius) function circumference (radius)&#123; return 2 * Math.PI * radius &#125;&#125; 123function isNewEndLand(aCustomer)&#123; return [&#x27;MA&#x27;, &#x27;CT&#x27;, &#x27;ME&#x27;, &#x27;VT&#x27;, &#x27;NH&#x27;, &#x27;NH&#x27;, &#x27;RI&#x27;].includes(aCustomer.address.state)&#125; 123456function isNewEndLand(aCustomer)&#123; return checkState(aCustomer.address.state) function checkState(state)&#123; return [&#x27;MA&#x27;, &#x27;CT&#x27;, &#x27;ME&#x27;, &#x27;VT&#x27;, &#x27;NH&#x27;, &#x27;NH&#x27;, &#x27;RI&#x27;].includes(state) &#125;&#125; 封装变量 将变量封装成函数调用的方式，方便修改和数据监控 1234567let defaultOwnerData = &#123;...&#125;function defaultOwner()&#123; return Object.assign(&#123;&#125;, defaultOwnerData)&#125;function setDefaultOwner(newOwner)&#123; return defaultOwnerData = newOwner&#125; 做法 创建封装函数，在其中访问和更新变量 执行静态检查 逐一修改使用变量的代码，将其改成调用合适的封装函数 限制变量的可变性 12345678910let defaultOwnerData = &#123; firstName: &#x27;Mt&#x27;, lastName: &#x27;Fl&#x27;&#125;function defaultOwner()&#123; return Object.assign(&#123;&#125;, defaultOwnerData)&#125;function setDefaultOwner(newOwner)&#123; return defaultOwnerData = newOwner&#125; 变量改名 取一个好的名字，是好的开始 12let a = &#x27;xy&#x27;a = &#x27;dq&#x27; 123let _name = &#x27;xy&#x27;function name()&#123; return _name &#125;function setName(name)&#123; _name = name &#125; 做法 如果变量被广泛引用，则运用封装变量将其封装 找到使用该变量的代码，注意修改 12345let tpHd = &#x27;111&#x27;;let result = &#x27;&#x27;result += `title: $&#123;tpHd&#125;\\n`tpHd = &#x27;222&#x27;;result += `title: $&#123;tpHd&#125;` 12345678let _title = &#x27;111&#x27;;let result = &#x27;&#x27;result += `title: $&#123;title()&#125;\\n`tpHd = setTitle(&#x27;222&#x27;);result += `title: $&#123;title()&#125;`function title() &#123; return _title &#125;function setTitle(title) &#123; _title = title &#125; 引入参数对象 使用参数对象代替多个参数的情况 123function readingsOutsideRange(station, min, max)&#123; return ...&#125; 1234class Range &#123; ... &#125;function readingsOutsideRange(station, range)&#123; return ...&#125; 做法 如果暂时没有一个合适的数据结构，那就创建一个 12345678910111213141516let station = &#123; name: &#x27;ZB1&#x27;, readings: [ &#123; temp: 47 &#125;, &#123; temp: 53 &#125;, &#123; temp: 28 &#125;, &#123; temp: 53 &#125;, &#123; temp: 61 &#125;, ],&#125;const min = 30const max = 60function readingsOutsideRange(station, min, max)&#123; return station.readings.filter((r) =&gt; r.temp &lt; min || r.temp &gt; max)&#125;let list = readingsOutsideRange(station, min, max) 1234567891011121314class Range &#123; constructor(min, max) &#123; this.min = min this.max = max &#125; contains(arg)&#123; return arg &gt;= this.min &amp;&amp; arg &lt;= this.max &#125;&#125;function readingsOutsideRange(station, range)&#123; return station.readings.filter(r =&gt; !range.contains(r.temp))&#125;let range = new Range(min, max)let list = readingsOutsideRange(station, range) 函数组合成类 一组函数形影不离的操作同一块数据，则这时候就可以组成一个类，这样可以少传递参数，简化调用 1234const reading = &#123;...&#125;function baseRate(month, year) &#123; ... &#125;const baseCharge = ...const base = ... 1234class Reading &#123; ...&#125;const aReading = new Reading(reading) 做法 通过封装记录对多个函数共用的数据进行封装 对于使用该记录结构的每个函数，通过搬移函数将其移入新类 用于处理该数据记录的逻辑可以用提炼函数提炼出来移动到新类 12345678910111213141516171819const reading = &#123; customer: &#x27;xy&#x27;, quantity: 10, month: 5, year: 2017&#125;function baseRate(month, year) &#123; return month * 0.1 + year * 0.15&#125;function taxThreshold(year) &#123; return year * 10&#125;const baseCharge = baseRate(reading.month, reading.year) * reading.quantityconst base = baseRate(reading.month, reading.year) * reading.quantityconst taxableCharge = Math.max(0, base - taxThreshold(reading.year))const amount = calculateBaseCharge(reading)function calculateBaseCharge(aReading) &#123; return baseRate(aReading.month, aReading.year) * aReading.quantity&#125; 1234567891011121314151617181920212223class Reading &#123; constructor(data) &#123; this._customer = data.customer this._quantity = data.quantity this._month = data.month this._year = data.year &#125; get customer() &#123; return this._customer &#125; get quantity() &#123; return this._quantity &#125; get month() &#123; return this._month &#125; get year() &#123; return this._year &#125; get baseCharge()&#123; return baseRate(this.month, this.year) * this.quantity &#125; get taxableCharge()&#123; return Math.max(0, this.baseCharge - taxThreshold(this.year)) &#125;&#125;const aReading = new Reading(reading)const baseCharge = aReading.baseChargeconst base = aReading.baseChargeconst taxableCharge = aReading.taxableChargeconst amount = aReading.baseCharge 函数组合变换 接受源数据作为输入，并派生出数据，将派生数据以字段形式填入输入输出数据 1234const reading = &#123;...&#125;function baseRate(month, year) &#123; ... &#125;const baseCharge = ...const base = ... 1234567function clone(obj)&#123; ... &#125;function enrichReading(aReading)&#123; let result = clone(aReading) ... return result&#125;const aReading = enrichReading(reading) 做法 创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值（注意这里最好是深复制） 提炼函数，将结果作为字段加入到增强对象中 12345678910111213141516171819const reading = &#123; customer: &#x27;xy&#x27;, quantity: 10, month: 5, year: 2017&#125;function baseRate(month, year) &#123; return month * 0.1 + year * 0.15&#125;function taxThreshold(year) &#123; return year * 10&#125;const baseCharge = baseRate(reading.month, reading.year) * reading.quantityconst base = baseRate(reading.month, reading.year) * reading.quantityconst taxableCharge = Math.max(0, base - taxThreshold(reading.year))const amount = calculateBaseCharge(reading)function calculateBaseCharge(aReading) &#123; return baseRate(aReading.month, aReading.year) * aReading.quantity&#125; 1234567891011121314function clone(obj)&#123; return JSON.parse(JSON.stringify(obj))&#125;function enrichReading(aReading)&#123; let result = clone(aReading) result.baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity result.taxableCharge = Math.max(0, result.baseCharge - taxThreshold(aReading.year)) return result&#125;const aReading = enrichReading(reading)const baseCharge = aReading.baseChargeconst base = aReading.baseChargeconst taxableCharge = aReading.taxableChargeconst amount = aReading.baseCharge 拆分阶段 一段代码在同时处理两件不同的事情，将其拆分成各自独立的模块 1234function priceOrder() &#123; ... return price&#125; 12345678910function priceOrder() &#123; const priceData = calculatePricingData() return applyShipping(priceData) function calculatePricingData()&#123; return &#123; ... &#125; &#125; function applyShipping(priceData)&#123; ... &#125;&#125; 做法 将二阶段的代码提炼成独立的函数 引入一个中转的数据结构，将其作为参数添加提炼出新函数的参数列表 逐一检查提炼出“第二阶段的每个参数”，如果某个参数被第一阶段用到，就将其移入中转数据结构 对第一阶段的代码运用提炼函数，让提炼出的函数返回中转数据结构 1234567891011121314/** * * @param &#123;&#123; basePrice: number, discountThreshold: number &#125;&#125; product * @param &#123;number&#125; quantity * @param &#123;&#123;discountThreshold: number, discountedFee: number, feePerCase: number&#125;&#125; shippingMethod */function priceOrder(product, quantity, shippingMethod) &#123; const basePrice = product.basePrice * quantity const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice const shippingPerCase = (basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase const shippingCost = quantity * shippingPerCase const price = basePrice - discount + shippingCost return price&#125; 1234567891011121314151617181920/*** * @param &#123;&#123; basePrice: number, discountThreshold: number &#125;&#125; product * @param &#123;number&#125; quantity * @param &#123;&#123;discountThreshold: number, discountedFee: number, feePerCase: number&#125;&#125; shippingMethod */function priceOrder(product, quantity, shippingMethod) &#123; const priceData = calculatePricingData(product, quantity) return applyShipping(priceData, shippingMethod) function calculatePricingData(product, quantity)&#123; const basePrice = product.basePrice * quantity const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice return &#123; basePrice, quantity, discount &#125; &#125; function applyShipping(priceData, shippingMethod)&#123; const shippingPerCase = (priceData.basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase const shippingCost = priceData.quantity * shippingPerCase return priceData.basePrice - priceData.discount + shippingCost &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"重构","slug":"重构","permalink":"https://luoyuda.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"React、Vue2 与 Vue3 的 diff 方法比较","slug":"Diff/01","date":"2021-06-24T11:23:00.000Z","updated":"2021-06-24T11:23:00.000Z","comments":true,"path":"2021/06/24/Diff/01/","link":"","permalink":"https://luoyuda.github.io/2021/06/24/Diff/01/","excerpt":"","text":"辅助方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 更新数据function patch(o, n)&#123; o.val = n.val&#125;// 模拟dom节点移动function insertBefore(prev, node, container, step = 0)&#123; if(prev === null)&#123; remove(node, container) container.push(node) return container &#125; if(prev &amp;&amp; prev.key === node.key) return container let idx = 0 for (let i = 0; i &lt; container.length; i++) &#123; const n = container[i]; if(n.key === node.key)&#123; [ node ] = container.splice(i, 1) break &#125; &#125; // console.log(prev, node, container) for (let i = 0; i &lt; container.length; i++) &#123; const n = container[i]; if(prev &amp;&amp; n.key === prev.key)&#123; idx = i + step break &#125; &#125; // console.log(idx) // console.log(container.slice(0, idx)) // console.log(container.slice(idx)) return [ ...container.slice(0, idx), node, ...container.slice(idx) ]&#125;// 删除某元素方法function remove(node, container)&#123; for (let i = 0; i &lt; container.length; i++) &#123; const n = container[i]; if(node &amp;&amp; n.key === node.key)&#123; container.splice(i, 1) break &#125; &#125; return container&#125;// 求最长上升子序列function lis(arr) &#123; const p = arr.slice() const result = [0] let i let j let u let v let c const len = arr.length for (i = 0; i &lt; len; i++) &#123; const arrI = arr[i] if (arrI !== 0) &#123; j = result[result.length - 1] if (arr[j] &lt; arrI) &#123; p[i] = j result.push(i) continue &#125; u = 0 v = result.length - 1 while (u &lt; v) &#123; c = ((u + v) / 2) | 0 if (arr[result[c]] &lt; arrI) &#123; u = c + 1 &#125; else &#123; v = c &#125; &#125; if (arrI &lt; arr[result[u]]) &#123; if (u &gt; 0) &#123; p[i] = result[u - 1] &#125; result[u] = i &#125; &#125; &#125; u = result.length v = result[u - 1] while (u-- &gt; 0) &#123; result[u] = v v = p[v] &#125; return result&#125; React算法流程 遍历 next 取出 nextNode，位置 i 在 prev 中查找 nextNode.key 一致的节点，如果没找到，则创建后插入到 next[i - 1] 之后 如果找到节点，位置为 j ，更新节点，判断 j 是否小于 lastIdx（lastIdx = 0），如果不小于，则 lastIdx = j 如果小于 lastIdx 则将节点插入到 next[i - 1] 之后 遍历 next 结束后，遍历 prev 如果节点不在 next 中，则删除节点 代码实现12345678910111213141516171819202122232425262728293031323334353637// reactfunction diff1(prev, next)&#123; let container = prev.slice() let nextIndex = &#123;&#125; let prevIndex = &#123;&#125; let prevLength = prev.length let nextLength = next.length let lastIdx = 0 // 生成映射表，方便查找 for(let i = 0; i &lt; prevLength; i++) prevIndex[prev[i].key] = i for(let i = 0; i &lt; nextLength; i++)&#123; // 1. 遍历 next 取出 nextNode，位置 i let nextNode = next[i] nextIndex[nextNode.key] = i // 3. 如果找到节点，位置为 j ，更新节点，判断 j 是否小于 lastIdx（lastIdx = 0），如果不小于，则 lastIdx = j let j = prevIndex[nextNode.key] if(j !== undefined)&#123; patch(prev[j], nextNode) // 4. 如果小于 lastIdx 则将节点插入到 next[i - 1] 之后 if(j &lt; lastIdx)&#123; container = insertBefore(next[i - 1], nextNode, container, 1) &#125;else&#123; lastIdx = j &#125; &#125;else&#123; // 2. 在 prev 中查找 nextNode.key 一致的节点，如果没找到，则创建后插入到 next[i - 1] 之后 container = insertBefore(next[i - 1], nextNode, container, 1) &#125; &#125; // 5. 遍历 next 结束后，遍历 prev 如果节点不在 next 中，则删除节点 for(let p of prev)&#123; if(nextIndex[p.key] === undefined)&#123; remove(p, container) &#125; &#125; return container&#125; 执行流程 第 1 行表示模拟 prev 数组 (一份拷贝)，点状表示移动过的节点，虚线表示更新过的节点 第 2 行表示旧的 prev 数组，绿色表示操作过，红色表示当前遍历的值 第 3 行表示新的 next 数组 按照 react diff 的流程来模拟下步骤 遍历 prev 生成一份 key 与 index 的映射表 prevIndex 遍历 next 数组，i = 0 lastIdx = 0 通过 prevIndex[key] 得出 j = 1 j 大于 lastIdx，lastIdx = j = 1 只执行更新操作不执行移动 i = 1 lastIdx = 1 通过 prevIndex[key] 得出 j = 0 j 小于 lastIdx 所以执行更新操作和移动操作，需要把 a 移动到 next[i - 1].next 也就是 c 节点之前 i = 2 lastIdx = 1 通过 prevIndex[key] 得出 j = 3 j 大于 lastIdx，lastIdx = j = 3 执行更新操作 i = 3 lastIdx = 3 通过 prevIndex[key] 得出 j = 2 j 小于 lastIdx 所以执行更新操作和移动操作，需要把 c 移动到 next[i - 1].next 也就是 f 节点之前 i = 4 lastIdx = 3 通过 prevIndex[key] 找不到对应的节点位置，所以这里需要新增一个节点 e，把 e 移动到 next[i - 1].next 也就是 f 节点之前 遍历完成后，我们需要重新遍历一遍 prev 然后通过 nextIndex 查找得出 f 节点已经不存在于新的节点数组之中，需要执行删除操作移除 f 节点 Vue2算法流程 声明4个变量 prevStart，prevEnd，nextStart，nextEnd 取出 prevStartNode， prevEndNode，nextStartNode，nextEndNode 循环，条件不满足 prevStart &lt;= prevEnd &amp;&amp; nextStart &lt;= nextEnd 跳出循环 prevStartNode 或 prevEndNode 是否存在，不存在则 prevStart++，prevEnd--，回到 2 prevStartNode.key == nextStartNode.key，相等则更新节点，prevStart++ nextStart++，回到2 prevEndNode.key == nextEndNode.key，相等则更新节点，prevEnd-- nextEnd--， 回到2 prevStartNode.key == nextEndNode.key，相等则更新节点， 将 prevStartNode 插入到 prevEndNode.next 之前，prevStart++ nextEnd--，回到 2 prevEndNode.key == nextStartNode.key，相等则更新节点，将 prevEndNode 插入到 prevStartNode 之前，prevEnd-- nextStart++，回到 2 如果全都不相等，查找 prev，看是否存在一个与 nextStartNode.key 相同的节点，有则更新，没有则创建一个新的节点，将其插入到 prevStartNode 之前，nextStart++，prev[j]标记为操作过，回到2 循环结束后 如果 prevEnd &lt; prevStart 证明存在新节点未处理，从 nextStart 开始 插入节点，直到 newEnd，每次节点都插入在 next[newEnd + 1] 之前 如果 nextEnd &lt; newStart 证明存在节点被移除，未处理，从 prevStart 开始 移除节点，直到 prevEnd 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// vue2function diff2(prev, next)&#123; let container = prev.slice() // 1. 声明4个变量 prevStart，prevEnd，nextStart，nextEnd 取出 prevStartNode， prevEndNode，nextStartNode，nextEndNode let prevStart = 0 let nextStart = 0 let prevEnd = prev.length - 1 let nextEnd = next.length - 1 let prevStartNode = prev[prevStart] let prevEndNode = prev[prevEnd] let nextStartNode = next[nextStart] let nextEndNode = next[nextEnd] let prevIndex = &#123;&#125; for(let i = 0; i &lt; prev.length; i++) prevIndex[prev[i].key] = i // 2. 循环，条件不满足 prevStart &lt;= prevEnd &amp;&amp; nextStart &lt;= nextEnd 跳出循环 while(prevStart &lt;= prevEnd &amp;&amp; nextStart &lt;= nextEnd)&#123; // 3. prevStartNode 或 prevEndNode 是否存在，不存在则 prevStart++，prevEnd--，回到 2 if(!prevStartNode)&#123; prevStartNode = prev[++prevStart] &#125;else if(!prevEndNode)&#123; prevEndNode = prev[--prevEnd] &#125;else if(prevStartNode.key === nextStartNode.key)&#123; // 4. prevStartNode.key == nextStartNode.key，相等则更新节点， prevStart++ nextStart++，回到2 patch(prevStartNode, nextStartNode) prevStartNode = prev[++prevStart] nextStartNode = next[++nextStart] &#125;else if(prevEndNode.key === nextEndNode.key)&#123; // 5. prevEndNode.key == nextEndNode.key，相等则更新节点， prevEnd-- nextEnd --， 回到2 patch(prevEndNode, nextEndNode) prevEndNode = prev[--prevEnd] nextEndNode = next[--nextEnd] &#125;else if(prevStartNode.key === nextEndNode.key)&#123; // 6. prevStartNode.key == nextEndNode.key，相等则更新节点， 将 prevStartNode 插入到 prevEndNode.next 之前，prevStart++ nextEnd--，回到 2 patch(prevStartNode, nextEndNode) container = insertBefore(prevEndNode, prevStartNode, container, 1) prevStartNode = prev[++prevStart] nextEndNode = next[--nextEnd] &#125;else if(prevEndNode.key === nextStartNode.key)&#123; // 7. prevEndNode.key == nextStartNode.key，相等则更新节点，将 prevEndNode 插入到 prevStartNode 之前，prevEnd-- nextStart++，回到 2 patch(prevEndNode, nextStartNode) container = insertBefore(prevStartNode, prevEndNode, container) prevEndNode = prev[--prevEnd] nextStartNode = next[++nextStart] &#125;else&#123; // 8. 如果全都不相等，查找 prev，看是否存在一个与 nextStartNode.key相同的节点，有则更新，没有则创建一个新的节点，将其插入到 prevStartNode 之前，nextStart++，prev[j]标记为操作过，回到2 let j = prevIndex[nextStartNode.key] if(j !== undefined)&#123; patch(prev[j], nextStartNode) prev[j] = undefined &#125; container = insertBefore(prevStartNode, nextStartNode, container) nextStartNode = next[++nextStart] &#125; &#125; if(prevEnd &lt; prevStart)&#123; // 9. 循环结束后 如果 prevEnd &lt; prevStart 证明存在新节点未处理，从 nextStart 开始 插入节点，直到newEnd，每次节点都插入在 next[newEnd + 1]之前 let ref = next[nextEnd + 1] || null while(nextStart &lt;= nextEnd)&#123; container = insertBefore(ref, next[nextStart++], container) &#125; &#125;else if(nextEnd &lt; nextStart)&#123; // 10. 如果 nextEnd &lt; newStart 证明存在节点被移除，未处理，从 prevStart 开始 移除节点，直到 prevEnd while(prevStart &lt;= prevEnd)&#123; remove(prev[prevStart++], container) &#125; &#125; return container&#125; 执行流程初始化 prevIndex , 此时 prevStart = 0 , prevEnd = 4, nextStart = 0, nextEnd = 4 通过比较 prevStart 与 nextStart，prevEnd 与 nextEnd，prevStart 与 nextEnd，prevEnd 与 nextStart 得知皆不想等，则通过 prevIndex 获取到 nextStartNode 是可以复用的节点，位置在 j = 1，将 prev[j] 更新后，将其设置为 undefined，并且将 nextStartNode 插入到 prevStartNode 之前，然后 nextStartNode = next[++nextStart] 此时 prevStart = 0 , prevEnd = 4, nextStart = 1, nextEnd = 4 满足 prevStartNode.key === nextStartNode.key 此时直接更新 prevStartNode 然后执行 prevStart++ nextStart++ 此时 prevStartNode 是先前处理过的节点，所以直接跳过 prevStart++ 此时 prevStart = 2 , prevEnd = 4, nextStart = 2, nextEnd = 4 通过比较 prevStart 与 nextStart，prevEnd 与 nextEnd，prevStart 与 nextEnd，prevEnd 与 nextStart 得知皆不想等，则通过 prevIndex 获取到 nextStartNode 是可以复用的节点，位置在 j = 3，将 prev[j] 更新后，将其设置为 undefined，并且将 nextStartNode 插入到 prevStartNode 之前，然后 nextStartNode = next[++nextStart] 此时 prevStart = 2 , prevEnd = 4, nextStart = 3, nextEnd = 4 满足 prevStartNode.key === nextStartNode.key 此时直接更新 prevStartNode 然后执行 prevStart++ nextStart++ 此时 prevStartNode 是先前处理过的节点，所以直接跳过 prevStart++ 此时 prevStart = 4 , prevEnd = 4, nextStart = 4, nextEnd = 4 通过比较 prevStart 与 nextStart，prevEnd 与 nextEnd，prevStart 与 nextEnd，prevEnd 与 nextStart 得知皆不想等，且在 prevIndex 中也没法获取到此节点，证明这个为新增节点，创建节点后插入到 prevNodeStart 之前，执行 nextStartNode = next[++nextStart] 此时 prevStart = 4 , prevEnd = 4, nextStart = 5, nextEnd = 4，此时已经不满足循环条件了，所以直接跳出 由判断 prevStart &gt; prevEnd 不成立，但 nextStart &gt; nextEnd 成立，所以存在节点是未删除的，循环删除掉多余的节点，条件为 prevStart &lt;= prevEnd 最后得到 在看一组巩固 此时 prevStart = 0 , prevEnd = 3, nextStart = 0, nextEnd = 4 通过比较，得知 prevStartNode 与 nextStartNode 相等，更新后移动指针位置 通过比较，得知 prevEndNode 与 nextEndNode 相等，更新节点，然后把节点移动到 prevStartNode 之前 此时 prevStart = 1 , prevEnd = 2, nextStart = 2, nextEnd = 4 我们发现 prevEndNode 跟 nextStartNode 是相等的，更新节点后移动指针 此时 prevStart = 1 , prevEnd = 1, nextStart = 2, nextEnd = 3 我们发现 prevStartNode 跟 nextStartNode 是相等的，更新节点后移动指针 此时 prevStart = 2 , prevEnd = 1, nextStart = 3, nextEnd = 3 已经不符合循环条件，跳出循环，此时满足 prevEnd &lt; prevStart，证明还有新增节点，循环将新节点插入在 next[nextEnd + 1] 之前 Vue3算法流程 j 表示当前匹配到第几个位置，初始值为0 从 j 开始匹配相同的元素，如果 prev[j].key == next[j].key，更新后 j++ 如果 j &gt; prevEnd || j &gt; nextEnd 提前跳出 匹配完前面的相同元素后 j 停在第一个不同点 从 prevEnd 和 nextEnd 开始从后面查找相同的后缀，更新后 prevEnd-- nextEnd-- 如果 j &gt; prevEnd || j &gt; nextEnd 提前跳出 此时已经更新完相同的前缀和后缀，需要看 j 处于什么位置 如果 j &gt; prevEnd &amp;&amp; j &lt;= nextEnd ，则 next 在 [j , nextEnd] 新增元素，直接在 next[nextEnd + 1] 前插入新增元素 如果 j &gt; nextEnd &amp;&amp; j &lt;= prevEnd ，则 prev 在 [j , prevEnd] 中元素被删除，直接删除多余元素 如果都不是上两种情况，则说明在 [j , prevEnd] 段存在乱序的节点，长度为 nextLeft = nextEnd - j + 1 初始化一个辅助数组 source 长度为 nextLeft 默认值为 -1，patched = 0，move = false，pos = 0 遍历 next, 从 j 到 nextEnd，生成一个 key - i 的映射表 keyIndex 遍历 prev ,从 j 到 prevEnd 如果 patched 大于 nextLeft，则说明相同元素从 prev 中取完，后面均为待删除的元素，直接删除 k = keyIndex[prev[i]]，如果 k 不存在，证明该节点不存在于 next，直接删除 next[k].key == prev[i].key，则更新该节点，patched++，source[k - j] = i，如果 k &lt; pos，则 prev[i] 是需要移动的 move = true，否则 pos = k 处理完成后判断 move 是否为真 如果不为真，i = nextLeft - 1 倒序遍历，如果 source[i] == -1 时，pos = j + i，在 next[pos + 1] 前增加节点 next[pos] 如果为真，则在这段范围内发生乱序 &#x2F; 新增的情况 求出最长上升子序列 seq = lis(source) k = seq.length - 1 i = nextLeft - 1 倒序遍历，如果 source[i] == -1 时，pos = j + i，在 next[pos + 1] 前增加节点 next[pos] 如果 i == seq[j]，则需要移动此节点，pos = j + i，在 next[pos + 1] 前插入节点 next[pos] 其他情况，k-- 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// vue3function diff3(prev, next)&#123; let container = prev.slice() // 1. j 表示当前匹配到第几个位置，初始值为0 let j = 0 let prevEnd = prev.length - 1 let nextEnd = next.length - 1 let prevNode = prev[j] let nextNode = next[j] // 2. 从 j 开始匹配相同的元素，如果 prev[j].key == next[j].key，更新后 j++ 如果 j &gt; prevEnd || j &gt; nextEnd 提前跳出 while(prevNode &amp;&amp; nextNode &amp;&amp; prevNode.key === nextNode.key)&#123; patch(prevNode, nextNode) j++ if(j &gt; prevEnd || j &gt; nextEnd) break prevNode = prev[j] nextNode = next[j] &#125; // 3. 匹配完前面的相同元素后 j 停在第一个不同点 prevNode = prev[prevEnd] nextNode = next[nextEnd] // 4. 从 prevEnd 和 nextEnd 开始从后面查找相同的后缀，更新后 prevEnd-- nextEnd-- 如果 j &gt; prevEnd || j &gt; nextEnd提前跳出 while(prevNode &amp;&amp; nextNode &amp;&amp; prevNode.key === nextNode.key)&#123; patch(prevNode, nextNode) prevEnd-- nextEnd-- if(j &gt; prevEnd || j &gt; nextEnd) break prevNode = prev[prevEnd] nextNode = next[nextEnd] &#125; // 5. 此时已经更新完相同的前缀和后缀，需要看 j 处于什么位置 if(j &gt; prevEnd &amp;&amp; j &lt;= nextEnd)&#123; // 6. 如果 j &gt; prevEnd &amp;&amp; j &lt;= nextEnd ，则 next 在[ j , nextEnd] 新增元素，直接在next[nextEnd + 1] 前插入新增元素 let ref = next[nextEnd + 1] || null while(j &lt;= nextEnd)&#123; container = insertBefore(ref, next[j++], container) &#125; &#125;else if(j &gt; nextEnd &amp;&amp; j &lt;= prevEnd)&#123; // 7. 如果 j &gt; nextEnd &amp;&amp; j &lt;= prevEnd ，则 prev 在 [j , prevEnd] 中元素被删除，直接删除多余元素 while(j &lt;= prevEnd)&#123; remove(prev[j++], container) &#125; &#125;else if(j &lt;= nextEnd)&#123; // 8. 如果都不是上两种情况，则说明在 [j , prevEnd] 段存在乱序的节点，长度为 nextLeft = nextEnd - j + 1 let nextLeft = nextEnd - j + 1 // 9. 初始化一个辅助数组 source 长度为 nextLeft 默认值为 -1，patched = 0，move = false， pos = 0 let source = new Array(nextLeft).fill(-1) let pos = 0 let patched = 0 let move = false let keyIndex = &#123;&#125; // 10. 遍历 next, 从 j 到 nextEnd，生成一个 key - i 的映射表 keyIndex for(let i = j; i &lt;= nextEnd; i++) keyIndex[next[i].key] = i // 11. 遍历 prev ,从 j 到 prevEnd for (let i = j; i &lt;= prevEnd; i++) &#123; let prevNode = prev[i] // 12. 如果 patched 大于 nextLeft，则说明相同元素从 prev 中取完，后面均为待删除的元素，直接删除 if(patched &lt; nextLeft)&#123; let k = keyIndex[prevNode.key] // 13. k = keyIndex[prev[i]]，如果 k 不存在，证明该节点不存在于 next，直接删除 if(k !== undefined)&#123; // 14. next[k].key == prev[i].key，则更新该节点，patched++，source[k - j] = i，如果 k &lt; pos，则prev[i] 是需要移动的 move = true，否则 pos = k patch(prevNode, next[k]) source[k - j] = i patched++ if(k &lt; pos)&#123; move = true &#125;else&#123; pos = k &#125; &#125;else&#123; remove(prevNode, container) &#125; &#125;else&#123; remove(prevNode, container) &#125; &#125; // 15. 处理完成后判断 move 是否为真 if(move)&#123; // 17. 如果为真，则在这段范围内发生乱序 / 新增的情况 // 18. 求出最长上升子序列 seq = lis(source) j = seq.length - 1 let seq = lis(source) let k = seq.length - 1 for(let i = nextLeft - 1; i &gt;= 0; i--)&#123; if(source[i] === -1 || i !== seq[k])&#123; // 19. i = nextLeft - 1 倒序遍历，如果 source[i] == -1 时，pos = j + i，在 next[pos + 1]前增加节点next[pos] // 20. 如果 i == seq[j]，则需要移动此节点，pos = j + i，将 prev 中的 next[pos]插入到 prev 中的 next[pos + 1] 之前 let pos = j + i container = insertBefore(next[pos + 1] || null, next[pos], container) &#125;else&#123; // 21. 其他情况，j-- k-- &#125; &#125; &#125;else&#123; // 16. 如果不为真，i = nextLeft - 1 倒序遍历，如果 source[i] == -1 时，pos = j + i，在 next[pos + 1]前增加节点 next[pos] for(let i = nextLeft - 1; i &gt;= 0; i--)&#123; if(source[i] === -1)&#123; let pos = j + i container = insertBefore(next[pos + 1] || null, next[pos], container) &#125; &#125; &#125; &#125; return container&#125; 执行流程首先比较前缀节点 j = 0 prevEnd = 3 nextEnd = 4 prevNode = prev[j] nextNode = next[j] 满足循环条件，执行到第一个不同点，即 j = 1 prevNode = prev[j] nextNode = next[j] 开始比对后缀节点，另 prevNode = prev[prevEnd] nextNode = next[nextEnd]，如果满足循环条件则开始循环 更新后缀节点直到不满足循环条件 此时 j = 1 prevEnd = 2 nextEnd = 3，条件 j &gt; prevEnd &amp;&amp; j &lt;= nextEnd 与 j &gt; nextEnd &amp;&amp; j &lt;= prevEnd 没有被满足，j &lt;= nextEnd 满足，证明 [j, nextEnd] 区间存在乱序或新增的情况 我们计算 nextLeft = nextEnd - j + 1 = 3 得出乱序区间大小为 3，source = [-1, -1, -1]，从 j 到 nextEnd 遍历 next 数组，得到 keyIndex，然后从 j 到 prevEnd 遍历 prev 数组 初始化 pos = 0 patched = 0 move = false 当 i = j = 1，pos = 0``patched = 0``nextLeft = 3 且 patched &lt; nextLeft 则查找 keyIndex 看 next 中是否存在节点下标 k = 2，如果找到，更新节点，patched++， 令 source[k - j] = i 则 source = [-1, 1, -1]，判断 k &lt; pos，如果小于则是需要移动，move = true， 这里明显不成立，所以令 pos = k = 2 当 i = 2，pos = 2``patched = 1，查找 keyIndex 得到 k = 1，更新节点，patched++ 令 source[k - j] = i 则 source = [2, 1, -1]，因为 k &lt; pos 所以这个节点是需要移动的，所以 move = true 因为需要移动所以需要通过lis(最长上升子序列)来确定最少移动的次数，seq = lis(source) = [2], k = seq.length - 1 = 1 然后我们从nextLeft - 1往前遍历，直到 0 i = 2时，通过 source[i] = -1，-1 表明此节点我们未曾处理过，必然是一个新增的节点，所以我们需要新增这个节点到数组中，由于我们上面得出的 source 是一个相对坐标，逆推可以得到当前节点在 next 中的坐标为 pos = j + i = 3 则它需要插入在 next[pos + 1] 节点的前方 i = 1时，由于 source[i] != -1，则我们接着判断 i !== seq[k]，由于不相等，这个节点是一个需要移动的节点，则我们将此节点移动到 next[pos + 1] 之前。 i = 0是，判断都不成立，所以 k--，接着就循环结束了，完成匹配 再来一遍执行流程加强下理解 这里直接跳过了前缀跟后缀的处理流程，也没啥好说的，此时 j = 0 prevEnd = 5 nextEnd = 5，条件 j &gt; prevEnd &amp;&amp; j &lt;= nextEnd 与 j &gt; nextEnd &amp;&amp; j &lt;= prevEnd 没有被满足，j &lt;= nextEnd 满足，证明 [j, nextEnd] = [0, 5] 区间存在乱序或新增的情况 根据上面的流程，我们求出 keyIndex, nextLeft = nextEnd - j + 1 = 5, source = [-1, -1, -1, -1, -1]，从 j 遍历到 prevEnd 当 i = j = 0， patched = 0, pos = 0, move = false，通过 keyIndex 可查找出 a 节点位于 next 中下标为 1 的位置，更新后，记录位置更新变量，patched++, pos = 1, move = false, source[k - j] = source[1] = 0 当 i = 1，patched = 1, pos = 1, move = false，通过 keyIndex 查找出 k = 0 由于 k &lt; pos 所以节点 b 是需要移动的，更新后，记录位置，更新变量，patched++, pos = 1, move = true, source[k - j] = source[0] = 1 当 i = 2，patched = 2, pos = 1, move = true，通过 keyIndex 查找出 k = 2 由于 k &gt; pos 所以 pos = k = 2，更新后，记录位置，更新变量，patched++, pos = 2, source[k - j] = source[2] = 2 当 i = 3，patched = 3, pos = 2，通过 keyIndex 查找出 k = 5 由于 k &gt; pos 所以 pos = k = 5，更新后，记录位置，更新变量，patched++, pos = 5, source[k - j] = source[5] = 3 当 i = 4，patched = 4, pos = 5，通过 keyIndex 查找出 k = 4 由于 k &lt; pos 所以 pos = 5，更新后，记录位置，更新变量，patched++, pos = 5, source[k - j] = source[4] = 4 当 i = 5，patched = 5, pos = 5，通过 keyIndex 查找出 k = 3 由于 k &lt; pos 所以 pos = 5，更新后，记录位置，更新变量，patched++, pos = 5, source[k - j] = source[3] = 5 遍历结束，此时 source = [ 1, 0, 2, 5, 4, 3 ], move = true 通过 seq = lis(source) = [0, 2, 5], k = seq.length - 1 = 3 从 nextLeft - 1 开始遍历 当 i = 5，source[5] !== -1 但 i === seq[k] 所以不做处理，k-- 当 i = 4，source[4] !== -1 由于 i !== seq[k] 所以要移动该节点，pos = j + i = 4 next[pos] 需要插入在 next[pos + 1] 之前 当 i = 3，source[4] !== -1 由于 i !== seq[k] 所以要移动该节点，pos = j + i = 3 next[pos] 需要插入在 next[pos + 1] 之前 当 i = 2，source[5] !== -1 但 i === seq[k] 所以不做处理，k-- 当 i = 1，source[4] !== -1 由于 i !== seq[k] 所以要移动该节点，pos = j + i = 1 next[pos] 需要插入在 next[pos + 1] 之前 当 i = 0，source[5] !== -1 但 i === seq[k] 所以不做处理，k-- 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const check = (diff) =&gt; &#123; var count = 100 var changeCount = 100 for(let i = 0; i &lt; count; i++)&#123; var random = 0 + Math.floor(10 * Math.random()) var prev = new Array(random).fill(0).map((item, index) =&gt; &#123; return &#123; key: &#x27;key-&#x27; + index, val: index &#125; &#125;) for(let j = 0; j &lt; changeCount; j++)&#123; var ran = random + (Math.floor(5 * Math.random()) * ( Math.random() &gt; 0.5 ? 1 : -1)) ran = ran &gt; 0 ? ran : 0 var next = new Array(ran).fill(0).map((item, index) =&gt; &#123; return &#123; key: &#x27;key-&#x27; + index, val: index * random &#125; &#125;) shuff(next) var res = diff(prev, next) if(!eq(res, next))&#123; console.log(prev, next) &#125; prev = res &#125; &#125;&#125;;function shuff(arr)&#123; let len = arr.length - 1 for(let i = 0; i &lt; len; i++)&#123; let rand = i + Math.floor((len - i) * Math.random()) swap(arr, rand, i) &#125;&#125;function swap(arr, i, j)&#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125;console.log(&#x27;random test&#x27;)console.time(&#x27;diff1&#x27;)check(diff1)console.timeEnd(&#x27;diff1&#x27;)console.time(&#x27;diff2&#x27;)check(diff2)console.timeEnd(&#x27;diff2&#x27;)console.time(&#x27;diff3&#x27;)check(diff3)console.timeEnd(&#x27;diff3&#x27;)let size = 5000let next = new Array(size).fill(0).map((item, index) =&gt; &#123; return &#123; key: &#x27;key-&#x27; + index, val: index &#125;&#125;)let prev = JSON.stringify(next)shuff(next)next = JSON.stringify(next)console.log(&#x27;test&#x27;)console.time(&#x27;diff1&#x27;)eq(diff1(JSON.parse(prev), JSON.parse(next)), next)console.timeEnd(&#x27;diff1&#x27;)console.time(&#x27;diff2&#x27;)eq(diff2(JSON.parse(prev), JSON.parse(next)), next)console.timeEnd(&#x27;diff2&#x27;)console.time(&#x27;diff3&#x27;)eq(diff3(JSON.parse(prev), JSON.parse(next)), next)console.timeEnd(&#x27;diff3&#x27;) 执行结果","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"},{"name":"React","slug":"React","permalink":"https://luoyuda.github.io/tags/React/"}]},{"title":"Promise/A+ 规范与 Promise 实现代码","slug":"JavaScript/promise","date":"2021-05-29T13:23:00.000Z","updated":"2021-05-29T13:23:00.000Z","comments":true,"path":"2021/05/29/JavaScript/promise/","link":"","permalink":"https://luoyuda.github.io/2021/05/29/JavaScript/promise/","excerpt":"","text":"Promisepromise 表示一个异步操作的最终结果。和一个 promise 进行交互的主要方式是通过它的 then 方法，该方法注册回调要么接收一个 promise 的最终值，要么接收 promise 为什么不能被满足的原因。 规范Promise A+ 规范 术语 promise 是一个带有 then 方法的对象或函数，其行为符合此规范。 thenable 是一个定义了 then 方法的对象或函数。 value 是任何合法的 JavaScript 值(包括undefined、thenable或promise)。 exception 是使用 throw 语句抛出的值。 reason 是一个值，它指示为什么一个承诺被拒绝。 要求 promise状态 pending：等待状态 当处于等待状态时可以转化成 fulfilled &#x2F; rejected fulfilled：完成状态 一定不能转换成其他状态 必须有一个不能转换的值(value) rejected：拒绝状态 一定不能转换成其他状态 必须又一个不能转换的原因(reason) then 方法：一个 promise 必须提供一个 then 方法来访问它的当前或最终值(value)或原因(reason)，then 方法接收两个参数 promise.then(onFulfilled, onRejected) onFulfilled 和 onRejected 都是可选的参数 如果 onFulfilled 不是个函数，必须被忽略 如果 onRejected 不是个函数，必须被忽略 如果 onFulfilled 是一个函数 必须在 promise 完成(resolve)后被调用，promise 的值(value)作为它第一个参数 一定不能在 promise 完成(resolve)前被调用 一定不能被调用多次 如果 onRejected 是一个函数 必须在 promise 拒绝(reject)后被调用，promise 的值(reason)作为它第一个参数 一定不能在 promise 拒绝(reject)前被调用 一定不能被调用多次 在执行上下文堆栈只包含平台代码[3.1]之前，不能调用 onfulfilled 或 onRejected onFulfilled 和 onRejected 必须作为函数调用(没有 this 值)[3.2] 同一个 promise 上的 then 可能被多次调用 如果 promise 被完成(resolve)，所有相应的 onFulfilled 需要按照 then 的顺序被顺序执行 如果 promise 被拒绝(reject)，所有相应的 onRejected 需要按照 then 的顺序被顺序执行 then 必须返回一个 promise 实例 [3.3] promise2 = promise1.then(onFulfilled, onRejected) 如果 onFulfilled 和 onRejected 返回一个值 x，运行 [[Resolve]](promise2, x) 如果 onFulfilled 和 onRejected 抛出一个异常 e ，promise2 必须要用 e 作为理由拒绝 如果 onFulfilled 不是一个函数并且 promise1 被完成(resolve)，promise2 需要返回跟 promise1 同样的值 (value) 如果 onRejected 不是一个函数并且 promise1 被拒绝(reject)，promise2 需要返回跟 promise1 同样的值 (reason) promise 解决程序（[[Resolve]]）[[Resolve]] 是一个抽象的概念，它一个 promise 和 x 作为输入 [[Resolve]](promise, x)，如果 x 是一个 thenable，它试图让承诺采用 x 的状态，假设 x 至少表现得有点像一个promise。否则，它将使用值x来实现 promise，这种 thenable 的处理允许 promise 的实现更具有通用型，只要它们暴露一个遵守 Promise/A+ 的 then 方法即可。它还允许遵守Promise/A+规范的实现可以与那些不太规范但是可用的实现进行共存，运行[[Resolve]](promise, x)，执行以下步骤 如果 promise 和 x 指向同一个对象，则以 TypeError 作为原因拒绝 promise 如果 x 是一个 promise 则采取它的状态 [3.4] 如果 x 状态是 pending，则 promise 必须持续 pending，直到 x 被完成或拒绝。 如果 x 状态是 resolve，则用相同的值(value)解决 promise 如果 x 状态是 reject，则用相同的原因(reason)拒绝 promise 如果 x 是一个函数或者对象 使 then 的值为 x.then [3.5] 如果获取 x.then 的值抛出异常 e， 则将 e 作为原因拒绝 promise 如果 then 是一个函数，用 x 作为 this 调用它，第一个参数resolvePromise ，第二个参数 rejectPromise ，其中 如果当 resolvePromise 的值为 y 时，运行 [[Resolve]](promise, y) 如果 rejectPromise 用一个原因 r 调用，用 r 拒绝 promise 如果同时调用了 resolvePromise 和 rejectPromise ，或者多次调用相同的参数，那么第一次调用优先，后续的调用将被忽略。(针对 thenable ) 如果调用 then 抛出一个异常 e 如果 resolvePromise 或 rejectPromise 已经被调用，忽略它。 否则用 e 作为原因拒绝 promise 如果 then 不是一个函数，用 x 完成(resolve) promise 如果 x 不是一个对象或函数，用 x 完成(resolve) promise 如果一个 promise 被 thenable 解析，并参与一个循环的 thenable 链，这样 [[Resolve]](promise, thenable) 的递归性质最终导致 [[Resolve]](promise, thenable) 再次被调用，按照上述算法将导致无限递归。我们鼓励(但不是必需)实现检测这种递归，并以 TypeError 作为原因拒绝承诺。[3.6] 注解 这里 平台代码 使引擎、环境以及promise的实现代码。在实践中，这需要确保 onFulfilled 和 onRejected 异步地执行，并且应该在 then 方法被调用的那一轮事件循环之后用新的执行栈执行。这可以用如 setTimeout 或 setImmediate 这样的“宏任务”机制实现，或者用如 MutationObserver 或 process.nextTick 这样的“微任务”机制实现。由于 promise 的实现被考虑为 平台代码 ，因此在自身处理程序被调用时可能已经包含一个任务调度队列 严格模式下，它们中的this将会是undefined；在非严格模式，this将会是全局对象 假如实现满足所有需求，可以允许 promise2 === promise1 。每一个实现都应该记录是否能够产生 promise2 === promise1 以及什么情况下会出现 promise2 === promise1 通常，只有 x 来自于当前实现，才知道它是一个真正的 promise 。这条规则允许那些特例实现采用符合已知要求的 Promise 的状态 这个程序首先存储 x.then 的引用，之后测试那个引用，然后再调用那个引用，这样避免了多次访问 x.then 属性。此类预防措施对于确保访问者属性的一致性非常重要，因为访问者属性的值可能在俩次检索之间发生变化 实现不应该在 thenable 链的深度上做任意限制，并且假设超过那个任意限制将会无限递归。只有真正的循环才应该引发一个 TypeError ；如果遇到一个无限循环的 thenable，永远执行递归是正确的行为 大纲图 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// ES6// 三种状态const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123; // 状态: 初始状态为 pending status = PENDING // 值 value = null // 原因 reason = null // 执行 onFulfilled 的队列 onFulfilledCallbacks = [] // 执行 onRejected 的队列 onRejectedCallbacks = [] // 构造方法 constructor(executor)&#123; try &#123; executor(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125; &#125; resolve = value =&gt; &#123; // 判断是否状态处于等待状态 if(this.status === PENDING)&#123; // 改变状态 this.status = FULFILLED // 赋值 this.value = value // 循环调用 while(this.onFulfilledCallbacks.length)&#123; this.onFulfilledCallbacks.shift()(this.value) &#125; &#125; &#125; reject = reason =&gt; &#123; // 判断是否状态处于等待状态 if(this.status === PENDING)&#123; // 更改状态 this.status = REJECTED // 赋值原因 this.reason = reason // 循环调用 while(this.onRejectedCallbacks.length)&#123; this.onRejectedCallbacks.shift()(this.reason) &#125; &#125; &#125; then(onFulfilled, onRejected)&#123; // 可选参数 const realOnFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value const realOnRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; const promise1 = new MyPromise((resolve, reject) =&gt; &#123; // 创建一个微任务执行完成的函数 const fulfilledMicrotask = () =&gt; &#123; queueMicrotask(() =&gt; &#123; try&#123; let x = realOnFulfilled(this.value) resolvePromise(promise1, x, resolve, reject) &#125;catch (error) &#123; reject(error) &#125; &#125;) &#125; // 创建一个微任务执行拒绝的函数 const rejectMicrotask = () =&gt; &#123; queueMicrotask(() =&gt; &#123; try&#123; let x = realOnRejected(this.reason) resolvePromise(promise1, x, resolve, reject) &#125;catch (error) &#123; reject(error) &#125; &#125;) &#125; // 状态确定后直接执行 if(this.status == FULFILLED)&#123; fulfilledMicrotask() &#125;else if(this.status == REJECTED)&#123; rejectMicrotask() &#125;else&#123; // 异步，加入队列 this.onFulfilledCallbacks.push(fulfilledMicrotask) this.onRejectedCallbacks.push(rejectMicrotask) &#125; &#125;) // then 返回一个新的 promise return promise1 &#125; // catch 方法 catch (onRejected) &#123; this.then(null, onRejected) &#125;&#125;function resolvePromise(promise, x, resolve, reject)&#123; if(x === promise)&#123; // 循环调用，直接报错 return reject(new TypeError(&#x27;The promise and the return value are the same&#x27;)); &#125; if(typeof x === &#x27;function&#x27; || typeof x === &#x27;object&#x27;)&#123; // null 直接返回 if(x === null) return resolve(x) let then try &#123; then = x.then &#125; catch (error) &#123; // 不存在直接拒绝 return reject(error) &#125; // 如果对象上面存在 then 方法 if(typeof then === &#x27;function&#x27;)&#123; let called = false try &#123; then.call(x, y =&gt; &#123; // 执行多次忽略 if(called) return called = true // 接着执行 resolvePromise(promise, y, resolve, reject) &#125;, r =&gt; &#123; // 执行多次忽略 if(called) return called = true reject(r) &#125;) &#125; catch (error) &#123; // if(called) return called = true reject(error) &#125; &#125;else&#123; // then 不是函数 resolve(x) &#125; &#125;else&#123; // 如果 x 不为对象或者函数，直接用 x 为参数执行 promise resolve(x) &#125;&#125;// 测试用MyPromise.deferred = function()&#123; var result = &#123;&#125; result.promise = new MyPromise(function(resolve, reject)&#123; result.resolve = resolve result.reject = reject &#125;) return result&#125;module.exports = MyPromise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// ES5var PENDING = &#x27;pending&#x27;;var REJECTED = &#x27;rejected&#x27;;var FULFILLED = &#x27;fulfilled&#x27;;function MyPromise(executor)&#123; this.status = PENDING this.value = null; this.reason = null; this.onFulfilled = [] this.onRejected = [] this.resolve = this.resolve.bind(this) this.reject = this.reject.bind(this) try &#123; executor(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125;&#125;MyPromise.prototype.resolve = function(value)&#123; if(this.status === PENDING)&#123; this.status = FULFILLED this.value = value while(this.onFulfilled.length)&#123; this.onFulfilled.shift()(this.value) &#125; &#125;&#125;MyPromise.prototype.reject = function(reason)&#123; if(this.status === PENDING)&#123; this.status = REJECTED this.reason = reason while(this.onRejected.length)&#123; this.onRejected.shift()(this.reason) &#125; &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected)&#123; var that = this onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : function(value)&#123; return value &#125; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function(reason)&#123; throw reason &#125; var promise1 = new MyPromise(function(resolve, reject)&#123; var fulfilled = function()&#123; // 没有 queueMicrotask 可以用 setTimeout queueMicrotask(function()&#123; try &#123; var x = onFulfilled(that.value) resolvePromise(promise1, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; var rejected = function()&#123; queueMicrotask(function()&#123; try &#123; var x = onRejected(that.reason) resolvePromise(promise1, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if(that.status === FULFILLED)&#123; fulfilled() &#125;else if(that.status === REJECTED)&#123; rejected() &#125;else&#123; that.onFulfilled.push(fulfilled) that.onRejected.push(rejected) &#125; &#125;) return promise1&#125;MyPromise.prototype.catch = function(onRejected)&#123; this.then(null, onRejected)&#125; 执行流程 参考文章从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://luoyuda.github.io/tags/Promise/"}]},{"title":"基于 webpack 打包js,css脚手架","slug":"webpack/webpack-01","date":"2020-09-02T16:00:00.000Z","updated":"2020-09-02T16:00:00.000Z","comments":true,"path":"2020/09/02/webpack/webpack-01/","link":"","permalink":"https://luoyuda.github.io/2020/09/02/webpack/webpack-01/","excerpt":"","text":"首先理清脚手架需要帮我们优化哪些步骤，通过对xxx项目分析，得出脚手架需要帮助我们处理好以下问题 js的打包，es6语法支持，模块引用问题，按需引入问题，提高业务开发效率和兼容性问题 sass文件的打包 自动化编译 区分js css的打包配置，各司其职 安装模块1234567891011# babelnpm i -D @babel/core @babel/cli core-js@3 @babel/preset-env # sassnpm i -D mini-css-extract-plugin sass node-sass autoprefixer # webpacknpm i -D webpack webpack-cli webpack-dev-server css-loader sass-loader babel-loader postcss-loader # shellnpm i -D/-g shelljs chalk onchange cross-env 配置文件build 文件夹存放 webpack 配置 1234build├── common.js├── webpack.prod.css.js└── webpack.prod.es.js 公共方法 common.js 123456789101112131415161718192021222324252627282930313233// 文件处理模块const fs = require(&#x27;fs&#x27;)// 检查当前改变文件是否匹配我们的目标文件const checkFile = (file, &#123; reg, dirReg, repDir &#125;, getConf, path) =&gt; &#123; if(file.match(dirReg) &amp;&amp; file.match(reg))&#123; // 匹配则往 path 数组中新增 let key = file.replace(reg, &#x27;&#x27;).replace(repDir, &#x27;&#x27;) const conf = getConf(key, file) console.log(`======== 打包 $&#123;key&#125; $&#123;file&#125; ========`) path.push(conf) &#125;&#125;// 递归获取目标文件夹内容const getFiles = (path, callback) =&gt; &#123; const files = fs.readdirSync(path) files.map(file =&gt; &#123; if(!callback(`$&#123;path&#125;/$&#123;file&#125;`, path))&#123; let exists = true let newPath = `$&#123;path&#125;/$&#123;file&#125;` try &#123; fs.readdirSync(newPath) &#125; catch (error) &#123; exists = false &#125; if(exists) getFiles(newPath, callback) &#125; &#125;)&#125;// 暴露方法module.exports = &#123; checkFile, getFiles&#125; js配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 路径模块const path = require(&#x27;path&#x27;)// 引入公共方法const &#123; checkFile, getFiles &#125; = require(&#x27;./common.js&#x27;)// webpack SourceMap 插件const SourceMapDevToolPlugin = require(&#x27;webpack&#x27;).SourceMapDevToolPlugin// 传入需要修改的文件名const needChange = process.env.change || &#x27;&#x27;// 需要修改的 js 文件列表const jsPath = []// 处理的文件夹名const dirName = &#x27;wp-js&#x27;// 匹配正则const jsReg = /\\.js$/// 文件夹名const dir = `./$&#123;dirName&#125;`// 需要替换的文件夹名const repDir = `./$&#123;dirName&#125;/`// 文件夹正则const dirReg = new RegExp(dirName,&#x27;ig&#x27;)// 配置const options = &#123; dir, reg: jsReg, dirName, repDir, dirReg&#125;// 批量生成webpack配置/* webpack 开启 Tree Shaking 特性 单页面打包时可直接输出一个对象，多页面打包时需要用数组来输出一个配置给webpack 1. mode: &quot;production&quot; 2. 单页面时不需要额外配置，多页面需要整理成数组配置项告知webpack*/const getConf = (key, file) =&gt; &#123; return &#123; mode: &quot;production&quot;, //模式配置 entry:&#123; [key]: file &#125;, //多文件入口 output:&#123; filename: &#x27;[name].js&#x27;, // 打包后文件名 path: path.resolve(&#x27;js&#x27;) // 打包后目录，需为绝对路径 &#125;, module:&#123; rules:[ &#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, // include: dirReg, // 只转化src目录下的js exclude: /node_modules/ // 排除掉node_modules，优化打包速度 &#125; ] &#125;, //处理对应模块 plugins: [ new SourceMapDevToolPlugin(&#123; filename: &#x27;.map/[file].map&#x27;, &#125;) ] &#125;&#125;if(needChange === &#x27;all&#x27;) &#123; // 如果 all 则批量打包所有js getFiles(options.dir, (file) =&gt; &#123; checkFile(file, options, getConf, jsPath) &#125;)&#125;else&#123; // 指定文件则打包目标js checkFile(`./$&#123;needChange&#125;`,options, getConf, jsPath)&#125; module.exports = jsPath.length ? jsPath : &#123;&#125; 处理scss文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// webpack.config.js// 路径模块const path = require(&#x27;path&#x27;)// 引入公共方法const &#123; checkFile, getFiles &#125; = require(&#x27;./common.js&#x27;)// webpack SourceMapconst SourceMapDevToolPlugin = require(&#x27;webpack&#x27;).SourceMapDevToolPlugin// webpack 输出 css 文件插件const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)// 需变更的文件const needChange = process.env.change || &#x27;&#x27;// 文件夹const dirName = &#x27;wp-css&#x27;// 需匹配文件后缀const scssReg = /\\.scss$/// 文件名const dir = `./$&#123;dirName&#125;`// 替换文件名const repDir = `./$&#123;dirName&#125;/`const dirReg = new RegExp(dirName,&#x27;ig&#x27;)// 配置const options = &#123; dir, reg: scssReg, dirName, repDir, dirReg&#125;// loader 配置const sassLoaders = [ MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;,//需要插在css-loader之前 &#x27;sass-loader&#x27;]// 文件修改路径数组const scssPath = []// 获取配置const getConf = (key, file) =&gt; &#123; return &#123; mode: &quot;production&quot;, //模式配置 entry:&#123; [key]: file &#125;, //多文件入口 output:&#123; filename: &#x27;.empty.index.js&#x27;, // 打包后文件名 path: path.resolve(&#x27;css&#x27;) // 打包后目录，需为绝对路径 &#125;, module:&#123; rules:[ &#123; test: /\\.scss$/, //匹配查找 scss 文件 use: sassLoaders &#125; ] &#125;, //处理对应模块 plugins: [ new SourceMapDevToolPlugin(&#123; filename: &#x27;.map/[file].map&#x27;, &#125;), new MiniCssExtractPlugin(&#123; filename: `/[name].css` &#125;) ] &#125;&#125;if(needChange === &#x27;all&#x27;) &#123; // 打包所有 scss 文件 getFiles(options.dir, (file) =&gt; &#123; checkFile(file, options, getConf, scssPath) &#125;)&#125;else&#123; // 打包目标 scss 文件 checkFile(`./$&#123;needChange&#125;`,options, getConf, scssPath)&#125; module.exports = scssPath.length ? scssPath : &#123;&#125; 从开发文件夹 wp-js 输出到 js 文件夹，wp-css 输出到 css 文件夹，通过 onchange 模块对项目进行监听，做自动化打包，创建一个 change.js 来作为变动后的脚本，判断是否执行打包操作 1234567891011121314const &#123; rm, cp, mkdir, exec, echo, env &#125; = require(&#x27;shelljs&#x27;)const chalk = require(&#x27;chalk&#x27;)// 获取变更文件夹let change = process.env.change || &#x27;&#x27; console.log(chalk.green(&#x27;==== 执行change脚本 ====&#x27;))console.log(chalk.red(`==== 变更$&#123;change&#125; ====`))// 判断是否在文件夹内的变动if(change.match(&#x27;wp-js&#x27;))&#123; exec(`cross-env change=$&#123;change&#125; npm run build:js -s`)&#125;else if(change.match(&#x27;wp-css&#x27;))&#123; exec(`cross-env change=$&#123;change&#125; npm run build:css -s`)&#125;console.log(chalk.green(&#x27;==== 打包结束 ====&#x27;)) babel 配置 12345678910&#123; &quot;presets&quot;:[ [&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false, &#125;], ], &quot;plugins&quot;: [ [&quot;@babel/plugin-proposal-object-rest-spread&quot;, &#123; &quot;loose&quot;: true &#125;], ]&#125; postcss 配置 12345module.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;)(&#123;&#125;) ]&#125; 配置可执行命令，package.json 中的 scripts 12345678910111213&#123;&quot;scripts&quot;: &#123; &quot;build:js&quot;: &quot;webpack --config build/webpack.prod.es.js&quot;, &quot;build:all:js&quot;: &quot;cross-env change=&#x27;all&#x27; npm run build:js&quot;, &quot;build:css&quot;: &quot;webpack --config build/webpack.prod.css.js&quot;, &quot;build:all:css&quot;: &quot;cross-env change=&#x27;all&#x27; npm run build:css&quot;, &quot;build:all&quot;: &quot;cross-env change=&#x27;all&#x27; npm run build:css &amp; cross-env change=&#x27;all&#x27; npm run build:js&quot;, &quot;watch&quot;: &quot;onchange --await-write-finish 500 -i \\&quot;**/*.js\\&quot; \\&quot;**/*.scss\\&quot; -e &#x27;./js/**/*.js&#x27; &#x27;./css/**/*.scss&#x27; -- cross-env change=&#x27;&#123;&#123;changed&#125;&#125;&#x27; node scripts/change.js&quot;, &quot;watch:js&quot;: &quot;onchange --await-write-finish 500 -i \\&quot;**/*.js\\&quot; -e &#x27;./js/**/*.js&#x27; -- cross-env change=&#x27;&#123;&#123;changed&#125;&#125;&#x27; node scripts/change.js&quot;, &quot;watch:css&quot;: &quot;onchange --await-write-finish 500 -i \\&quot;**/*.scss\\&quot; -e &#x27;./css/**/*.scss&#x27; -- cross-env change=&#x27;&#123;&#123;changed&#125;&#125;&#x27; node scripts/change.js&quot;, &quot;postbuild:css&quot;: &quot;rm -rf css/.empty.index.js &amp; rm -rf css/.map/.empty.index.js.map&quot; &#125;,&#125; 运行 npm run watch 进行开发 wp-js &#x3D;&gt; js 支持 es6 语法，es6 api 需要到 es.api 文件夹引入对应api（不然安卓4.4不支持） 支持 import export 语法 支持混淆压缩 支持 tree shaking wp-css &#x3D;&gt; css 支持 scss 文件处理","categories":[{"name":"工程化","slug":"工程化","permalink":"https://luoyuda.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://luoyuda.github.io/tags/CSS/"},{"name":"Webpack","slug":"Webpack","permalink":"https://luoyuda.github.io/tags/Webpack/"}]},{"title":"数据结构 - 二叉树（JavaScript实现）","slug":"data-structures/binaryTree","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/binaryTree/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/binaryTree/","excerpt":"","text":"源码地址 二叉树二叉树是 n(n&gt;&#x3D;0) 个节点的有限集合，该集合或者为空集(空二叉树)，或者一由一个根节点和两颗互不相交的、分别成为根节点的左子树和右子树的二叉树组成 特点 每个节点最多由两颗子树，所以二叉树不存在度大于2的节点 左子树根右子树是有顺序的，次序不能随意颠倒 即使树中某个节点只有一棵子树，也要区分是左子树还是右子树 形态 空二叉树 只有一个根节点 根节点只有左子树 根节点只有右子树 根节点既有左子树也有右子树 特殊的二叉树 斜树 左斜树 右斜树 满二叉树 如果所有的分支节点都有左子树根右子树，并且所有的叶子结点都在同一层 完全二叉树 对一个具有n个节点的二叉树进行层序编号，刚好编号为i的节点与同样深度的满二叉树中编号i的节点的位置完全相同 叶子节点只能出现在最下两层 最下层的叶子节点一定集中在左边 倒数二层如果有叶子结点，一定都在右边 如果节点度为1，则该节点只有左孩子，不存在右子树 同样节点数的二叉树，完全二叉树的深度最小 性质 第 i 层上至多有 2^i-1 个节点 （ i&gt;&#x3D;1 ） 深度为 k 的二叉树最多有 2^k - 1 个节点 （ k&gt;&#x3D;1 ） 终端节点 n0 &#x3D; （度为2的节点数）n2 + 1 具有N个节点的完全二叉树的深度为 log2N + 1 具有N个节点的完全二叉树按层序编号，如果 i 为 1则节点为根节点 如果 2i &gt; n 则节点 i 没有左孩子 如果 2i + 1 &gt; n 则 i 没有右孩子 树的遍历深度优先遍历前序遍历根节点 -&gt; 左子树 -&gt; 右子树 若二叉树为空，则空操作返回，否则先访问根节点，然后遍历左子树，在遍历右子树 123456789101112131415161718192021222324252627282930// 前序遍历const preOrderTraversal = function(treeNode, res=[]) &#123; if(!treeNode) return [] // 取中间节点 res.push(treeNode.data) // 再取左子树 preOrderTraversal(treeNode.leftChild, res) // 最后右子树 preOrderTraversal(treeNode.rightChild, res) return res&#125;// 使用栈实现前序遍历const preOrderTraversalByStack = function(treeNode) &#123; if(!treeNode) return [] let stack = [] let node = treeNode let res = [] while (node !== null || stack.length &gt; 0) &#123; while (node !== null)&#123; stack.push(node) res.push(node.data) node = node.leftChild &#125; if(stack.length &gt; 0) &#123; node = stack.pop() node = node.rightChild &#125; &#125; return res&#125; 中序遍历左子树 -&gt; 根节点 -&gt; 右子树 若二叉树为空，则空操作返回，否则先访问左子树，然后遍历根节点，在遍历右子树 123456789101112131415161718192021222324252627282930// 中序遍历const inOrderTraversal = function(treeNode, res=[]) &#123; if(!treeNode) return [] // 取左子树 inOrderTraversal(treeNode.leftChild, res) // 取中间节点 res.push(treeNode.data) // 最后取右子树 inOrderTraversal(treeNode.rightChild, res) return res&#125;// 使用栈实现中序遍历const inOrderTraversalByStack = function(treeNode) &#123; if(!treeNode) return [] let stack = [] let node = treeNode let res = [] while (node !== null || stack.length &gt; 0) &#123; while (node !== null)&#123; stack.push(node) node = node.leftChild &#125; if(stack.length &gt; 0) &#123; node = stack.pop() res.push(node.data) node = node.rightChild &#125; &#125; return res&#125; 后序遍历左子树 -&gt; 右子树 -&gt; 根节点 若二叉树为空，则空操作返回，否则先访问左子树，然后遍历右子树，在遍历根节点 1234567891011121314151617181920212223242526272829303132// 后序遍历const postOrderTraversal = function(treeNode, res=[]) &#123; if(!treeNode) return [] // 取左子树 postOrderTraversal(treeNode.leftChild, res) // 右子树 postOrderTraversal(treeNode.rightChild, res) // 最后取中间节点 res.push(treeNode.data) return res&#125;// 使用栈实现后序遍历const postOrderTraversalByStack = function(treeNode) &#123; if(!treeNode) return [] let stack = [treeNode] let curr = treeNode let last = treeNode let res = [] while(stack.length &gt; 0)&#123; curr = stack[stack.length - 1] if(curr.leftChild != null &amp;&amp; last != curr.leftChild &amp;&amp; last != curr.rightChild)&#123; stack.push(curr.leftChild) &#125;else if(curr.rightChild != null &amp;&amp; last != curr.rightChild)&#123; stack.push(curr.rightChild) &#125;else&#123; stack.pop() res.push(curr.data) last = curr &#125; &#125; return res&#125; 广度优先遍历层序遍历第一层 -&gt; 第二层 -&gt; 第三层 若二叉树为空，则空操作返回，否则先访问树的第一层，然后从上而下组层遍历，从左往右 123456789101112131415161718// 层序遍历const levelOrderTraversal = function(treeNode) &#123; if(!treeNode) return [] const queue = new Queue() queue.enqueue(treeNode) let res = [] while (!queue.isEmpty()) &#123; let node = queue.dequeue() res.push(node.data) if(node.leftChild != null) &#123; queue.enqueue(node.leftChild) &#125; if(node.rightChild != null) &#123; queue.enqueue(node.rightChild) &#125; &#125; return res&#125; 生成树123456789101112131415161718// 树节点const TreeNode = function(data) &#123; this.data = data this.leftChild = null this.rightChild = null&#125;// 使用前序顺序生成const createBinaryTree = function(list)&#123; let node = null if(list == null || list.length == 0) return null let data = list.shift() if(data) &#123; node = new TreeNode(data) node.leftChild = createBinaryTree(list, node.leftChild) node.rightChild = createBinaryTree(list, node.rightChild) &#125; return node&#125; 线索二叉树指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就被称为线索二叉树 原理把二叉树进行中序遍历之后，把所有空指针中rightChild指向它的后继节点，把leftChild指向前驱节点，这个过程称为线索化。需要通过 ltag 跟 rtag 的值 0&#x2F;1 来区分是左右孩子还前驱后继 123456789101112131415161718192021// 二叉树线索化let pre = nullconst ThreadedInOrderTraversal = function(treeNode, res=[]) &#123; if(!treeNode) return [] // 取左子树 ThreadedInOrderTraversal(treeNode.leftChild, res) if(!treeNode.leftChild)&#123; treeNode.lTag = 1 treeNode.leftChild = pre &#125; // 取中间节点 res.push(treeNode.data) if(pre &amp;&amp; !pre.rightChild)&#123; pre.rTag = 1 pre.rightChild = treeNode &#125; pre = treeNode // 最后取右子树 ThreadedInOrderTraversal(treeNode.rightChild, res) return res&#125; 树转换为二叉树 加线。在所有兄弟节点之间加一条连线 去线。对树中对每个节点，只保留它与第一个孩子节点对连线，删除它与其他孩子子节点之间对连线 以树的根节点为轴心，顺时针旋转一定角度，使其结构分明 森林转换成二叉树 把每棵树都转化成二叉树 第一颗二叉树不动，从第二颗二叉树开始，依次把后一颗二叉树对根节点作为前一颗二叉树的根节点的右孩子，用线连起来 二叉树转换成树 加线。若某节点的左孩子存在，将左孩子的右孩子节点、右孩子的右孩子节点…，都连线 去掉原二叉树中所有节点与其右孩子节点的连线 旋转调整层次 二叉树转换成森林 从根节点开始，若右孩子存在，将右孩子节点的连线删除，再查看分离后的二叉树，若右孩子存在，则接着删除，直到都删除感觉 再将分离后的二叉树转换成树","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://luoyuda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"数据结构 - 循环双向链表（JavaScript实现）","slug":"data-structures/circularDoublyLinkedList","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/circularDoublyLinkedList/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/circularDoublyLinkedList/","excerpt":"","text":"源码地址 双向循环链表（CircularDoublyLinkList）双向循环链表双向循环链表是在双向链表的基础上，将尾节点的 next 指向 头节点，形成了一个环。 11-&gt;2-&gt;3-&gt;1 // 1.next -&gt; 2.next -&gt; 3.next -&gt; 1 1.prev -&gt; 3.prev -&gt; 2.prev -&gt; 1.prev 初始化12345678910111213class CircularDoublyLinkList &#123; constructor(...arg)&#123; this.head = null this.rear = null &#125; node(data)&#123; return &#123; data, next: null, prev: null &#125; &#125;&#125; 基本操作插入头部插入 如果头节点为空，head 和 rear 都指向新节点node 头节点不为空，取出头节点 temp &#x3D; head node.next 指向 temp 设置头指针指向新节点node head &#x3D; node， 设置尾部节点的 next 指向新节点 rear.next &#x3D; node node.prev 指向 rear 12341-&gt;2-&gt;3-&gt;1 // head:1 rear:3 // 取出 1,3 插入 00-&gt;1-&gt;2-&gt;3 // 0.next -&gt; 10-&gt;1-&gt;2-&gt;3-&gt;0 // 3.next -&gt; 0 head: 0 3.prev 0.prev -&gt; 3 1234567891011121314151617181920212223242526prepend(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.head)&#123; // 如果头节点指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node node.next = this.head node.prev = this.rear return node.data &#125; // 取出头节点 let temp = this.head // 节点的 next 指向 temp node.next = temp // temp.prev 指向 前置节点 node temp.prev = node // 头节点指针 指向 node this.head = node // node.prev 指向 rear node.prev = this.rear // rear.next 指向 node this.rear.next = node // 返回节点值 return node.data&#125; 尾部插入 取出头尾节点 head，rear，temp &#x3D; rear 新节点 node.next 指向 head temp.next 指向新节点 node rear 指针指向新节点 node head.prev 指向 head 12341-&gt;2-&gt;3-&gt;1 // head:1 rear:3// 取出1，3 插入41-&gt;2-&gt;3-&gt;4 // 3.next = 41-&gt;2-&gt;3-&gt;4-&gt;1 // 4.next -&gt; 1 rear: 4 1.prev -&gt; 4 1234567891011121314151617181920212223242526append(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.rear)&#123; // 如果尾指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node node.next = this.head node.prev = this.rear return node.data &#125; // 取出尾节点 let temp = this.rear // 节点的 temp.next 指向 node temp.next = node // node.prev 指向 前置节点 temp node.prev = temp // 尾节点指针 指向 node this.rear = node // node.next 指向 head node.next = this.head // head.prev 指向 node this.head.prev = node // 返回节点值 return node.data&#125; 指定位置插入 找到插入的位置 curr，创建新节点 node，temp &#x3D; curr.next 把 curr.next 指向 node 把 node.next 指向 temp 把 node.prev 指向 curr 把 temp.prev 指向 node 12341-&gt;2-&gt;4-&gt;1 // 在 2 的位置插入 3取出 2 创建 3 1-&gt;2-&gt;3 // 2.next = 31-&gt;2-&gt;3-&gt;4-&gt;1 // 3.next = 4 3.prev -&gt; 2 4.prev -&gt; 3 12345678910111213141516171819add(el, data)&#123; // 查找到要插入的节点 let curr = this.contains(el) // 如果不存在 返回 null if(!curr) throw null if(curr == this.rear) return this.append(data) // 初始化一个节点 node let node = this.node(data) // 取出插入节点 curr 的 next let temp = curr.next // curr 的 next 指向新节点 node curr.next = node // node.prev 指向 前置节点 node.prev = curr // node 的 next 指向 curr 原来的 next node.next = temp // 返回节点值 return node.data&#125; 删除头部删除 取出头节点 temp &#x3D; head，如果节点不存在，返回 null。 把 head 的指针 指向原 head.next 把 rear.next 指向新的 head 把 head.prev 指向 rear 1231-&gt;2-&gt;3-&gt;1 // head 1 rear 32-&gt;3-&gt;1 // head 22-&gt;3-&gt;2 // rear.next -&gt; 2 head.prev -&gt; 3 123456789101112131415161718192021222324removeHead()&#123; if(!this.head) return null // 取出头节点 let temp = this.head // 如果头节点不存在，返回 null if(!temp) return null // 如果头节点的 next 不存在 尾节点置为 null if(temp == this.rear) &#123; this.rear = null this.head = null return temp.data &#125; // 删除 prev 的指向 temp.next.prev = null // 指定新的 头指针指向 this.head = temp.next // rear.next 指向新的 头节点 this.rear.next = this.head // head.prev 指向 尾节点 this.head.prev = this.rear // 清空 temp.next 的指向 temp.next = null return temp.data&#125; 尾部删除 取出头节点 head 尾节点 rear ，找出 rear 的前置节点 curr 将 curr.next 指向 rear.next 把尾指针指向 curr 把 head.prev 指向 curr 1231-&gt;2-&gt;3-&gt;1 // head 1 rear 3取出 2 1-&gt;2-&gt;1 // 2.next -&gt; 1.next rear head.prev -&gt; 2 1234567891011121314151617181920212223removeRear()&#123; if(!this.rear) return null // 先取出 头节点 let curr = this.rear.prev // 取出尾节点 let rear = this.rear if(rear == this.head) &#123; this.rear = null this.head = null return rear.data &#125; // 断开联系 rear.prev = null // 把前置节点 curr 的 next 指向 null if(curr) curr.next = null // 把尾指针指向 前置节点 curr this.rear = curr // rear.next 指向新的 头节点 this.rear.next = this.head // head.prev 指向 尾节点 this.head.prev = this.rear return rear.data&#125; 指定位置删除 判断删除位置是否头节点，还是尾节点，还是中间节点 取出 前置节点 curr，通过 curr.next 取出目标节点 node curr.next 指向 node.next node.next.prev 指向 curr 1231-&gt;2-&gt;3-&gt; // head 1 rear 3取出 1 21-&gt;3-&gt;1 // 1.next -&gt; 3 3.prev -&gt; 1 1234567891011121314151617181920remove(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 如果 删除值 等于头节点的值 直接删除头节点 if(this.head.data === el) return this.removeHead() // 取出头节点 寻找 前置节点 let curr = this.contains(el) // 如果找不到，返回null if(!curr) return null // 如果需删除的是尾节点 if(curr == this.rear) return this.removeRear() // 取出删除节点的前置节点，后置节点 let nextNode = curr.next let prevNode = curr.prev // 前置节点的 next 指向 后置节点 prevNode.next = nextNode // 后置节点的 prev 指向 前置节点 nextNode.prev = prevNode return curr.data&#125; 查找 循环查找，直到 curr 再次等于 head 的时候，跳出循环 12345678910111213contains(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 先取出 头节点 let curr = this.head do &#123; if(curr.data === el) break curr = curr.next; &#125; while (curr != this.head); if(curr.data != el) return null // 返回节点 return curr&#125; 遍历正序遍历 从头节点开始循环，直到 curr 再次等于 head 的时候，跳出循环 1234567891011121314// 遍历方法traverse(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.head do &#123; res.push(callback(curr.data)) curr = curr.next; &#125; while (curr != this.head); // 返回 return res&#125; 反序遍历 取出尾节点，通过前置指针不停往前，直到 curr 再次等于 rear 12345678910111213reverseTraversal(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.rear do &#123; res.push(callback(curr.data)); curr = curr.prev; &#125; while (curr != this.rear); // 返回 return res&#125; 反转 步骤跟单链表差不多，但是需要在后面处理尾指针的指向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 反转链表reverse() &#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 取出头节点 let curr = this.head // 定义 next 节点 let next = null // 定义 prev 节点 let prev = null while(curr)&#123; // 1-&gt;2-&gt;3-&gt;1 3-&gt;2-&gt;1-&gt;3 // 把 next 指向 curr.next next = curr.next // 1. curr = &#123; 1, next: 2, prev: 3 &#125; next = &#123; 2, next:3, prev: 1 &#125; prev = null // 2. curr = &#123; 2, next: 3, prev: 1 &#125; next = &#123; 3, next:1, prev:2 &#125; prev = &#123; 1, next:null, prev: 3 &#125; // 2. curr = &#123; 3, next: 1, prev: 2 &#125; next = &#123; 1, next: null, prev:2 &#125; prev = &#123; 2, next: 1, prev: 1 &#125; // 4. curr = &#123; 1, next: null, prev: 2 &#125; next = null prev = &#123; 3, next: 2, prev: 2 &#125; // curr.next 指向 prev 节点 curr.next = prev // 1. &#123; 1, next:null, prev: 3 &#125; // 2. &#123; 2, next: 1, prev: 1 &#125; // 3. &#123; 3, next: 2, prev: 2 &#125; // 4. &#123; 1, next: 3, prev: 2 &#125; // 指定前置节点 if(prev) prev.prev = curr // 1 // 2. &#123; 1, next:null, prev: 2 &#125; // 3. &#123; 2, next:1, prev: 3 &#125; // 4. &#123; 3, next: 2, prev: 1 &#125; // prev 节点 指向 curr prev = curr // 1. prev = &#123; 1, null &#125; // 2. prev = &#123; 2, next: 1, prev: 1 &#125; // 3. prev = &#123; 3, next: 2, prev: 2 &#125; // 3. prev = &#123; 1, next: 3, prev: 2 &#125; // 当前节点指向 next curr = next // 1. curr = &#123; 2, next: 3, prev: 1 &#125; // 2. curr = &#123; 3, next:1, prev:2 &#125; // 3. curr = &#123; 1, next: null, prev: 2 &#125; // 4. curr = null &#125; let rear = this.rear // 把原来的尾指针指向原来的头指针 this.rear = this.head // &#123; 3, 2 &#125; =&gt; &#123; 1, null &#125; // 头指针指向 prev 节点 this.head = rear // &#123; 1, null &#125; =&gt; &#123; 3, 2 &#125; return this&#125; 取出中间节点12345678910111213141516171819202122// 取出中间节点findMid()&#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 设置 快指针 search 慢指针 mid // search 步数为 mid 的两倍 let search = this.head let mid = this.head while(search.next != this.head)&#123; // 当 search.next == null 则说明到尾部 跳出循环 if(search.next.next != this.head)&#123; // 如果 search.next.next 存在值，则继续行进 search = search.next.next mid = mid.next &#125;else&#123; // 不存在则 快指针直接指向下一个节点 search = search.next &#125; &#125; // 返回 return mid&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"循环双向链表","slug":"循环双向链表","permalink":"https://luoyuda.github.io/tags/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构 - 循环链表（JavaScript实现）","slug":"data-structures/circularLinkedList","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/circularLinkedList/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/circularLinkedList/","excerpt":"","text":"源码地址 循环链表（CircularLinkedList）单向循环链表单向循环链表是在单向链表的基础上，将尾节点的 next 指向 头节点，形成了一个环 11-&gt;2-&gt;3-&gt;1 // 1.next -&gt; 2.next -&gt; 3.next -&gt; 1 初始化123456789101112class CircularLinkedList &#123; constructor()&#123; this.head = null this.rear = null &#125; node(data)&#123; return &#123; data, next: null &#125; &#125;&#125; 基本操作插入头部插入 如果头节点为空，head 和 rear 都指向新节点node 头节点不为空，取出头节点 temp &#x3D; head node.next 指向 temp 设置头指针指向新节点node head &#x3D; node， 设置尾部节点的 next 指向新节点 rear.next &#x3D; node 12341-&gt;2-&gt;3-&gt;1 // head:1 rear:3 // 取出 1,3 插入 00-&gt;1-&gt;2-&gt;3 // 0.next -&gt; 10-&gt;1-&gt;2-&gt;3-&gt;0 // 3.next -&gt; 0 head: 0 123456789101112131415161718192021prepend(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.head)&#123; // 如果头节点指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node node.next = this.head return node.data &#125; // 取出头节点 let temp = this.head // 节点的 next 指向 temp node.next = temp // 头节点指针 指向 node this.head = node // 尾指针next指向新的头指针节点 this.rear.next = this.head // 返回节点值 return node.data&#125; 尾部插入 取出头尾节点 head，rear，temp &#x3D; rear 新节点 node.next 指向 head temp.next 指向新节点 node rear 指针指向新节点 node 12341-&gt;2-&gt;3-&gt;1 // head:1 rear:3// 取出1，3 插入41-&gt;2-&gt;3-&gt;4 // 3.next = 41-&gt;2-&gt;3-&gt;4-&gt;1 // 4.next -&gt; 1 rear: 4 123456789101112131415161718192021append(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.rear)&#123; // 如果尾指针为空，则链表为空，直接令插入的节点作为头和尾 this.rear = node this.head = node node.next = this.head return node.data &#125; // 取出尾节点 let temp = this.rear // 新节点next 指向头节点 node.next = this.head // 节点的 temp.next 指向 node temp.next = node // 尾节点指针 指向 node this.rear = node // 返回节点值 return node.data&#125; 指定位置插入 找到插入的位置 curr，创建新节点 node，temp &#x3D; curr.next 把 curr.next 指向 node 把 node.next 指向 temp 12341-&gt;2-&gt;4-&gt;1 // 在 2 的位置插入 3取出 2 创建 3 1-&gt;2-&gt;3 // 2.next = 31-&gt;2-&gt;3-&gt;4-&gt;1 // 3.next = 4 123456789101112131415161718add(el, data)&#123; // 查找到要插入的节点 let curr = this.contains(el) // 如果不存在 返回 null if(!curr) throw null // 如果插入的节点是尾节点，直接使用尾部插入法 if(curr == this.rear) return this.append(data) // 初始化一个节点 node let node = this.node(data) // 取出插入节点 curr 的 next let temp = curr.next // curr 的 next 指向新节点 node curr.next = node // node 的 next 指向 curr 原来的 next node.next = temp // 返回节点值 return node.data&#125; 删除头部删除 取出头节点 temp &#x3D; head，如果节点不存在，返回 null。 把 head 的指针 指向原 head.next 把 rear.next 指向新的 head 1231-&gt;2-&gt;3-&gt;1 // head 1 rear 32-&gt;3-&gt;1 // head 22-&gt;3-&gt;2 // rear.next 2 12345678910111213141516removeHead()&#123; // 取出头节点 let temp = this.head // 如果头节点不存在，返回 null if(!temp) return null if(this.head == this.rear) &#123; this.head = null this.rear = null return temp.data &#125; // 指定新的 头指针指向 this.head = temp.next // 更改尾指针的 next 指向 this.rear.next = this.head return temp.data&#125; 尾部删除 取出头节点 head 尾节点 rear ，找出 rear 的前置节点 curr 将 curr.next 指向 rear.next 把尾指针指向 curr 1231-&gt;2-&gt;3-&gt;1 // head 1 rear 3取出 2 2-&gt;1 // 2.next -&gt; 1.next rear 2 1234567891011121314151617181920212223removeRear()&#123; // 先取出 头节点 let curr = this.head if(this.head == this.rear) &#123; this.head = null this.rear = null return curr.data &#125; while (curr)&#123; // 找出尾节点的前置节点 if(curr.next == this.rear) break // 如果不是 curr 指向 curr.next curr = curr.next &#125; // 取出尾节点 let rear = this.rear // 把前置节点 curr 的 next 指向 null curr.next = this.rear.next // 把尾指针指向 前置节点 curr this.rear = curr // 头指针指向新的尾指针 return rear.data&#125; 指定位置删除 判断删除位置是否头节点，还是尾节点，还是中间节点 取出 前置节点 curr，通过 curr.next 取出目标节点 node curr.next 指向 node.next 1231-&gt;2-&gt;3-&gt; // head 1 rear 3取出 1 21-&gt;3-&gt;1 // 1.next = 2.next 12345678910111213141516171819202122232425262728293031323334353637383940414243remove(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 如果 删除值 等于头节点的值 直接删除头节点 if(this.head.data == el)&#123; // 取出头节点 let temp = this.head if(this.head == this.rear)&#123; this.head = null this.rear = null return temp.data &#125; // 更改头指针指向 this.head = this.head.next // 更改尾指针的 next 指向 this.rear.next = this.head // 切断联系 temp.next = null return temp.data &#125; // 取出头节点 寻找 前置节点 let curr = this.head do &#123; // 查找 if(curr.next.data == el) break // 前进一步 curr = curr.next &#125; while (curr != this.head) // 如果需删除的是尾节点 if(curr.next == this.rear)&#123; let node = curr.next // 改变前置节点的 next 的指向 curr.next = this.head // 改变尾指针指向 this.rear = curr return node.data &#125; // 取出删除节点 let node = curr.next // 前置节点的 next 指向 删除节点的 next curr.next = node.next return node.data&#125; 查找 循环查找，直到 curr 再次等于 head 的时候，跳出循环 123456789101112131415contains(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null let curr = this.head do &#123; // 查找 if(curr.data === el) break // 前进一步 curr = curr.next &#125; while (curr != this.head); // 如果不相等，返回 null if(curr.data != el) return null // 返回节点 return curr&#125; 遍历正序遍历 从头节点开始循环，直到 curr 再次等于 head 的时候，跳出循环 123456789101112131415traverse(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.head do &#123; // 处理每一个值 res.push(callback(curr.data)) // 前进一步 curr = curr.next &#125; while (curr != this.head); // 返回 return res&#125; 反序遍历 取出头节点跟尾节点，反序取出 12345678910111213141516171819202122reverseTraversal(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 取出尾节点 let curr = this.rear // 如果 curr = head 跳出 while(curr != this.head)&#123; let prev = this.head // 从 head 开始查找 找到当前节点到前置节点 while(prev.next != curr)&#123; prev = prev.next &#125; // 处理 res.push(callback(curr.data)) // 当前节点指向前置节点 curr = prev &#125; // 再处理一遍 head res.push(callback(curr.data)) return res&#125; 反转 步骤跟单链表差不多，但是需要在后面处理尾指针的指向 12345678910111213141516171819202122232425262728293031323334353637383940414243// 反转链表reverse() &#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 取出头节点 let curr = this.head // 定义 next 节点 let next = null // 定义 prev 节点 let prev = null while(curr)&#123; // 1 2 3 -&gt; 3 2 1 &#123; 1, 2 &#125; &#123; 2, 3 &#125; &#123; 3, 1 &#125; // 把 next 指向 curr.next next = curr.next // 1. curr = 1 &#123; 1, 2 &#125; next = 2 &#123; 2, 3 &#125; prev = null // 2. curr = 2 &#123; 2, 3 &#125; next = 3 &#123; 3, 1 &#125; prev = &#123; 1, null &#125; // 3. curr = 3 &#123; 3, 1 &#125; next = &#123; 1, null &#125; prev = &#123; 2, 1 &#125; // 4. curr = 1 &#123; 1, null &#125; next = null prev = &#123; 3, 2 &#125; // curr.next 指向 prev 节点 curr.next = prev // 1. &#123; 1, null &#125; // 2. &#123; 2, 1 &#125; // 3. &#123; 3, 2 &#125; // 4. &#123; 1, 3 &#125; // prev 节点 指向 curr prev = curr // 1. prev = &#123; 1, null &#125; // 2. prev = &#123; 2, 1 &#125; // 3. prev = &#123; 3, 2 &#125; // 4. prev = &#123; 1, 3 &#125; // 当前节点指向 next curr = next // 1. curr = &#123; 2, 3 &#125; // 2. curr = &#123; 3, 1 &#125; // 3. curr = &#123; 1, null &#125; // 4. curr = null break &#125; // 头指针指向尾指针的节点 this.head = this.rear // &#123; 1, 2 &#125; =&gt; &#123; 3, 2 &#125; // 把尾指针指向 prev this.rear = prev // &#123; 3, 1 &#125; =&gt; &#123; 1, 3 &#125; return this&#125; 取出中间节点12345678910111213141516171819202122// 取出中间节点findMid()&#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 设置 快指针 search 慢指针 mid // search 步数为 mid 的两倍 let search = this.head let mid = this.head do &#123; // 当 search.next == null 则说明到尾部 跳出循环 if(search.next.next != this.head)&#123; // 如果 search.next.next 存在值，则继续行进 search = search.next.next mid = mid.next &#125;else&#123; // 不存在则 快指针直接指向下一个节点 search = search.next &#125; &#125; while (search.next != this.head); // 返回 return mid&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"循环链表","slug":"循环链表","permalink":"https://luoyuda.github.io/tags/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构 - 双向链表（JavaScript实现）","slug":"data-structures/doublyLinklist","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/doublyLinklist/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/doublyLinklist/","excerpt":"","text":"源码地址 双向链表 (DoublyLinkList)双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 初始化12345678910111213class DoublyLinkList &#123; constructor(...arg)&#123; this.head = null this.rear = null &#125; node(data)&#123; return &#123; data, next: null, prev: null &#125; &#125;&#125; 基本操作插入头部插入 如果头节点为空，直接插入，并指定 head rear 取出头节点 temp &#x3D; head 初始化新节点 node node.next 指向 temp temp.prev 指向 node head 指向 node 1230-&gt;1-&gt;2 // head 0 rear 2插入 -1 ，取出 0 -1-&gt;0-&gt;1-&gt;2 // -1.next -&gt; 0 0.prev -&gt; -1 1234567891011121314151617181920prepend(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.head)&#123; // 如果头节点指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node return node.data &#125; // 取出头节点 let temp = this.head // 节点的 next 指向 temp node.next = temp // temp.prev 指向 前置节点 node temp.prev = node // 头节点指针 指向 node this.head = node // 返回节点值 return node.data&#125; 尾部插入 如果头节点为空，直接插入，并指定 head rear 取出 temp &#x3D; rear 初始化节点 node temp.next 指向 node node.prev 指向 temp rear 指向 node 1231-&gt;2 // head 1 rear 2取出 2 插入 31-&gt;2-&gt;3 // 2.next-&gt;3 3.prev-&gt;2 rear 3 1234567891011121314151617181920append(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.rear)&#123; // 如果尾指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node return node.data &#125; // 取出尾节点 let temp = this.rear // 节点的 temp.next 指向 node temp.next = node // node.prev 指向 前置节点 temp node.prev = temp // 尾节点指针 指向 node this.rear = node // 返回节点值 return node.data&#125; 指定位置插入 查找出插入位置 curr，初始化 node，temp &#x3D; curr.next curr.next 指向 node node.prev 指向 curr node.next 指向 curr.next 12345678910111213141516171819add(el, data)&#123; // 查找到要插入的节点 let curr = this.contains(el) if(curr == this.rear) return this.append(data) // 如果不存在 返回 null if(!curr) throw null // 初始化一个节点 node let node = this.node(data) // 取出插入节点 curr 的 next let temp = curr.next // curr 的 next 指向新节点 node curr.next = node // node.prev 指向 前置节点 node.prev = curr // node 的 next 指向 curr 原来的 next node.next = temp // 返回节点值 return node.data&#125; 删除头部删除 取出头节点 temp &#x3D; head ，如果头节点不存在，直接返回null 如果 temp.next 不存在，证明只有一个节点，把头节点和尾节点一同置为 null 把头节点指针指向 temp.next temp.next.prev 置为 null，temp.next 置为 null 1231-&gt;2-&gt;3 // head 1 rear 3取出 1， 22-&gt;3 // 1.next = null; 2.prev = null; head = 2 1234567891011121314151617181920removeHead()&#123; if(!this.head) return null // 取出头节点 let temp = this.head // 如果头节点不存在，返回 null if(!temp) return null // 如果头节点的 next 不存在 尾节点置为 null if(!temp.next) &#123; this.rear = null this.head = null return temp.data &#125; // 删除 prev 的指向 temp.next.prev = null // 指定新的 头指针指向 this.head = temp.next // 清空 temp.next 的指向 temp.next = null return temp.data&#125; 尾部删除 取出 curr &#x3D; rear.prev，rear rear.prev 置为 null curr.next 置为 null rear 指针指向 curr 1231-&gt;2-&gt;3 // head 1 rear 3取出 3 ，3.prev -&gt; 21-&gt;2 // 2.next -&gt; null rear 2 1234567891011121314removeRear()&#123; if(!this.rear) return null // 先取出 头节点 let curr = this.rear.prev // 取出尾节点 let rear = this.rear // 断开联系 rear.prev = null // 把前置节点 curr 的 next 指向 null if(curr) curr.next = null // 把尾指针指向 前置节点 curr this.rear = curr return rear.data&#125; 指定位置删除 如果头节点不存在，返回null 如果值等于头节点，直接删除头节点 查找出值，如果值等于尾节点，直接删除尾节点 取出当前值的前置节点 prevNode， 后置节点 nextNode prevNode.next 指向 nextNode nextNode.prev 指向 prevNode curr.next, curr.prev 置为 null 1231-&gt;2-&gt;3 // head 1 rear 3找出 2 ，通过 2 取出 2.prev -&gt; 1 2.next -&gt; 31-&gt;3 // 1.next = 3 3.prev -&gt; 1 1234567891011121314151617181920remove(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 如果 删除值 等于头节点的值 直接删除头节点 if(this.head.data === el) return this.removeHead() // 取出头节点 寻找 前置节点 let curr = this.contains(el) // 如果找不到，返回null if(!curr) return null // 如果需删除的是尾节点 if(curr == this.rear) return this.removeRear() // 取出删除节点的前置节点，后置节点 let nextNode = curr.next let prevNode = curr.prev // 前置节点的 next 指向 后置节点 prevNode.next = nextNode // 后置节点的 prev 指向 前置节点 nextNode.prev = prevNode return curr.data&#125; 查找1234567891011121314contains(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 先取出 头节点 let curr = this.head while (curr)&#123; // 当 data = el 跳出循环 if(curr.data === el) break // 如果不是 curr = curr.next curr = curr.next &#125; // 返回节点 return curr&#125; 遍历正序遍历 从头节点开始，通过后继指针，循环遍历，直到 null 123456789101112131415traverse(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.head while (curr)&#123; // 处理每一个值 res.push(callback(curr.data)) // 前进一步 curr = curr.next &#125; // 返回 return res&#125; 反序遍历 由于每个非头节点都有前置节点，可以直接通过前置节点往前遍历 123456789101112131415reverseTraversal(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.rear while (curr)&#123; // 处理每一个值 res.push(callback(curr.data)) // 前进一步 curr = curr.prev &#125; // 返回 return res&#125; 反转 相比链表的反转，需要注意 prev 的指向问题 在循环中需要指定，循环结束后给头节点的 prev 置 null 123456789101112131415161718192021222324252627282930313233343536373839404142reverse() &#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 取出头节点 let curr = this.head // 定义 next 节点 let next = null // 定义 prev 节点 let prev = null while(curr)&#123; // 1 2 3 // 把 next 指向 curr.next next = curr.next // 1. curr = 1 &#123; 1, 2 &#125; next = 2 &#123; 2, 3 &#125; prev = null // 2. curr = &#123; 2, 3 &#125; next = &#123; 3, null &#125; prev = &#123; 1,null &#125; // 3. curr = &#123; 3, null &#125; next = null prev = &#123; 2, 1 &#125; // curr.next 指向 prev 节点 curr.next = prev // 指定前置节点 if(prev) prev.prev = curr // 1. &#123; 1, null &#125; // 2. &#123; 2, 1 &#125; &#123; 1, null &#125; // 3. &#123; 3, 2 &#125; &#123; 2, 1 &#125; &#123; 1, null &#125; // prev 节点 指向 curr prev = curr // 1. prev = &#123; 1, null &#125; // 2. prev = &#123; 2, 1 &#125; // 3. prev = &#123; 3, 2 &#125; // 当前节点指向 next curr = next // 1. curr = &#123; 2, 3 &#125; // 2. curr = &#123; 3, null &#125; // 2. curr = null &#125; // 把原来的尾指针指向原来的头指针 this.rear = this.head // &#123; 3, 2 &#125; =&gt; &#123; 1, null &#125; // 头指针指向 prev 节点 this.head = prev // &#123; 1, null &#125; =&gt; &#123; 3, 2 &#125; // 清楚头指针的 前置指针 this.head.prev = null return this&#125; 取出中间节点123456789101112131415161718192021findMid()&#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 设置 快指针 search 慢指针 mid // search 步数为 mid 的两倍 let search = this.head let mid = this.head while(search.next)&#123; // 当 search.next == null 则说明到尾部 跳出循环 if(search.next.next != null)&#123; // 如果 search.next.next 存在值，则继续行进 search = search.next.next mid = mid.next &#125;else&#123; // 不存在则 快指针直接指向下一个节点 search = search.next &#125; &#125; // 返回 return mid&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"双向链表","slug":"双向链表","permalink":"https://luoyuda.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构 - 堆（JavaScript实现）","slug":"data-structures/heap","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/heap/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/heap/","excerpt":"","text":"源码地址 堆堆 是一种特别的二叉树，满足以下条件的二叉树，可以称之为堆 完全二叉树 每一个节点的值都必须 大于等于或者小于等于 其孩子节点的值。 特点 可以在 O(logN) 的时间复杂度内向 堆 中插入元素； 可以在 O(logN) 的时间复杂度内向 堆 中删除元素； 可以在 O(1) 的时间复杂度内获取 堆 中的最大值或最小值。 分类 最大堆 堆内所有节点都大于或等于其孩子的节点值 堆顶元素就是堆内的最大值 最小堆 堆内所有节点都小于或等于其孩子的节点只 堆顶元素就是堆内最大值 堆操作 堆上浮 将节点与其父节点进行比较，如果不满足堆条件则和父节点交换，直到满足条件 堆下沉 将节点与子节点比较，与较小&#x2F;较大的节点交换，直到满足条件 添加元素 将元素插入到完全二叉树的最后一个节点，并执行堆上浮操作 删除元素 将堆顶元素删除，把最后一个节点复制到堆顶，然后将堆顶元素执行下沉操作 完全二叉树与数组转换12345678910tree 1 2 3 4 5 6 7==&gt;res = [7, 1, 2, 3, 4, 5, 6, 7]res[0]: 完全二叉树的大小 len父节点： n / 2子节点： left: 2n、right: 2n + 1是否叶子节点： n &gt; len / 2 编码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const helper = &#123; // 交换数组中的值 swap(arr, i, j)&#123; let temp = arr[i] arr[i] = arr[j] arr[j] = temp &#125;, // 获取父元素的下标 parent(i)&#123; return i &gt;&gt; 1 &#125;, // 获取左孩子下标 left(i)&#123; return i * 2 &#125;, // 获取右孩子下标 right(i)&#123; return i * 2 + 1 &#125;&#125;class Heap &#123; constructor(size)&#123; // 开辟数组空间 heap[0] 表示堆的个数 this.heap = new Array(size + 1); // 不真的使用第一个下标，方便后续定位 this.heap[0] = 0 &#125; get size() &#123; return this.heap[0] &#125; handle(i, j)&#123; return this.heap[i] &lt; this.heap[j] &#125; // 添加元素 add(el)&#123; if(this.size &gt;= this.heap.length) return -1 // 往尾部插入元素后进行上浮操作 this.heap[0] += 1 this.heap[this.size] = el this.up() return el &#125; // 弹出元素 pop()&#123; if(!this.size) return -1 // 弹出堆顶后将最后一个元素放置到堆顶，然后执行下沉操作 let el = this.peek() helper.swap(this.heap, 1, this.size) this.heap[this.size] = undefined this.heap[0] -= 1 this.down() return el &#125; // 上浮 up()&#123; let i = this.size let j = helper.parent(i) while (this.handle(i, j) &amp;&amp; i &gt; 1)&#123; helper.swap(this.heap, i, j) i = j j = helper.parent(i) &#125; &#125; // 下沉 down()&#123; let i = 1 while(i &lt; this.size &amp;&amp; i &lt;= this.size / 2)&#123; let l = helper.left(i) let r = helper.right(i) if(this.handle(r, i) || this.handle(l, i))&#123; let j = this.handle(r, l) ? r : l helper.swap(this.heap, i, j) i = j &#125;else&#123; break &#125; &#125; &#125; // 获取堆顶元素 peek()&#123; return this.heap[1] &#125;&#125;class MaxHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &gt; this.heap[j] &#125;&#125;class MinHeap extends Heap &#123; handle(i, j)&#123; return this.heap[i] &lt; this.heap[j] &#125;&#125; 时间复杂度 插入元素 获取堆顶元素 删除堆顶元素 创建「堆」 O(logN) O(1) O(logN) O(logN) 空间复杂度O(n)","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","permalink":"https://luoyuda.github.io/tags/%E5%A0%86/"}]},{"title":"数据结构 - 链表（JavaScript实现）","slug":"data-structures/linkedList","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/linkedList/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/linkedList/","excerpt":"","text":"源码地址 链表（linked list）链表是一种在物理上非连续、非顺序的数据结构，由若干节点组成。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 单向链表单向链表的每个节点包含两个部分，data 跟 next，data用于存放数据，next 指向 下一个节点 12345678910// 节点var node_1 = &#123; data: 1, next: null &#125;var node_2 = &#123; data: 2, next: null &#125;var node_3 = &#123; data: 3, next: null &#125;var node_4 = &#123; data: 4, next: null &#125;// 变成一个单向链表node_1.next = node_2node_2.next = node_3node_3.next = node_4// &#123;&quot;data&quot;:1,&quot;next&quot;:&#123;&quot;data&quot;:2,&quot;next&quot;:&#123;&quot;data&quot;:3,&quot;next&quot;:&#123;&quot;data&quot;:4,&quot;next&quot;:null&#125;&#125;&#125;&#125; 初始化123456789101112class LinkList &#123; constructor(...arg)&#123; this.head = null // 头节点指针 this.rear = null // 尾节点指针 &#125; node(data)&#123; return &#123; data, next: null &#125; &#125;&#125; 基本操作插入头部插入链表的头节点前面插入 新节点的next指向原头节点 把头节点指针指向新节点 1231-&gt;2-&gt;3 // head = 1插入0 // &#123; data: 0, next: null &#125;0-&gt;1-&gt;2-&gt;3 // &#123; data: 0, next: &#123; data:1, ...&#125; &#125; head = 0 123456789101112131415161718prepend(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.head)&#123; // 如果头节点指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node return node.data &#125; // 取出头节点 let temp = this.head // 节点的 next 指向 temp node.next = temp // 头节点指针 指向 node this.head = node // 返回节点值 return node.data&#125; 尾部插入从节点尾部插入新节点 通过尾指针找到尾节点，尾节点的next指向新节点 把尾指针指向新节点 1231-&gt;2-&gt;3 // rear = 3插入4 // &#123; data: 4, next: null &#125;1-&gt;2-&gt;3-&gt;4 // &#123; ... &#123; data: 3, next: &#123; data:4, next: null &#125; &#125; &#125; rear = 4 123456789101112131415161718append(data)&#123; // 初始化一个节点 node let node = this.node(data) if(!this.rear)&#123; // 如果尾指针为空，则链表为空，直接令插入的节点作为头和尾 this.head = node this.rear = node return node.data &#125; // 取出尾节点 let temp = this.rear // 节点的 temp.next 指向 node temp.next = node // 尾节点指针 指向 node this.rear = node // 返回节点值 return node.data&#125; 中间插入从指定的某个值后插入 找到目标节点，将目标节点的 next 取出 将新节点的 next 指向目标节点的 next 目标节点的 next 指向新节点 12345671-&gt;3 // &#123; data: 1, next: &#123; data: 3, next: null &#125;&#125;在 1 后插入 2 // &#123; data: 2, next: null &#125;取出 1 3 // 从 1.next 取出 3 1-&gt;2 // 1.next -&gt; 22-&gt;3 // 2.next -&gt; 31-&gt;2-&gt;3 // 1.next -&gt; 2.next -&gt; 3 1234567891011121314151617// 指定位置插入add(el, data)&#123; // 查找到要插入的节点 let curr = this.contains(el) // 如果不存在 返回 null if(!curr) throw null // 初始化一个节点 node let node = this.node(data) // 取出插入节点 curr 的 next let temp = curr.next // curr 的 next 指向新节点 node curr.next = node // node 的 next 指向 curr 原来的 next node.next = temp // 返回节点值 return node.data&#125; 删除头部删除从头节点开始删除节点 通过头指针取出头节点，取出头节点的 next 头指针指向 头节点的 next 释放原来的头节点 1231-&gt;2-&gt;3 // head:12 // 取出 1.next head = 22-&gt;3 // 2.next -&gt; 3.next 1234567891011121314// 删除第一个节点 removeHead()&#123; // 取出头节点 let temp = this.head // 如果头节点不存在，返回 null if(!temp) return null // 如果头节点的 next 不存在 尾节点置为 null if(!temp.next) this.rear = null // 指定新的 头指针指向 this.head = temp.next // 清空 temp.next 的指向 temp.next = null return temp.data &#125; 删除尾节点从尾部删除节点 取出尾指针指向的尾节点，通过头节点遍历找出尾节点的前置节点 将尾指针指向尾节点的前置节点，next 指向 null 释放原来的尾节点 12341-&gt;2-&gt;3 // head:1 rear:22 // 从 1 开始 找到 3 的前置节点 2 2.next = null3 // 删除 31-&gt;2 // 1.next-&gt;2.next-&gt;null 1234567891011121314151617removeRear()&#123; // 先取出 头节点 let curr = this.head while (curr)&#123; // 找出尾节点的前置节点 if(curr.next == this.rear) break // 如果不是 curr 指向 curr.next curr = curr.next &#125; // 取出尾节点 let rear = this.rear // 把前置节点 curr 的 next 指向 null curr.next = null // 把尾指针指向 前置节点 curr this.rear = curr return rear.data&#125; 删除指定节点删除指定的节点，断开前置节点的 next 指向，令前置节点的 next 指向删除节点的 next 找到目标节点的前置节点 curr，取出待删除节点 node &#x3D; curr.next 前置节点 curr 的 next 指向 待删除节点 node node.next 释放待删除节点 12341-&gt;2-&gt;3-&gt;4 // head:1 rear:4 删除32, 3 // 取出22-&gt;4 // 2.next = 3.next1-&gt;2-&gt;4 // 1.next-&gt;2.next-&gt;4.next-&gt;null 1234567891011121314151617181920212223242526272829303132remove(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 如果 删除值 等于头节点的值 直接删除头节点 if(this.head.data === el)&#123; // 取出头节点 let temp = this.head // 更改头指针指向 this.head = this.head.next // 切断联系 temp.next = null return temp.data &#125; // 取出头节点 寻找 前置节点 let curr = this.head while (curr &amp;&amp; curr.next)&#123; if(curr.next.data == el) break curr = curr.next &#125; // 如果找不到，返回null if(!curr.next) return null // 如果需删除的是尾节点 if(curr.next == this.rear)&#123; // 改变尾指针指向 this.rear = curr &#125; // 取出删除节点 let node = curr.next // 前置节点的 next 指向 删除节点的 next curr.next = node.next return node.data&#125; 查找 定位到头节点 根据头节点的next往下遍历比对 找到就返回 12341-&gt;2-&gt;3-&gt;4 // 查找3 head:11 // 从1开始查找 不是目标 接着走 1.next 2 // 2.next 3 // 找到，返回 123456789101112131415// 搜索方法contains(el)&#123; // 如果没有头节点，空链表返回 null if(!this.head) return null // 先取出 头节点 let curr = this.head while (curr)&#123; // 当 data = el 跳出循环 if(curr.data === el) break // 如果不是 curr = curr.next curr = curr.next &#125; // 返回节点 return curr&#125; 遍历正向遍历 找到头节点 查找每一个值，当curr为 null 跳出循环 123451-&gt;2-&gt;3 // head:11 //2 //3 //null // 跳出 12345678910111213141516// 遍历方法traverse(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 先取出 头节点 let curr = this.head while (curr)&#123; // 处理每一个值 res.push(callback(curr.data)) // 前进一步 curr = curr.next &#125; // 返回 return res&#125; 反向遍历 找到头节点，找到尾节点 每次从头节点查找到前置节点 123451-&gt;2-&gt;3 // head:13 //2 //等于 head // 跳出1 // 1234567891011121314151617181920212223// 反向遍历reverseTraversal(callback=(item)=&gt;item)&#123; let res = [] // 如果没有头节点，空链表返回 [] if(!this.head) return res // 取出尾节点 let curr = this.rear // 如果 curr = head 跳出 while(curr != this.head)&#123; let prev = this.head // 从 head 开始查找 找到当前节点到前置节点 while(prev.next != curr)&#123; prev = prev.next &#125; // 处理 res.push(callback(curr.data)) // 当前节点指向前置节点 curr = prev &#125; // 再处理一遍 head res.push(callback(curr.data)) return res&#125; 反转 取出头尾节点，定义 next &#x3D; null prev &#x3D; null curr &#x3D; head 从 curr 开始循环，取出 curr.next，next &#x3D; curr.next curr.next 指向 prev prev &#x3D; curr curr &#x3D; next 回到第二步 12341-&gt;2-&gt;3 // head=1 rear=31 2-&gt;3 // 1.next = null 2-&gt;1 33-&gt;2-&gt;1 123456789101112131415161718192021222324252627282930313233343536373839// 反转链表reverse() &#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 取出头节点 let curr = this.head // 定义 next 节点 let next = null // 定义 prev 节点 let prev = null while(curr)&#123; // 1 2 3 // 把 next 指向 curr.next next = curr.next // 1. curr = 1 &#123; 1, 2 &#125; next = 2 &#123; 2, 3 &#125; prev = null // 2. curr = &#123; 2, 3 &#125; next = &#123; 3, null &#125; prev = &#123; 1,null &#125; // 3. curr = &#123; 3, null &#125; next = null prev = &#123; 2, 1 &#125; // curr.next 指向 prev 节点 curr.next = prev // 1. &#123; 1, null &#125; // 2. &#123; 2, 1 &#125; &#123; 1, null &#125; // 3. &#123; 3, 2 &#125; &#123; 2, 1 &#125; &#123; 1, null &#125; // prev 节点 指向 curr prev = curr // 1. prev = &#123; 1, null &#125; // 2. prev = &#123; 2, 1 &#125; // 3. prev = &#123; 3, 2 &#125; // 当前节点指向 next curr = next // 1. curr = &#123; 2, 3 &#125; // 2. curr = &#123; 3, null &#125; // 2. curr = null &#125; // 把原来的尾指针指向原来的头指针 this.rear = this.head // &#123; 3, 2 &#125; =&gt; &#123; 1, null &#125; // 头指针指向 prev 节点 this.head = prev // &#123; 1, null &#125; =&gt; &#123; 3, 2 &#125; return this&#125; 取出中间节点取出中间节点一般通过快慢指针来实现 search 指针 search.next.next mid 指针 mid.next search 相当于 走两步，mid 走一步，当 search 走完的时候，mid 则刚好在中间 12341-&gt;2-&gt;3-&gt;4-&gt;5 // search = mid = 11 3 // mid = 1 search = 32 4 // mid = 2 search = 43 5 // mid = 3 search = 5 到达尾部，跳出循环 返回 mid 12345678910111213141516171819202122// 取出中间节点findMid()&#123; // 如果没有头节点，空链表返回null if(!this.head) return null // 设置 快指针 search 慢指针 mid // search 步数为 mid 的两倍 let search = this.head let mid = this.head while(search.next)&#123; // 当 search.next == null 则说明到尾部 跳出循环 if(search.next.next != null)&#123; // 如果 search.next.next 存在值，则继续行进 search = search.next.next mid = mid.next &#125;else&#123; // 不存在则 快指针直接指向下一个节点 search = search.next &#125; &#125; // 返回 return mid&#125; 时间复杂度 Access Search Insertion Deletion O(n) O(n) O(1) O(1) 空间复杂度O(n)","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://luoyuda.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构 - 队列（JavaScript实现）","slug":"data-structures/queue","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/queue/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/queue/","excerpt":"","text":"源码地址 队列（Queue）队列用于存储按顺序排列的数据，遵循 先进先出(FIFO，First-In-First-Out) 的原则 普通队列普通队列通过 enqueue 入队，通过 dequeue 出队，一般使用链表进行实现 初始化12345class Queue &#123; constructor()&#123; this.linkList = new LinkList() &#125;&#125; 基本操作入队操作利用链表的尾部插入的方式，进行入队操作 121-&gt;2-&gt;3 // head rear1-&gt;2-&gt;3-&gt;4 // 4 入队 123enqueue(data)&#123; return this.linkList.append(data)&#125; 出队操作利用链表删除头部的方法，进行出队操作 121-&gt;2-&gt;3 // head rear2-&gt;3 // 1 出队 123dequeue()&#123; return this.linkList.removeHead()&#125; 查找队首直接访问链表结构的头指针 123front()&#123; return this.linkList.head &amp;&amp; this.linkList.head.data || null&#125; 查找队尾直接访问链表结构的尾指针 123back()&#123; return this.linkList.rear &amp;&amp; this.linkList.rear.data || null&#125; 是否空队列判断头指针是否有值，如果没有值就是空队列 123isEmpty()&#123; return !this.linkList.head&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"队列","slug":"队列","permalink":"https://luoyuda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 - 栈（JavaScript实现）","slug":"data-structures/stack","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/stack/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/stack/","excerpt":"","text":"源码地址 栈（Stack）栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 普通栈通过数组顺序结构来实现栈 初始化12345class Stack &#123; constructor()&#123; this.linkList = new Array() &#125;&#125; 入栈1234push(data)&#123; let curr = this.list.push(data) return curr&#125; 出栈12345pop()&#123; if(this.isEmpty()) return null let curr = this.list.pop() return curr&#125; 检查是否空栈123isEmpty()&#123; return !this.list.length&#125; 获取栈顶元素123peek()&#123; return this.top() &gt;= 0 &amp;&amp; this.list[this.top()] || null&#125; 获取栈内元素个数123length()&#123; return this.list.length&#125; 获取栈顶位置123top()&#123; return this.length() - 1&#125; 链栈初始化1234567class StackLinked &#123; constructor()&#123; this.linkList = new LinkList() this.length = 0 // 获取栈内元素个数 this.top = 0 // 获取栈顶位置 &#125;&#125; 入栈123456push(data)&#123; let curr = this.linkList.prepend(data) ++this.length ++this.top return curr&#125; 出栈1234567pop()&#123; if(this.isEmpty()) return null let curr = this.linkList.removeHead() --this.length --this.top return curr&#125; 检查是否空栈123isEmpty()&#123; return !this.linkList.head&#125; 获取栈顶元素123peek()&#123; return this.linkList.head &amp;&amp; this.linkList.head.data || null&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://luoyuda.github.io/tags/%E6%A0%88/"}]},{"title":"数据结构 - 静态链表（JavaScript实现）","slug":"data-structures/staticlinkedList","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/staticlinkedList/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/staticlinkedList/","excerpt":"","text":"源码地址 静态链表（StaticLinkedList）对于那些没有指针的语言，可以通过数组来描述链表，这种链表叫做静态链表 初始化12345678910111213141516171819202122232425262728class StaticLinkedList &#123; constructor(size=10)&#123; // 数组第一个下标存储的值用来存放下一个备用链表的下标 // 数组最后一个下标存储的值用来存放指向头的下标 if(size &lt; 3) return null this.list = [] // 需要初始化数组中的每个值 for (let index = 0; index &lt; size; index++) &#123; let node = this.node(&#x27;&#x27;) node.next = index + 1 this.list[index] = node &#125; // 最后一个值的 next 默认指向 0 this.list[size-1].next = 0 // 数组的长度 this.size = size // 每次扩容的长度 this.expansionSize = size // 链表大小 this.length = 0 &#125; node(data) &#123; return &#123; next: 0, data, &#125; &#125;&#125; 扩容操作12345678910111213141516// 扩容expansion()&#123; // 如果链表长度超过了数组长度-2的时候 if(this.length &gt;= this.size -2)&#123; let expansionSize = this.size + this.expansionSize // 移动到最后 this.list[expansionSize - 1] = this.list[this.size-1] // 执行循环扩容 for (let index = this.size-1; index &lt; expansionSize - 1; index++) &#123; let node = this.node(&#x27;&#x27;) node.next = index + 1 this.list[index] = node &#125; this.size = expansionSize &#125;&#125; 基本操作插入头部插入1234567891011121314151617181920212223// 头部插入prepend(data)&#123; // 判断是否需要扩容 this.expansion() // 取出数组头 let front = this.list[0] // 通过数组头 取出下一个空闲节点的下标 let curr = front.next // 取出数组尾的头指针 let head = this.list[this.size-1] // 取出新增节点 let node = this.list[curr] // 给节点赋值 node.data = data // 数组头的 next 指向 node.next 指向一个新的空闲节点的下标 front.next = node.next // node.next 指向原来的 head.next node.next = head.next // 头指针指向新的头节点下标 head.next = curr ++this.length return data&#125; 尾部插入1234567891011121314151617181920212223242526272829303132333435// 尾部插入append(data)&#123; // 判断是否需要扩容 this.expansion() // 取出数组头 let front = this.list[0] // 通过数组头 取出下一个空闲节点的下标 let curr = front.next // 取出数组尾的头指针 let head = this.list[this.size-1] // 取出新增节点 let node = this.list[curr] // 给节点赋值 node.data = data // 数组头的 next 指向 node.next 指向一个新的空闲节点的下标 front.next = node.next // 判断链表长度 if(this.length == 0) &#123; // 如果空链表，需要给头指针指向当前的下标 head.next = curr &#125;else &#123; // 如果不是空链表，需要找到最后一个节点 let last = this.list[head.next] // 通过循环找到最后一个节点 while(last.next != 0)&#123; last = this.list[last.next] &#125; // 调整最后一个节点的指向 last.next = curr &#125; // node.next 需要指向 0 node.next = 0 ++this.length return data&#125; 中间插入从指定的某个值后插入 1234567891011121314151617181920212223242526// 指定插入add(value, data)&#123; // 判断是否需要扩容 this.expansion() // 取出数组头 let front = this.list[0] // 通过数组头 取出下一个空闲节点的下标 let curr = front.next // 取出新增节点 let node = this.list[curr] // 找到插入的节点 let currNode = this.contains(value) if(!currNode) return null // 取出前置节点原来指向的下标 let next = currNode.next // 给节点赋值 node.data = data // 数组头的 next 指向 node.next 指向一个新的空闲节点的下标 front.next = node.next // node.next 指向原来的 currNode.next node.next = next // currNode.next 指向 当前节点下标 currNode.next = curr ++this.length return data&#125; 删除头部删除从头节点开始删除节点 12345678910111213141516171819202122232425262728// 删除头节点removeHead()&#123; // 取出数组尾指针 let rear = this.list[this.size-1] // 取出头节点的下标 let headCur = rear.next // 取出头节点 let currNode = this.list[headCur] if(this.length == 0) return null // 取出头节点的下一个节点下标 let next = currNode.next // 取出数组头 let front = this.list[0] // 取出数组头的下个空闲节点下标 let empty = front.next // 获取头节点数据 let data = currNode.data // 尾指针指向新的头节点下标 rear.next = next // 头节点的 next 指向原下个空闲节点 currNode.next = empty // 置空 currNode.data = &#x27;&#x27; // 数组头的 next 指向原头节点的下标 front.next = headCur --this.length return data&#125; 删除尾节点从尾部删除节点 123456789101112131415161718192021222324252627282930313233// 删除尾节点removeRear()&#123; // 取出头节点 let curr = this.list[this.list[this.size-1].next] if(this.length == 0) return null // 循环找出尾节点的前置节点 while (curr != this.list[0])&#123; if(this.list[curr.next].next === 0) break curr = this.list[curr.next] &#125; // 如果尾节点也是头节点，直接删除头节点 if(curr == this.list[0]) return this.removeHead() // 取出尾节点的下标 let next = curr.next // 取出尾节点 let rear = this.list[next] // 取出数组头的下个空闲节点下标 let front = this.list[0] // 获取头节点数据 let data = rear.data // 取出数组头的下个空闲节点下标 let empty = front.next // 前置节点指向 0 成为新的尾节点 curr.next = 0 // 尾节点指针指向原空闲节点下标 rear.next = empty // 尾节点置空 rear.data = &#x27;&#x27; // 数组头的 next 指向尾节点的下标 front.next = next --this.length return data&#125; 删除指定节点删除指定的节点 12345678910111213141516171819202122232425262728293031323334// 删除某个节点remove(el)&#123; // 取出头节点 let curr = this.list[this.list[this.size-1].next] if(this.length == 0) return null // 如果头节点等于删除的数据，直接删除头节点 if(curr.data == el) return this.removeHead() // 寻找删除节点的前置节点 while (curr != this.list[0])&#123; if(this.list[curr.next].data === el) break curr = this.list[curr.next] &#125; // 取出待删除节点的下标 let next = curr.next // 取出待删除节点 let node = this.list[next] // 取出待删除节点数据 let data = node.data if(data != el) return null // 取出数组头的下个空闲节点下标 let front = this.list[0] // 取出数组头的下个空闲节点下标 let empty = front.next // 前置节点指向待删除节点的 next curr.next = node.next // 数组头的 next 待删除节点的下标 front.next = next // 待删除节点指针指向原空闲节点下标 node.next = empty // 尾节点置空 node.data = &#x27;&#x27; --this.length return data&#125; 查找 定位到头节点 根据头节点的next往下遍历比对 找到就返回 12345678910111213// 查找contains(data) &#123; // 取出头节点 let curr = this.list[this.list[this.size-1].next] if(this.length == 0) return null // 循环找出目标值 while (curr != this.list[0])&#123; if(curr.data === data) break curr = this.list[curr.next] &#125; if(curr == this.list[0]) return null return curr&#125; 遍历正向遍历1234567891011121314// 遍历方法traverse(callback=(item)=&gt;item)&#123; let res = [] // 先取出 头节点 let curr = this.list[this.list[this.size-1].next] // 如果没有头节点，空链表返回 [] if(this.length == 0) return [] while (curr != this.list[0])&#123; res.push(callback(curr.data)); curr = this.list[curr.next] &#125; // 返回 return res&#125; 反向遍历123456789101112131415161718192021222324252627// 反向遍历reverseTraversal(callback=(item)=&gt;item)&#123; let res = [] let head = this.list[this.list[this.size-1].next] // 如果没有头节点，空链表返回 [] if(this.length == 0) return [] // 取出尾节点 let curr = head while (curr.next != 0)&#123; curr = this.list[curr.next] &#125; // 如果 curr = head 跳出 while(curr != head)&#123; let prev = head // 从 head 开始查找 找到当前节点到前置节点 while(this.list[prev.next] != curr)&#123; prev = this.list[prev.next] &#125; // 处理 res.push(callback(curr.data)) // 当前节点指向前置节点 curr = prev &#125; // 再处理一遍 head res.push(callback(curr.data)) return res&#125; 反转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 反转链表reverse() &#123; // 先取出头节点的的下标 let cur = this.list[this.size-1].next // 取出头节点 let curr = this.list[cur] // 取出数组头 let front = this.list[0] // 临时保存原来头 let head = curr if(this.length === 0) return null // 定义 next 节点 let next = null // 定义 prev 节点 let prev = null // 声明一个用来存放前两位的下标 let temp = curr.next // 声明一个用来存放前置节点的下标 let lastCur = 0 prev = curr curr = this.list[temp] while(curr != front)&#123; // 1 2 3 // 把 next 指向 curr.next // 如果等于零，即将跳出循环令头节点的的下标指向当前节点的下标 if(curr.next == 0) cur = next ? next : cur // 取出下一个节点的下标 next = curr.next // curr.next 指向 prev 节点 if(lastCur &gt; 0)&#123; // 如果前置节点指针下标大于零，证明当前循环已经走过至少一次 // 缓存前置节点指针下标 let tempCur = lastCur // 前置节点下标指向上次的下标 lastCur = temp // 当前节点下标指向前前节点指向的下标 curr.next = tempCur &#125;else&#123; // 如果第一次，当前节点下标指向原来头节点的下标 curr.next = cur // 前前节点指向的下标 指向前置节点指向的 next lastCur = prev.next // 如果下个节点为零，证明只会走一次循环，需要把新的头节点下标指向当前节点的下标 if(next == 0) cur = temp &#125; // prev 节点 指向 curr prev = curr // 当前节点指向 next curr = this.list[next] // 缓存当前节点下标 temp = next &#125; // 把原来的头节点的 next 指向 0 head.next = 0 // 校正新的头节点下标 this.list[this.size-1].next = cur return this&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"静态链表","slug":"静态链表","permalink":"https://luoyuda.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构 - 前缀树（JavaScript实现）","slug":"data-structures/trie","date":"2020-06-24T11:23:00.000Z","updated":"2020-06-24T11:23:00.000Z","comments":true,"path":"2020/06/24/data-structures/trie/","link":"","permalink":"https://luoyuda.github.io/2020/06/24/data-structures/trie/","excerpt":"","text":"源码地址 前缀树是N叉树的一种特殊形式，用来存储字符串的，每一个节点代表一个字符串。每个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。 实现 数组 每个节点都是大小为26数组，通过计算字符与’a’的偏移量定位 [[[[]...]],...,[]] 哈希表 每个节点都是个hashmap，&#123; a: &#123; b ....&#125; &#125; 插入操作从根节点开始，根据字符串中的字符找到目标节点，没有则创建一个新的hashmap，直到最后一个节点 搜索操作从根结点开始，根据字符串字符查找子节点，如果没有找到子节点则不存在与trie树中，找到最后一个节点，且此节点为终止节点 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Initialize your data structure here. */var Trie = function() &#123; this.root = &#123;&#125;&#125;;/** * Inserts a word into the trie. * @param &#123;string&#125; word * @return &#123;void&#125; */Trie.prototype.insert = function(word) &#123; let root = this.root for(let x of word)&#123; if(!root[x])&#123; root[x] = &#123;&#125; &#125; root = root[x] &#125; root.end = true&#125;;/** * Returns if the word is in the trie. * @param &#123;string&#125; word * @return &#123;boolean&#125; */Trie.prototype.search = function(word) &#123; let root = this.find(word) return root ? !!root.end : false&#125;;/** * Returns if there is any word in the trie that starts with the given prefix. * @param &#123;string&#125; prefix * @return &#123;boolean&#125; */Trie.prototype.startsWith = function(prefix) &#123; return !!this.find(prefix)&#125;;Trie.prototype.find = function(word) &#123; let root = this.root for(let x of word)&#123; if(!root[x]) return false root = root[x] &#125; return root&#125;; 例题 实现 Trie (前缀树) 添加与搜索单词 单词搜索 II 单词的唯一缩写 设计搜索自动补全系统 单词替换 键值映射 数组中两个数的最大异或值","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前缀树","slug":"前缀树","permalink":"https://luoyuda.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"}]},{"title":"半自动骨架屏工具","slug":"JavaScript/CreateStructure","date":"2020-06-13T11:23:00.000Z","updated":"2022-04-15T06:06:33.724Z","comments":true,"path":"2020/06/13/JavaScript/CreateStructure/","link":"","permalink":"https://luoyuda.github.io/2020/06/13/JavaScript/CreateStructure/","excerpt":"","text":"源码地址 解决问题解决活动页面白屏问题 设计思路假设这是个活动页面 目标生成这样的骨架屏，通过 copy 按钮复制 HTML 代码插入到页面中 目标 执行方法时分析页面节点，挑选白名单节点 递归处理节点 将节点绘制到页面中 点击按钮复制骨架屏代码 util.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122const animationConf = &#123; loading: &#123; keyframe: &#x27;loading &#123; to &#123; background-position-x: -20%; &#125; &#125;&#x27;, needDelay: false, styles: &#123; backgroundColor: &#x27;#ecf0f2&#x27;, background: &#x27;linear-gradient( 100deg, rgba(255, 255, 255, 0) 40%, rgba(255, 255, 255, .5) 50%, rgba(255, 255, 255, 0) 60% ) #ecf0f2&#x27;, backgroundSize: &#x27;200% 100%&#x27;, backgroundPositionX: &#x27;180%&#x27;, animation: &#x27;2s loading ease-in-out infinite&#x27; &#125;, &#125;, flash: &#123; keyframe: &#x27;flash &#123;from,50%,to&#123;opacity: 1;&#125;25%,75% &#123;opacity: 0.5;&#125;&#125;&#x27;, needDelay: true, styles: &#123; backgroundColor: &#x27;#ecf0f2&#x27;, animation: &#x27;flash 3s infinite&#x27;, &#125;, &#125;,&#125;// 获取默认配置export const getDefault = () =&gt; &#123; return &#123; include: [&#x27;audio&#x27;, &#x27;button&#x27;, &#x27;canvas&#x27;, &#x27;code&#x27;, &#x27;img&#x27;, &#x27;input&#x27;, &#x27;pre&#x27;, &#x27;svg&#x27;, &#x27;textarea&#x27;, &#x27;video&#x27;], w: window.innerWidth, h: window.innerHeight, boxId: &#x27;bone&#x27;, boxStyle: `position: fixed;width: 100%;height: 100%;background-color: #fff;top: 0;z-index: 100000;`, delay: 0.3, beforeCreateOption: (() =&gt; false), styles: &#123; position: &#x27;fixed&#x27;, zIndex: 1000000, background: &#x27;#ecf0f2&#x27;, animation: &#x27;flash 3s infinite&#x27; &#125; &#125;&#125;export const useAnimation = (animation, config) =&gt; &#123; const animate = animationConf[animation] config.keyframe = animate.keyframe return &#123; ...config.styles, ...animate.styles &#125;&#125;// 获取节点css样式export const getStyle = el =&gt; &#123; if(el.nodeType !== 1) return () =&gt; &#x27;&#x27; const computedStyle = getComputedStyle(el) return attr =&gt; computedStyle[attr]&#125;// 百分比export const percent = (x, y) =&gt; parseFloat(x / y * 100).toFixed(3)// 是否隐藏元素export const isHidden = (style, node) =&gt; style(&#x27;display&#x27;) === &#x27;none&#x27; || style(&#x27;visibility&#x27;) === &#x27;hidden&#x27; || style(&#x27;opacity&#x27;) == 0 || node.hidden;// 是否有背景图export const hasBackgroundUrl = style =&gt; !!(style(&#x27;backgroundImage&#x27;).match(/url\\(.+?\\)/) || []).length// 是否有背景颜色export const hasBackgroundColor = style =&gt; !!(style(&#x27;backgroundColor&#x27;))// 是否圆角export const hasBorderRadius = style =&gt; !!(-style(&#x27;border-radius&#x27;).replace(&#x27;px&#x27;, &#x27;&#x27;))// 获取圆角export const getBorderRadius = style =&gt; !hasBorderRadius(style) ? `5px` : style(&#x27;border-radius&#x27;)// 获取node节点位置大小export const getRect = node =&gt; node ? node.getBoundingClientRect() : &#123;&#125;// 是否文本节点export const isTextNode = node =&gt; node.textContent.trim().length &amp;&amp; node.nodeType === 1 &amp;&amp; !node.children.length// 是否子元素为文本节点export const hasChildText = node =&gt; [...node.children].some(item =&gt; isTextNode(item)) &amp;&amp; node.children.length === 1export const inWhite = (els, node) =&gt; els.includes(node.tagName.toLocaleLowerCase())// 获取nodeexport const getRootNode = (el) =&gt; &#123; el = el || document.body return typeof el === &#x27;object&#x27; ? el : (typeof el === &#x27;string&#x27; ? document.querySelector(el): null);&#125;// 获取paddingexport const getPadding = style =&gt; &#123; return &#123; paddingTop: parseInt(style(&#x27;paddingTop&#x27;)), paddingLeft: parseInt(style(&#x27;paddingLeft&#x27;)), paddingBottom: parseInt(style(&#x27;paddingBottom&#x27;)), paddingRight: parseInt(style(&#x27;paddingRight&#x27;)) &#125;&#125;// 转换css属性export const transformStyle = (str, replace=&#x27;-&#x27;) =&gt; &#123; var temp = str.replace(/[A-Z]/g, (match) =&gt; &#123; return replace + match.toLowerCase(); &#125;); if(temp.slice(0,1) === replace)&#123; //如果首字母是大写，执行replace时会多一个_，这里需要去掉 temp = temp.slice(1); &#125; return temp;&#125;// 绘制节点export const drawBlock = (styles = &#123;&#125;) =&gt; Object.entries(styles).reduce((prev,[key, value]) =&gt; `$&#123;prev&#125;$&#123;transformStyle(key)&#125;:$&#123;value&#125;;`, &#x27;&lt;div style=&quot;&#x27;) + `&quot;&gt;&lt;/div&gt;`// 合并配置export const margeOptions = (option, useOption, node) =&gt; &#123; // 处理diy配置 const diy = useOption(node, option) // 显示不渲染 if(diy === null || JSON.stringify(diy) === &#x27;&#123;&#125;&#x27;) return null const options = typeof diy === &#x27;object&#x27; ? diy : option return options&#125; index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import &#123; getDefault, useAnimation, getStyle, percent, isHidden, hasBackgroundUrl, hasBackgroundColor, hasBorderRadius, getBorderRadius, getRect, isTextNode, hasChildText, inWhite, getRootNode, getPadding, drawBlock,margeOptions &#125; from &#x27;./util&#x27;class CreateStructure &#123; constructor(options = &#123;&#125;)&#123; this.node = getRootNode(options.node) // 初始化配置 this.config = &#123; ...getDefault(), ...options &#125; this.blocks = [] &#125; // 处理节点 deal(animate=&#x27;flash&#x27;)&#123; // 使用什么动画 useAnimation(animate, this.config) // div数组 this.blocks = [] // 动画延迟时间 const &#123; delay, beforeCreateOption, include &#125; = this.config let delayTime = 0 // 递归节点 this.deepFindNode(this.node.children, node =&gt; &#123; const style = getStyle(node) // 过滤隐藏的节点 if(isHidden(style, node)) return /** * 绘制目标 * 1. 有背景图片的节点 * 2. 有背景颜色且有圆角的节点 * 3. 文本节点 * 4. 子节点为文本节点 * 5. 在需要绘制的标签内的节点 */ if( hasBackgroundUrl(style) || (hasBackgroundColor(style) &amp;&amp; hasBorderRadius(style)) || isTextNode(node) || hasChildText(node) || inWhite(include, node) )&#123; // 获取默认配置 const option = this.defaultOptions(node) // 过滤不在当前的屏幕内的元素 if(!option) return // 判断动画是否需要延迟 option.animationDelay = delayTime + &#x27;s&#x27; delayTime = parseInt((delayTime + delay) * 10000) / 10000 const options = margeOptions(option, beforeCreateOption, node) if(!options) return // 绘制每个节点 this.blocks.push(drawBlock(options)) return true &#125; &#125;) &#125; // 递归节点 deepFindNode(nodes=[], deal=()=&gt;&#123;&#125;)&#123; nodes = [...nodes] if(nodes.length)&#123; nodes.forEach(el =&gt; &#123; const children = el.children if(!deal(el) &amp;&amp; children.length)&#123; this.deepFindNode(children, deal) &#125; &#125;); &#125; &#125; // 默认配置 defaultOptions(node)&#123; const &#123; width, height, top, left &#125; = getRect(node) const &#123; w, h &#125; = this.config if((width &gt;= w &amp;&amp; height &gt;= h) || top &gt; h || left &gt; w) return null const style = getStyle(node) const &#123; paddingTop, paddingLeft, paddingBottom, paddingRight, &#125; = getPadding(style) this.config.styles = &#123; ...this.config.styles, width: percent(width - paddingLeft - paddingRight, w) + &#x27;%&#x27;, height: percent(height - paddingTop - paddingBottom - (height / 30), h) + &#x27;%&#x27;, top: percent(top + paddingTop, h) + &#x27;%&#x27;, left: percent(left + paddingLeft, w) + &#x27;%&#x27;, borderRadius: getBorderRadius(style), &#125; return this.config.styles &#125; // 绘制方法 draw()&#123; if (!this.blocks.length) return const &#123; body &#125; = document; const &#123; keyframe=&#x27;&#x27;, boxStyle, boxId &#125; = this.config const blocksHTML = this.blocks.join(&#x27;&#x27;); const div = document.createElement(&#x27;div&#x27;); div.id = boxId div.style = boxStyle let html = `&lt;style&gt;@keyframes $&#123;keyframe&#125;@-webkit-keyframes $&#123;keyframe&#125;&lt;/style&gt;&lt;button style=&#x27;position: fixed;z-index: 10000000;left: 10px;top: 10px;&#x27; class=&#x27;copy-btn&#x27;&gt;copy HTML&lt;/button&gt;$&#123;blocksHTML&#125;` div.innerHTML = html body.appendChild(div); setTimeout(() =&gt; &#123; new ClipboardJS(&#x27;.copy-btn&#x27;, &#123; text: () =&gt; this.getHtml() &#125;); &#125;, 10) &#125; // 获取html内容 getHtml(data=&#123;&#125;)&#123; let &#123; html=&#x27;&#x27; &#125; = data const &#123; boxStyle, boxId &#125; = this.config const bone = document.getElementById(boxId) html = html || bone.innerHTML return `&lt;div id=&#x27;$&#123;boxId&#125;&#x27; style=&quot;$&#123;boxStyle&#125;&quot;&gt;$&#123;html&#125;&lt;/div&gt;&lt;script&gt;window.closeBone = function(e)&#123;var _b = document.getElementById(&#x27;$&#123;boxId&#125;&#x27;);(_b &amp;&amp; _b.remove())&#125;&lt;/script&gt;`; &#125;&#125;export default CreateStructure 使用123456789101112import CreateStructure from &#x27;./src/index&#x27;setTimeout(() =&gt; &#123; window.cs = new CreateStructure(&#123; boxStyle: `position: fixed;width: 100%;height: 100%;background-color: #ddd;top: 0;z-index: 100000;`, delay: 0.2, beforeCreateOption(node, option)&#123; &#125; &#125;) cs.deal() cs.draw()&#125;, 1000)","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"效率工具","slug":"效率工具","permalink":"https://luoyuda.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"骨架屏","slug":"骨架屏","permalink":"https://luoyuda.github.io/tags/%E9%AA%A8%E6%9E%B6%E5%B1%8F/"}]},{"title":"oss 上传辅助工具","slug":"Node/01","date":"2020-06-13T11:23:00.000Z","updated":"2022-04-15T06:06:33.728Z","comments":true,"path":"2020/06/13/Node/01/","link":"","permalink":"https://luoyuda.github.io/2020/06/13/Node/01/","excerpt":"","text":"源码地址 oss 上传辅助工具解决问题：减少手动压缩上传oss 将需要上传的图片内容放置在 src 文件夹中 压缩后的文件会保存到 .data 文件夹中 up：单纯压缩上传，不处理 src 文件 cp：复制 src 到 .data 中 rm：删除 src 内容 u：npm run up &amp;&amp; npm run cp &amp;&amp; npm run rm conf.js处理输入输出路径配置 123456789const dir = __dirname.replace(&#x27;scripts&#x27;, &#x27;&#x27;)const target = __dirname.replace(&#x27;scripts&#x27;, &#x27;.data&#x27;) // 目标文件夹路径const source = __dirname.replace(&#x27;scripts&#x27;, &#x27;src&#x27;) // 目标文件夹路径module.exports = &#123; source, target, dir&#125; util.js定义函数访问文件和文件夹 123456789101112131415161718192021222324252627282930// 通用函数const &#123; readdir, statSync &#125; = require(&#x27;fs&#x27;)const &#123; join &#125; = require(&#x27;path&#x27;)const noop = () =&gt; &#123;&#125;const findBySource = path =&gt; &#123; return new Promise(resolve =&gt; &#123; readdir(path, async (err, files) =&gt; &#123; resolve(&#123; files: files.map(file =&gt; join(path, file)), path &#125;) &#125;) &#125;)&#125;const resolveFile = (file, dirCb = noop, fileCb = noop) =&gt; &#123; let stat = statSync(file) if(stat.isDirectory())&#123; dirCb(file) &#125;else if(stat.isFile())&#123; fileCb(file) &#125;&#125;module.exports = &#123; findBySource, resolveFile&#125; cp.js用于复制文件到目标文件夹 123456789101112131415161718192021222324252627// 复制文件const &#123; join &#125; = require(&#x27;path&#x27;)const &#123; source, target &#125; = require(&#x27;./conf&#x27;)const &#123; findBySource, resolveFile &#125; = require(&#x27;./util&#x27;)const &#123; cp, mkdir, rm &#125; = require(&#x27;shelljs&#x27;)const cb = (&#123; files &#125;) =&gt; &#123; return new Promise(async resolve =&gt; &#123; files.map(async file =&gt; &#123; let targetFile = join(target, file.replace(source, &#x27;&#x27;)) resolveFile(file, () =&gt; &#123; // 创建 ./data/文件夹 mkdir(targetFile) findBySource(file).then(cb).then(() =&gt; &#123; // rm(&#x27;-rf&#x27;, file) &#125;) &#125;, () =&gt; &#123; // 移动到目标文件夹 rm(&#x27;-rf&#x27;, targetFile) cp(&#x27;-R&#x27;, file, targetFile) &#125;) &#125;) resolve() &#125;)&#125;findBySource(source).then(cb) rm.js用于删除文件 123456789101112131415// 删除文件const &#123; findBySource, resolveFile &#125; = require(&#x27;./util&#x27;)const &#123; source &#125; = require(&#x27;./conf&#x27;)const &#123; rm &#125; = require(&#x27;shelljs&#x27;)const rmCb = file =&gt; rm(&#x27;-rf&#x27;, file)const cb = (&#123; files &#125;) =&gt; &#123; return new Promise(async resolve =&gt; &#123; files.map(async file =&gt; resolveFile(file, rmCb, rmCb)) resolve() &#125;)&#125;findBySource(source).then(cb) up.js用于压缩上传到 oss，具体 oss 配置需要自行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 上传代码const fs = require(&#x27;fs&#x27;);const &#123; mkdir &#125; = require(&#x27;shelljs&#x27;) // mkdir 创建文件夹方法const &#123; source, target, dir &#125; = require(&#x27;./conf&#x27;)const &#123; findBySource, resolveFile &#125; = require(&#x27;./util&#x27;) // findBySource 获取文件夹内容方法，resolveFile 判断是否文件夹方法// 第三方插件const sizeOf = require(&#x27;image-size&#x27;); // 获取图片大小插件const imagemin = require(&#x27;imagemin&#x27;); // 压缩插件const imageminJpegtran = require(&#x27;imagemin-jpegtran&#x27;); // 压缩 jpg 插件const imageminPngquant = require(&#x27;imagemin-pngquant&#x27;); // 压缩 png 插件const date = new Date()// 归档文件名，防止重复，用时间来做文件名const uploadFilePath = `$&#123;target&#125;\\\\$&#123;date.getFullYear()&#125;-$&#123;date.getMonth()+1&#125;-$&#123;date.getDate()&#125;-$&#123;date.getHours()&#125;-$&#123;date.getMinutes()&#125;-$&#123;date.getSeconds()&#125;.txt`// oss 部分// const OSS = require(&#x27;ali-oss&#x27;);// const client = new OSS(&#123;// accessKeyId: &#x27;...&#x27;,// accessKeySecret: &#x27;...&#x27;,// region: &#x27;...&#x27;,// bucket: &#x27;...&#x27;// &#125;);async function put (file) &#123; try &#123; //object-name可以自定义为文件名（例如file.txt）或目录（例如abc/test/file.txt）的形式，实现将文件上传至当前Bucket或Bucket下的指定目录。 // const result = await client.put(file, file.replace(/.\\//ig, &#x27;&#x27;)); console.log(&#x27;---- upload ----&#x27;); console.log(file, file.replace(/.\\//ig, &#x27;&#x27;)); &#125; catch (e) &#123; console.log(e); &#125;&#125;// 创建文件夹mkdir(target)// 记录处理次数let count = 0// 所有文件个数let all = 0// 文件内容let txt = &#x27;&#x27;// 上传钩子函数：（输出图片信息文档）const beforeUploadHook = file =&gt; &#123; // 获取图片尺寸 const size = sizeOf(file) count++ txt += `path: $&#123;file.replace(source, &#x27;&#x27;)&#125;; height: $&#123;size.height&#125;px; width: $&#123;size.width&#125;px;` // 如果处理的文件个数等于所有的文件个数，则默认所有的文件已经处理完成 if(all === count)fs.writeFileSync(`$&#123;uploadFilePath&#125;`, txt)&#125;const zipImage = async (src, dir) =&gt; &#123; return await imagemin([`$&#123;src.replace(dir, &#x27;&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;)&#125;/*.&#123;jpg,png&#125;`], &#123; destination: src, plugins: [ imageminJpegtran(&#123; progressive:true &#125;), imageminPngquant(&#123; quality: [0.8, 0.9] &#125;) ] &#125;);&#125;// 读取文件夹回调const cb = (&#123; files, path &#125;) =&gt; &#123; return new Promise(async resolve =&gt; &#123; // 匹配到图片则进行压缩处理，生成新的图片 zipImage(path, dir) // 记录文件数 all += files.length files.map(async file =&gt; &#123; resolveFile(file, () =&gt; &#123; // 如果是文件夹 all -1 all-- findBySource(file).then(cb) &#125;, async () =&gt; &#123; // 调用钩子函数 beforeUploadHook(file) // 上传 put(file) &#125;) &#125;) resolve() &#125;)&#125;// 读取目标文件夹findBySource(source).then(cb)","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://luoyuda.github.io/tags/Node/"},{"name":"提效工具","slug":"提效工具","permalink":"https://luoyuda.github.io/tags/%E6%8F%90%E6%95%88%E5%B7%A5%E5%85%B7/"}]},{"title":"docker 笔记","slug":"Docker/01","date":"2020-05-31T11:23:00.000Z","updated":"2020-05-31T11:23:00.000Z","comments":true,"path":"2020/05/31/Docker/01/","link":"","permalink":"https://luoyuda.github.io/2020/05/31/Docker/01/","excerpt":"","text":"docker 核心docker 镜像 命令docker images 查看所有本地主机上的镜像 命令选项 意义 -a, –all 列出所有镜像，默认为 true –disests 列出镜像数字摘要值，默认为true -f, –filter&#x3D;[] 过滤列出的镜像 –format&#x3D;”TEMPLATE” 控制输出格式 -q, –quiet 仅输出ID信息 docker search 搜索镜像 命令选项 意义 –filter 过滤搜索 docker pull 拉取镜像，分层下载，docker pull 镜像名:标签名，不写标签名则拉取最新的版本 docker rmi 删除一个或一组镜像，用空格分割 命令选项 意义 -f 强制删除 docker 容器命令docker run 启动一个镜像，docker run [可选项] image 命令选项 意义 –name 容器名字 -d 后台方式运行 -p 指定容器端口 -P 随机指定端口 -it 使用交互式运行，进入容器查看内容 docker ps 列出所有在运行的容器 命令选项 意义 -a 列出所有容器 -q 仅输出ID信息 -n&#x3D;? 最近创建的容器 docker rm 删除一个或一组容器，用空格分割 命令选项 意义 -f 强制删除 docker start 启动容器 docker restart 重启容器 docker stop 停止容器 docker kill 强制杀死容器 其他命令docker logs 查看某个容器的日志 1docker logs -tf --tail 10 container docker top 查看容器内进程信息 docker inspect 查看容器信息 docker exec 进入当前容器，开启一个新的终端，可以在里面操作 1docker exec -it container /bin/bash docker attach 进去容器正在执行的代码 docker cp 从容器中复制文件 1docker cp container:init.sh . docker commit 提交镜像 1docker commit -m=&quot;描述&quot; -a=&quot;作者&quot; container image:tag docker 小案例nginx123456# 1. 下载镜像docker pull nginx# 2. 运行镜像生成容器docker run -d --name xhl_nginx -p 3030:80 nginx# 3. 测试是否正常运行curl localhost:3030 tomcat123456# 1. 下载镜像docker pull tomcat# 2. 运行镜像生成容器docker run -d -p 3355:8080 --name xhl_tomcat tomcat# 3. 复制文件夹目录到目标文件夹cp -r /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps 容器数据卷容器之间可以共享数据 1docker run -it -v 主机目录:容器目录 安装mysql1234# 1. 下载镜像docker pull mysql# 2. 运行 Dockerfile Dockerfile 就是用来构建 docker 镜像的构建文件 1docker build -f 文件路径 -t image . 每个保留关键字都必须大写 执行从上到下顺序执行 #表示注释 每一个指令都会创建一个镜像层 Dockerfile 指令123456789101112FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像维护者， 姓名+邮箱RUN # 运行命令ADD # 添加内容WORKDIR # 设置工作目录VOLUME # 挂载目录EXPOSE # 保留端口配置CMD # 指定这个容器启动时候运行的命令，只有最后一个会生效，可以被替代ENTRYPOINT # 指定这个容器启动时候运行的命令，可以追加命令ONBUILD # 当构建一个被继承当时候会运行，触发指令COPY # 复制文件到镜像中ENV # 设置环境变量 构建centos1234567891011121314151617# 基础映像FROM centos# 维护者MAINTAINER xhl&lt;562958029@qq.com&gt;# 环境变量ENV MYPATH /usr/local# 设置工作目录WORKDIR $MYPATH# 安装 vim net-toolsRUN yum -y install vimRUN yum -y install net-tools# 暴露端口EXPOSE 80CMD echo $MYPATHCMD echo &quot;--end--&quot;CMD /bin/bash CMD ENTRYPOINTENTRYPOINT 追加命令直接拼接到参数后面 CMD 需要完整命令去替换 tomcat 实战12345678910111213tomcat-demo 目录结构.├── Dockerfile├── apache-tomcat-9.0.35.tar.gz├── html│ ├── WEB-INF│ │ └── web.xml│ ├── a.jsp│ └── index.html├── jdk-8u11-linux-x64.tar.gz├── logs│ └──└── readme.txt 12345678910111213141516171819202122232425# Dockerfile# 基本镜像FROM centos# 基本信息MAINTAINER xhl&lt;562958029@qq.com&gt;# 复制文件COPY readme.txt /usr/local/readme.txt# 添加 jdk apache-tomcat 到 /usr/local 并解压ADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.35.tar.gz /usr/local/# 安装 vimRUN yum -y install vim# 设置环境变量 工作目录ENV MYPATH /usr/local/WORKDIR $MYPATH# 设置环境变量 ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.35ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin# 暴露接口EXPOSE 8080# 启动 tomcatCMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/bin/logs/catalina.out 123456789101112131415# 构建镜像docker build -t my_tomcat .# 运行镜像docker run -d -p 8090:8080 --name xhl_tomcat -v /Users/chenxiayu/docker-demo/tomcat-demo/html:/usr/local/apache-tomcat-9.0.35/webapps/html -v /Users/chenxiayu/docker-demo/tomcat-demo/logs/:/usr/local/apache-tomcat-9.0.35/logs my_tomcat# 请求localhost:8090curl localhost:8090# tag 打上标签docker tag 392978c9c6de xiayu5/my_tomcat:1.0# push 推送到 dockerHubdocker push xiayu5/my_tomcat:1.0 docker 网络1234567891011121314# 查看内部网络地址ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/ipip 0.0.0.0 brd 0.0.0.03: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000 link/tunnel6 :: brd ::78: eth0@if79: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 原理每启动一个docker容器，docker就会给容器分配一个ip。容器间可以互相ping通 –link连接容器，只能 A 连 B，A 能 ping 通 A，B ping 不通 A 网络模式123456789101112131415161718192021222324252627282930313233343536373839bridge: 桥接模式 (默认)none: 不配置网络host: 和宿主机共享网络container: 容器网络互通docker run -d -p -name c1 --net=bridge centosdocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet--driver 模式--subnet 子网地址--gateway 网关# 不使用 --link 也能 ping 通docker run -it -d --name c1 --net mynet centosdocker run -it -d --name c2 --net mynet centosdocker exec -it c1 ping c2PING c2 (192.168.0.3) 56(84) bytes of data.64 bytes from c2.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.126 msdocker exec -it c2 ping c1PING c1 (192.168.0.2) 56(84) bytes of data.64 bytes from c1.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.987 ms# docker network connect [OPTIONS] NETWORK CONTAINER# 容器连通到网络docker network connect mynet cpn1# 将cpn1加入到 mynet Containers 中docker exec -it c2 ping cpn1PING cpn1 (192.168.0.4) 56(84) bytes of data.64 bytes from cpn1.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.263 ms64 bytes from cpn1.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.103 msdocker exec -it c1 ping cpn1PING cpn1 (192.168.0.4) 56(84) bytes of data.64 bytes from cpn1.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.444 ms64 bytes from cpn1.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.076 ms redis 集群123456789101112131415161718192021222324252627282930# init.shdocker network create --driver bridge --subnet 192.169.0.0/16 redis sudo mkdir -p /Users/chenxiayu/docker-demo/redis-group-demo/redissudo chmod -R 777 /Users/chenxiayu/docker-demo/redis-group-demo/redis/for port in $(seq 1 6);doecho &quot;$port&quot;sudo mkdir -p /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/datasudo mkdir -p /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/confsudo chmod -R 777 /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/sudo chmod -R 777 /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/data/sudo chmod -R 777 /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/conf/sudo touch /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/conf/redis.confsudo chmod -R 777 /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/conf/redis.confsudo cat &lt;&lt;EOF &gt; /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 192.169.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFsudo docker run -p 637$&#123;port&#125;:6379 -p 1367$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \\-v /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/data:/data \\-v /Users/chenxiayu/docker-demo/redis-group-demo/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 192.169.0.1$&#123;port&#125; redis redis-server /etc/redis/redis.confdone 12345678910111213141516171819202122# 进入容器docker exec -it redis-1 sh# 创建集群redis-cli --cluster create 192.169.0.11:6379 192.169.0.12:6379 192.169.0.13:6379 192.169.0.14:6379 192.169.0.15:6379 192.169.0.16:6379 --cluster-replicas 1# 进入集群 查看集群分布redis-cli -c192.169.0.14:6379&gt; cluster nodes0b340a93041448fd37a52fb808a9690c56aab02b 192.169.0.13:6379@16379 slave 8d6026446c28203ae8708edeec3bfa68d8606ca2 0 1590910699057 7 connected30d17be07b086c65eb45efd449ca6e65949efd2d 192.169.0.16:6379@16379 slave 81f593301f71dec7f89d5e41a3f5facbfa4136bc 0 1590910698545 6 connected8d6026446c28203ae8708edeec3bfa68d8606ca2 192.169.0.14:6379@16379 myself,master - 0 1590910699000 7 connected 10923-1638381f593301f71dec7f89d5e41a3f5facbfa4136bc 192.169.0.12:6379@16379 master - 0 1590910700088 2 connected 5461-10922acac3d931539ff56cc584b000f1edab51ec47021 192.169.0.15:6379@16379 slave e22c1502d5d6446e4ea126987bba9b3e40a84168 0 1590910699000 5 connectede22c1502d5d6446e4ea126987bba9b3e40a84168 192.169.0.11:6379@16379 master - 0 1590910699000 1 connected 0-5460# 随便设置一个值192.169.0.14:6379&gt; set b 321-&gt; Redirected to slot [3300] located at 192.169.0.11:6379OK192.169.0.14:6379&gt; get b-&gt; Redirected to slot [3300] located at 192.169.0.11:6379&quot;321&quot;","categories":[{"name":"部署","slug":"部署","permalink":"https://luoyuda.github.io/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://luoyuda.github.io/tags/docker/"}]},{"title":"CSS布局","slug":"CSS/01","date":"2019-04-16T11:23:00.000Z","updated":"2019-04-16T11:23:00.000Z","comments":true,"path":"2019/04/16/CSS/01/","link":"","permalink":"https://luoyuda.github.io/2019/04/16/CSS/01/","excerpt":"","text":"github 单栏布局1234567891011121314151617&lt;!--公共样式--&gt;&lt;style&gt;*&#123; margin:0; padding:0;&#125;.header,.banner,.footer&#123; min-height: 50px; border-bottom: 1px solid #003300; background: #c6ffdd; /* fallback for old browsers */ background: -webkit-linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* Chrome 10-25, Safari 5.1-6 */ background: linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */&#125;.parent&#123; margin-bottom: 30px;&#125;&lt;/style&gt; margin代码实现123456789101112131415161718192021222324&lt;!-- margin --&gt; &lt;div class=&#x27;parent layout1&#x27;&gt; &lt;style&gt; /* margin + max-width 1.子元素 设定 margin: 0 auto; 指定宽度 或者 父元素设定 margin: 0 auto; 指定最大宽度 子元素宽度百分百 实用性：兼容性好，需指定宽度 */ .layout1 .header,.layout1 .banner,.layout1 .footer&#123; margin: 0 auto; max-width: 960px; &#125; /* 或者父元素直接 margin: 0 auto; max-width: 960px; 子元素宽度百分百*/ &lt;/style&gt; &lt;div class=&#x27;header&#x27;&gt;header&lt;/div&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;p&gt;margin + max-width&lt;/p&gt; &lt;p&gt;1.子元素 设定 margin: 0 auto; 指定宽度&lt;/p&gt; &lt;p&gt;或者 父元素设定 margin: 0 auto; 指定最大宽度 子元素宽度百分百&lt;/p&gt; &lt;p&gt;实用性：兼容性好，需指定宽度&lt;/p&gt; &lt;/div&gt; &lt;div class=&#x27;footer&#x27;&gt;footer&lt;/div&gt; &lt;/div&gt; 效果 inline-block + text-align代码实现123456789101112131415161718192021222324252627&lt;!-- inline-block text-align --&gt; &lt;div class=&#x27;parent layout2&#x27;&gt; &lt;style&gt; /* inline-block text-align width max-width 1.设置 子元素 display:inline-block 最大宽度 和 宽度百分 2.父元素 text-align: center 实用性：兼容性好，需要设定父元素，且子元素需指定宽度 */ .layout2.parent&#123; text-align: center; &#125; .layout2 .header,.layout2 .banner,.layout2 .footer&#123; max-width: 960px; width: 100%; display: inline-block; &#125; &lt;/style&gt; &lt;div class=&#x27;header&#x27;&gt;header&lt;/div&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;p&gt;inline-block text-align width max-width 兼容性好，需要设定父元素，且子元素需要指定宽度 &lt;/p&gt; &lt;p&gt;1.设置 子元素 display:inline-block 最大宽度 和 宽度百分百&lt;/p&gt; &lt;p&gt;2.父元素 text-align: center &lt;/p&gt; &lt;p&gt;实用性：兼容性好，需要设定父元素，且子元素需指定宽度 &lt;/p&gt; &lt;/div&gt; &lt;div class=&#x27;footer&#x27;&gt;footer&lt;/div&gt; &lt;/div&gt; 效果 flexbox代码实现1234567891011121314151617181920212223242526272829303132&lt;!-- flexbox --&gt; &lt;div class=&#x27;parent layout3&#x27;&gt; &lt;style&gt; /* flexbox 1.父元素display:flex; 2.父元素 设定 子元素 排列方向 flex-direction: column; 3.父元素 设定 子元素 根据交叉轴的对齐方式 align-items: center; 4.子元素 设定宽度，最大宽度 实用性：PC端ie9+ 移动端常用，写起来简洁明了 */ .layout3.parent&#123; display:flex; align-items: center; flex-direction: column; &#125; .layout3 .header,.layout3 .banner,.layout3 .footer&#123; max-width: 960px; width: 100%; &#125; &lt;/style&gt; &lt;div class=&#x27;header&#x27;&gt;header&lt;/div&gt; &lt;div class=&#x27;banner&#x27;&gt; &lt;p&gt;flexbox&lt;/p&gt; &lt;p&gt;1.父元素display:flex; &lt;/p&gt; &lt;p&gt;2.父元素 设定 子元素 排列方向 flex-direction: column;&lt;/p&gt; &lt;p&gt;3.父元素 设定 子元素 根据交叉轴的对齐方式 align-items: center;&lt;/p&gt; &lt;p&gt;4.子元素 设定宽度，最大宽度&lt;/p&gt; &lt;p&gt;实用性：PC端ie9+ 移动端常用，写起来简洁明了&lt;/p&gt; &lt;/div&gt; &lt;div class=&#x27;footer&#x27;&gt;footer&lt;/div&gt; &lt;/div&gt; 效果 双栏布局1234567891011121314151617181920&lt;!--公共样式--&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; .left&#123; background-color: rgba(0, 0, 0, 0.1); width: 200px; &#125; .right&#123; background-color: rgba(0, 0, 0, 0.2); &#125; .parent&#123; margin-bottom: 30px; background: #c6ffdd; /* fallback for old browsers */ background: -webkit-linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* Chrome 10-25, Safari 5.1-6 */ background: linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */ &#125;&lt;/style&gt; margin + float代码实现1234567891011121314151617181920212223242526&lt;!-- 浮动+边距 --&gt;&lt;div class=&#x27;parent layout1&#x27;&gt; &lt;style&gt; /* float + margin 1.浮动左列 2.右列自适应，且设置margin-left 实用性：兼容性好，但是浮动后超出无法顶开父容器高度 */ .layout1 .left&#123; float:left; &#125; .layout1 .right&#123; margin-left: 200px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;float + margin&lt;/p&gt; &lt;p&gt;1.浮动左列&lt;/p&gt; &lt;p&gt;2.右列自适应，且设置margin-left&lt;/p&gt; &lt;p&gt;实用性：兼容性好，但是浮动后超出无法顶开父容器高度&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 float代码实现1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 全浮动 --&gt;&lt;div class=&#x27;parent layout2&#x27;&gt; &lt;style&gt; /* float + margin 1.浮动左列 2.右列自适应, 右列负margin-left 3.右列子元素正margin-left 实用性：兼容性虽好，但是相当麻烦的方案，从布局角度看 右列 部分超到了 左列 部分，还额外需要一个子元素，父元素由于两个子元素都浮动，高度彻底塌陷，还额外需要清除浮动 */ .layout2 .left&#123; float:left; &#125; .layout2 .right&#123; width: 100%; float: right; margin-left: -200px; &#125; .layout2 .right-box&#123; margin-left: 200px; &#125; .layout2&#123; height: 120px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;right-box&quot;&gt; &lt;p&gt;float + margin&lt;/p&gt; &lt;p&gt;1.浮动左列 &lt;/p&gt; &lt;p&gt;2.右列自适应, 右列负margin-left&lt;/p&gt; &lt;p&gt;3.右列子元素正margin-left&lt;/p&gt; &lt;p&gt;实用性：兼容性虽好，但是相当麻烦的方案，从布局角度看 右列 部分超到了 左列 部分，还额外需要一个子元素，父元素由于两个子元素都浮动，高度彻底塌陷，还额外需要清除浮动&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果 float + overflow代码实现123456789101112131415161718192021222324252627282930313233343536&lt;!-- 浮动 overflow 触发BFC --&gt;&lt;div class=&#x27;parent layout3&#x27;&gt; &lt;style&gt; /* float + overflow 1.浮动左列，左列指定宽度 2.右列overflow: hidden, 触发右列 BFC 模式 3.父元素 overflow 之后，触发 BFC 模式，浮动后仍然可以撑开父容器高度 实用性：兼容性好，较为常用的实现方式，基本没什么后遗症 */ .layout3&#123; overflow: hidden; &#125; .layout3 .left&#123; float:left; &#125; .layout3 .right&#123; overflow: hidden; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;p&gt;left&lt;/p&gt; &lt;p&gt;left&lt;/p&gt; &lt;p&gt;left&lt;/p&gt; &lt;p&gt;left&lt;/p&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;float + overflow&lt;/p&gt; &lt;p&gt;1.浮动左列，左列指定宽度&lt;/p&gt; &lt;p&gt;2.右列overflow: hidden, 触发右列 BFC 模式&lt;/p&gt; &lt;p&gt;3.父元素 overflow 之后，触发 BFC 模式，浮动后仍然可以撑开父容器高度&lt;/p&gt; &lt;p&gt;实用性：兼容性好，较为常用的实现方式，基本没什么后遗症&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 表格布局代码实现123456789101112131415161718192021222324252627282930&lt;!-- 表格 --&gt;&lt;div class=&#x27;parent layout4&#x27;&gt; &lt;style&gt; /* 表格布局 1.父元素设置 display:table; table-layout:fixed; 设置宽度 2.子元素设置 table-cell 3.左列设置宽度 实用性，不需要用到浮动，高度不会塌陷，且可以实现双边等高布局，但是也只会是等高布局，无法设置左右列边距 */ .layout4 .parent&#123; display: table; table-layout: fixed; width: 100%; &#125; .layout4 .right,.layout4 .left&#123; display: table-cell; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;表格布局&lt;/p&gt; &lt;p&gt;1.父元素设置 display:table; table-layout:fixed; 设置宽度&lt;/p&gt; &lt;p&gt;2.子元素设置 table-cell&lt;/p&gt; &lt;p&gt;3.左列设置宽度&lt;/p&gt; &lt;p&gt;实用性：不需要用到浮动，高度不会塌陷，且可以实现双边等高布局，但是也只会是等高布局，无法设置左右列边距&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 flexbox布局代码实现123456789101112131415161718192021222324252627282930&lt;!-- flexbox --&gt;&lt;div class=&#x27;parent layout5&#x27;&gt; &lt;style&gt; /* flexbox 1.父元素 display:flex 2.左列设置宽度，右列flex:1 3.右列flex:1 4.align-items: start; 设置为 start 就不撑满 实用性：PC端IE9+，简洁明了的布局方式，可以通过控制 align-items 实现等高或者不等高。 */ .layout5.parent&#123; display: flex; &#125; .layout5 .right&#123; flex:1; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;flexbox&lt;/p&gt; &lt;p&gt;1.父元素 display:flex&lt;/p&gt; &lt;p&gt;2.左列设置宽度，右列flex:1&lt;/p&gt; &lt;p&gt;3.右列flex:1&lt;/p&gt; &lt;p&gt;4.align-items: start; 设置为 start 就不撑满&lt;/p&gt; &lt;p&gt;实用性：PC端IE9+，简洁明了的布局方式，可以通过控制 align-items 实现等高或者不等高。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 网格布局代码实现1234567891011121314151617181920212223242526&lt;!-- 网格布局 --&gt;&lt;div class=&#x27;parent layout6&#x27;&gt; &lt;style&gt; /* 网格布局 1.父元素 设置 display:grid 2.父元素 设置 grid-template-columns: 200px 1fr; 实现 左列100px 右列自适应 3.align-items: start; 设置为 start 就不撑满 实用性：更加简洁，高效的二维布局方式，但是兼容性 ie11+ 还是相对蛋疼 */ .parent.layout6&#123; display: grid; grid-template-columns: 200px 1fr; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;网格布局&lt;/p&gt; &lt;p&gt;1.父元素 设置 display:grid &lt;/p&gt; &lt;p&gt;2.父元素 设置 grid-template-columns: 200px 1fr; 实现 左列100px 右列自适应&lt;/p&gt; &lt;p&gt;3.align-items: start; 设置为 start 就不撑满&lt;/p&gt; &lt;p&gt;实用性：更加简洁，高效的二维布局方式，但是兼容性 ie11+ 还是相对蛋疼&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 三栏布局12345678910111213141516&lt;!-- 公共样式 --&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; .left,.right&#123; background-color: rgba(0, 0, 0, 0.1); &#125; .parent&#123; margin-bottom: 10px; background: #c6ffdd; /* fallback for old browsers */ background: -webkit-linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* Chrome 10-25, Safari 5.1-6 */ background: linear-gradient(to right, #c6ffdd, #fbd786, #f7797d); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */ &#125; &lt;/style&gt; 圣杯布局代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 圣杯布局 --&gt;&lt;div class=&quot;parent layout1&quot;&gt; &lt;style&gt; /* 圣杯布局 两边固定宽度，中间自适应 1. 子元素都左浮动，父元素 padding 留出空间 2. 中间元素宽度100% 3. 左右元素相对定位 配合负边距 缺点: 如果center部分宽度效于left部分，会造成布局塌陷，旁边两列不能自动填充高度 */ .layout1.parent&#123; position: relative; padding-left: 100px; padding-right: 100px; &#125; .layout1 .left,.layout1 .right&#123; position: relative; height: 100px; width: 100px; &#125; .layout1 .center&#123; height: 300px; width:100%; &#125; .layout1 .left,.layout1 .right,.layout1 .center&#123; float: left; &#125; .layout1 .left&#123; left: -100px; margin-left: -100%; &#125; .layout1 .right&#123; right: -100px; margin-left: -100px; &#125; .layout1&#123; height: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;圣杯布局&lt;/p&gt; &lt;p&gt;两边固定宽度，中间自适应&lt;/p&gt; &lt;p&gt;1. 子元素都左浮动，父元素 padding 留出空间&lt;/p&gt; &lt;p&gt;2. 中间元素宽度100%&lt;/p&gt; &lt;p&gt;3. 左右元素相对定位 配合负边距&lt;/p&gt; &lt;p&gt;缺点: 如果center部分宽度效于left部分，会造成布局塌陷，旁边两列不能自动填充高度&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 缺陷 双飞翼布局代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 双飞翼布局 --&gt;&lt;div class=&quot;parent layout2&quot;&gt; &lt;style&gt; /* 双飞翼布局 圣杯布局的优化，实现内容和布局的分离 1.在圣杯布局的基础上 2.设定 parent 元素的最小宽度 3.center 元素再增加一个子元素来撑开双边 优点: 避免使用了无用的定位，由于父元素使用了 overflow 三个部分都能撑开高度 缺点: 增加了一个 inner 层 */ .layout2.parent&#123; min-width: 200px; overflow:hidden; &#125; .layout2 .left,.layout2 .right&#123; height: 100px; width: 100px; &#125; .layout2 .center&#123; width:100%; height: 300px; &#125; .layout2 .left,.layout2 .right,.layout2 .center&#123; float: left; &#125; .layout2 .center .inner&#123; margin: 0 100px; &#125; .layout2 .left&#123; margin-left: -100%; &#125; .layout2 .right&#123; margin-left: -100px; &#125; &lt;/style&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;p&gt;双飞翼布局&lt;/p&gt; &lt;p&gt;圣杯布局的优化，实现内容和布局的分离&lt;/p&gt; &lt;p&gt;1.在圣杯布局的基础上&lt;/p&gt; &lt;p&gt;2.设定 parent 元素的最小宽度&lt;/p&gt; &lt;p&gt;3.center 元素再增加一个子元素来撑开双边&lt;/p&gt; &lt;p&gt;优点: 避免使用了无用的定位，由于父元素使用了 overflow 三个部分都能撑开高度&lt;/p&gt; &lt;p&gt;缺点: 增加了一个 inner 层&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 表格布局代码实现1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 表格布局 --&gt;&lt;div class=&quot;parent layout3&quot;&gt; &lt;style&gt; /* 表格布局 1.父元素 diplay:table 2.子元素 display: table-cell 3.左右两边设置宽度，中间元素不设置宽度 优点: 实现等高布局，兼容性很好,如果需要兼容flex不能用的情况，优先考虑此种实现 缺点: 无法设置栏边距，等高布局无法改变，对SEO不友好 */ .layout3.parent&#123; display: table; height: 150px; width: 100%; &#125; .layout3 .left,.layout3 .right,.layout3 .center&#123; display: table-cell; &#125; .layout3 .left,.layout3 .right&#123; width: 100px; &#125; .layout3 .center&#123; height: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;表格布局&lt;/p&gt; &lt;p&gt;1.父元素 diplay:table&lt;/p&gt; &lt;p&gt;2.子元素 display: table-cell&lt;/p&gt; &lt;p&gt;3.左右两边设置宽度，中间元素不设置宽度&lt;/p&gt; &lt;p&gt;优点: 实现等高布局，兼容性很好,如果需要兼容flex不能用的情况，优先考虑此种实现&lt;/p&gt; &lt;p&gt;缺点: 无法设置栏边距，等高布局无法改变，对SEO不友好&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 flexbox 布局代码实现123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- flexbox --&gt;&lt;div class=&quot;parent layout4&quot;&gt; &lt;style&gt; /* flexbox布局 1.父元素 diplay:flex 2.左右两边 设置宽度 3.中间元素 flex: 1 4.父元素 align-items: stretch(填满)/start/end/center;控制是否填满等高 优点：书写方便简洁，可以等高也可以不等高，基本就是一个属性设置的区别，移动端常用 缺点：PC端IE10才开始支持 */ .layout4.parent&#123; display: flex; &#125; .layout4 .left,.layout4 .right&#123; width: 100px; &#125; .layout4 .center&#123; flex: 1; height: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;flexbox布局&lt;/p&gt; &lt;p&gt;1.父元素 diplay:flex&lt;/p&gt; &lt;p&gt;2.左右两边 设置宽度&lt;/p&gt; &lt;p&gt;3.中间元素 flex: 1&lt;/p&gt; &lt;p&gt;4.父元素 align-items: stretch(填满)/start/end/center;控制是否填满等高&lt;/p&gt; &lt;p&gt;优点：书写方便简洁，可以等高也可以不等高，基本就是一个属性设置的区别，移动端常用&lt;/p&gt; &lt;p&gt;缺点：PC端IE10才开始支持&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果 网格布局代码实现12345678910111213141516171819202122232425262728293031323334&lt;!-- 网格布局 --&gt;&lt;div class=&quot;parent layout5&quot;&gt; &lt;style&gt; /* 网格布局 1.父元素diplay:grid 2.父元素设置 grid-template-columns 3.align-items: stretch(填满)/start/end/center;控制是否填满等高 优点：布局强大，二维布局能力出色，可以玩出很多骚操作。未来最流弊的布局方案了 缺点：ie 谷歌一条街，打听打听谁是爹 */ .layout5.parent&#123; display: grid; grid-template-columns: 100px 1fr 100px; &#125; .layout5 .center&#123; height: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;网格布局&lt;/p&gt; &lt;p&gt;1.父元素diplay:grid&lt;/p&gt; &lt;p&gt;2.父元素设置 grid-template-columns&lt;/p&gt; &lt;p&gt;3.align-items: stretch(填满)/start/end/center;控制是否填满等高&lt;/p&gt; &lt;p&gt;优点：布局强大，二维布局能力出色，可以玩出很多骚操作。未来最流弊的布局方案了&lt;/p&gt; &lt;p&gt;缺点：ie 谷歌一条街，打听打听谁是爹&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://luoyuda.github.io/tags/CSS/"}]},{"title":"模拟 Array 原型上的方法","slug":"Array/array-01","date":"2019-04-13T11:23:00.000Z","updated":"2019-04-13T11:23:00.000Z","comments":true,"path":"2019/04/13/Array/array-01/","link":"","permalink":"https://luoyuda.github.io/2019/04/13/Array/array-01/","excerpt":"","text":"Array.prototype.push1234567891011121314151617181920212223242526272829let arr = [1,2,3,4,5]let arrLike = &#123;0:1,1:2,length:2&#125;let obj = &#123;&#125;/** * Array.prototype.push(element1,...,elementN) * 向数组末尾添加N个元素并且返回数组长度 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push * push 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时， * 可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。 * 如果 length 不能被转成一个数值，则插入的元素索引为 0， * 包括 length 不存在时。当 length 不存在时，将会创建它。 */Array.prototype.myPush = function() &#123; var length = this.length ? this.length : (this.length = 0) &amp;&amp; 0 var index = 0 while (index &lt; arguments.length) &#123; this[length] = arguments[index] ++index ++length &#125; this.length = length return this.length&#125;arr.myPush(1,2,3,4)Array.prototype.myPush.call(obj,1,2,&#123;&#125;) Array.prototype.myPush.call(arrLike,3,4,&#123;&#125;)console.log(arr)console.log(obj)console.log(arrLike) Array.prototype.pop1234567891011121314151617181920/** * Array.prototype.pop() * 向数组末尾删除元素并且返回该元素 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop * 从数组中删除的元素(当数组为空时返回undefined) * pop 方法有意具有通用性。该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上。 * pop方法根据 length属性来确定最后一个元素的位置。 * 如果不包含length属性或length属性不能被转成一个数值，会将length置为0，并返回undefined。 */Array.prototype.myPop = function () &#123; var length = this.length ? this.length : (this.length = 0) &amp;&amp; 0 if(length === 0)return var last = this[length-1] delete this[length - 1] --this.length return last&#125;console.log(Array.prototype.myPop.call(arr))console.log(Array.prototype.myPop.call(arrLike))console.log(arr,obj,arrLike) Array.prototype.shift1234567891011121314151617181920212223242526/** * Array.prototype.shift() * 向数组索引为0的位置删除元素并且返回该元素 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift * shift 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素， * 其他元素的索引值随之减 1。如果 length 属性的值为 0 (长度为 0)，则返回 undefined。 * shift 方法并不局限于数组：这个方法能够通过 call 或 apply 方法作用于类似数组的对象上。 * 但是对于没有 length 属性（从0开始的一系列连续的数字属性的最后一个）的对象，调用该方法可能没有任何意义。 * */ Array.prototype.myShift = function()&#123; var length = this.length ? this.length : 0 if(length === 0)return var first = this[0] var index = 1 while (index &lt; this.length) &#123; this[index - 1] = this[index] index ++ &#125; delete this[length - 1] --this.length return first&#125;console.log(arr.myShift())console.log(Array.prototype.myShift.call(obj))console.log(Array.prototype.myShift.call(arrLike)) Array.prototype.unshift1234567891011121314151617181920212223242526272829/** * Array.prototype.unshift(element1,...,elementN) * 向数组索引为0的位置插入N个元素并且返回该数组长度 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift * unshift 方法会在调用它的类数组对象的开始位置插入给定的参数。 * unshift 特意被设计成具有通用性；这个方法能够通过 call 或 apply 方法作用于类数组对象上。 * 不过对于没有 length 属性（代表从0开始的一系列连续的数字属性的最后一个）的对象，调用该方法可能没有任何意义。 * */ Array.prototype.myUnshift = function() &#123; if(!this.length)return var length = this.length var arglength = arguments.length this.length = length + arglength var index = length - 1 while (index &gt;= 0) &#123; this[index + arglength] = this[index] --index &#125; index = arglength - 1 while (index &gt;= 0) &#123; this[index] = arguments[index] --index &#125; return this.length&#125;console.log(arr.myUnshift(0,1,3,4,5))console.log(Array.prototype.myUnshift.call(obj,0,1,3,4,5))console.log(Array.prototype.myUnshift.call(arrLike,0,1,3,4,5)) Array.prototype.slice123456789101112131415161718192021222324252627282930313233/** * Array.prototype.slice(begin,end) * 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice * slice 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： * 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。 * 两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 * 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。 * 在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 * */ Array.prototype.mySlice = function(begin,end) &#123; if(!this.length)return var arr = [] var index = 0 begin = typeof begin === &#x27;number&#x27; ? begin &lt; 0 ? this.length + begin : begin : 0 end = typeof end === &#x27;number&#x27; ? end &gt; this.length ? this.length : end : this.length while (begin &lt; end) &#123; arr[index] = this[begin] begin++ index++ &#125; return arr&#125;console.log(arr.mySlice(-4))console.log(Array.prototype.mySlice.call(obj,0,2))console.log(Array.prototype.mySlice.call(arrLike,0,1)) Array.prototype.concat12345678910111213141516171819202122232425262728293031323334353637383940/** * Array.prototype.concat(item1,...,itemN) * 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat * concat方法创建一个新的数组，它由被调用的对象中的元素组成， * 每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。 * concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝 * */ Array.prototype.myConcat = function() &#123; if(!arguments.length)return var arr = [] var index = 0 while (index&lt;this.length) &#123; arr[index] = this[index] ++index &#125; var i = 0 while (i &lt; arguments.length) &#123; var el = arguments[i] if(el instanceof Array) &#123; if(el.length)&#123; var j = 0 while (j &lt; el.length) &#123; arr[index] = el[j] ++index ++j &#125; &#125; &#125;else&#123; arr[index] = el ++index &#125; ++i &#125; return arr&#125;console.log(arr.myConcat(1,[2,3],[4,[5,[6],[7]]]))console.log(arr.concat(1,[2,3],[4,[5,[6],[7]]]))console.log(arr) Array.prototype.splice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Array.prototype.splice(start,deleteCount,item1,...,itemN) * 方法通过删除或替换现有元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice * 如果添加进数组的元素个数不等于被删除的元素个数，数组的长度会发生相应的改变。 * */ Array.prototype.mySplice = function(start,deleteCount) &#123; if(!this.length)return var arr = [] /** * 如果超出了数组的长度，则从数组末尾开始添加内容； * 如果是负值，则表示从数组末位开始的第几位（从-1计数）； * 如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 */ start = typeof start === &#x27;number&#x27; ? start &gt; this.length ? this.length : start &lt; 0 ? this.length + start &lt; 0 ? 0 : this.length + start : start : 0 /** * 如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 * 如果 deleteCount 被省略，则其相当于 array.length - start。 * 如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。 * 如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 */ deleteCount = typeof deleteCount === &#x27;number&#x27; ? deleteCount &lt; 0 ? 0 : deleteCount &gt; this.length - start ? this.length - start : deleteCount : deleteCount === undefined ? this.length - start : 0 //取出除去前两个参数之后的剩余参数 var args = arguments.length &gt; 2 ? Array.prototype.mySlice.call(arguments,2) : [] var argLength = args.length //记录一下开始位置 var oIndex = start //需要新增或者缩减的数目 var moveLength = argLength - deleteCount //需要删除到指定的下标 var delIndex = deleteCount + start //新增到指定的下表 var addIndex = argLength + start var index = 0 //删除 [...start, ... ,delIndex,...] while (start &lt; delIndex) &#123; arr[index] = this[start] this[start] = null ++start ++index &#125; if(moveLength &gt; 0)&#123; //数组不足以插入的时候,开辟新的位置 var i = this.length - 1 this.length += moveLength while (i &gt;= oIndex) &#123; this[i+moveLength] = this[i] --i &#125; &#125;else&#123; //插入后还有剩余,需要回缩空间 var i = this.length if(start &lt; this.length)&#123; while (start &lt; i) &#123; this[start+moveLength] = this[start] ++start &#125; &#125; this.length += moveLength &#125; var i = 0 // 插入新的 item1...itemN while (oIndex &lt; addIndex) &#123; this[oIndex] = args[i] ++i ++oIndex &#125; return arr&#125;console.log(arrLike)console.log(Array.prototype.mySplice.call(arrLike,1,1))console.log(arrLike)console.log(arr.mySplice())console.log(arr) Array.prototype.reduce123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Array.prototype.reduce(callback,initialValue) * reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce * callback 执行数组中每个值的函数，包含四个参数： * accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 * currentValue: 数组中正在处理的元素。 * currentIndex可选: 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 * array可选: 调用reduce()的数组 * initialValue 可选 * 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 */Array.prototype.myReduce = function(callback)&#123; var arr = this.mySlice() var len = arr.length var index = 0 var initialValue if(arguments.length &gt;= 2)&#123; //如果有默认值取默认值 initialValue = arguments[1] &#125;else&#123; //如果没有默认值,取第一个有值的索引,处理稀疏数组,若第一项没有值的时候起始索引往后走 while (index &lt; len &amp;&amp; !(arr[index] in arr)) &#123; ++index &#125; if(index &gt;= len) return initialValue = arr[index++] &#125; while (index &lt; len) &#123; if(arr[index] in arr)&#123; //值存在才走进来 initialValue = callback.call(null, initialValue, arr[index], index, arr) &#125; ++index &#125; return initialValue&#125;var sum = [0,1,2,3,4].myReduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue;&#125;); // 10var sum = [, 1, ,3,,].myReduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue;&#125;); // 4 Array.prototype.reduceRight123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Array.prototype.reduceRight(callback,initialValue) * reduceRight() 方法对数组中的每个元素执行一个由您提供的reducer函数(降序执行)，将其结果汇总为单个返回值。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight * callback 执行数组中每个值的函数，包含四个参数： * accumulator: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 * currentValue: 数组中正在处理的元素。 * currentIndex可选: 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 * array可选: 调用reduceRight()的数组 * initialValue 可选 * 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduceRight 将报错。 */Array.prototype.myReduceRight = function(callback)&#123; var arr = this.mySlice() var len = arr.length-1 var index = len var initialValue if(arguments.length &gt;= 2)&#123; //如果有默认值取默认值 initialValue = arguments[1] &#125;else&#123; //如果没有默认值,取第一个有值的索引,处理稀疏数组,若最后一项项没有值的时候起始索引往前走 while (index &gt;= 0 &amp;&amp; !(arr[index] in arr)) &#123; --index &#125; if(index &lt;= 0) return initialValue = arr[index--] &#125; while (index &gt;= 0) &#123; if(arr[index] in arr)&#123; //值存在才走进来 initialValue = callback.call(null, initialValue, arr[index], index, arr) &#125; index-- &#125; return initialValue&#125;var sum = [0,1,2,3,4].myReduceRight(function(accumulator, currentValue, currentIndex, array)&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue;&#125;,2); // 12var sum = [, 1, ,3,,].myReduceRight(function(accumulator, currentValue, currentIndex, array)&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue;&#125;,2); // 6 Array.prototype.forEach1234567891011121314151617181920212223242526272829/** * Array.prototype.forEach(callback,context) * forEach() 方法对数组的每个元素执行一次提供的函数。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback map 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.myForEach = function(callback)&#123; var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; callback.call(context, this[index], index, this) index++ &#125;&#125;[1,2,3,4,5].forEach(function(current, index, arr) &#123; console.log(current, index, arr, this.a)&#125;,&#123;a:1&#125;)[1,2,3,4,5].myForEach(function(current, index, arr)&#123; console.log(current, index, arr, this.a)&#125;,&#123;a:1&#125;) Array.prototype.map123456789101112131415161718192021222324252627282930313233/** * Array.prototype.map(callback,context) * map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback map 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.myMap = function(callback)&#123; var arr = [] var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; arr.myPush(callback.call(context, this[index], index, this)) index++ &#125; return arr&#125;console.log([1,2,3,4,5].map(function(current, index, arr) &#123; console.log(current, index, arr) return index + this.a&#125;,&#123;a:1&#125;)) //[1,2,3,4,5]console.log([1,2,3,4,5].myMap(function(current, index, arr) &#123; console.log(current, index, arr) return index + this.a&#125;,&#123;a:1&#125;)) //[1,2,3,4,5] Array.prototype.filter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Array.prototype.filter(callback,context) * filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback filter 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.myFilter = function(callback)&#123; var arr = [] var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; var el = this[index] callback.call(context, el, index, this) &amp;&amp; arr.myPush(el) index++ &#125; return arr&#125;console.log([1,2,3,4,5].filter(function(current, index, arr) &#123; console.log(current, index, arr) return index &gt; this.a&#125;,&#123;a:1&#125;))console.log([1,2,3,4,5].myFilter(function(current, index, arr) &#123; console.log(current, index, arr) return index &gt; this.a&#125;,&#123;a:1&#125;))/** * Array.prototype.filter(callback,context) * filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback filter 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.myFilter = function(callback)&#123; var arr = [] var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; var el = this[index] callback.call(context, el, index, this) &amp;&amp; arr.myPush(el) index++ &#125; return arr&#125;console.log([1,2,3,4,5].filter(function(current, index, arr) &#123; console.log(current, index, arr) return index &gt; this.a&#125;,&#123;a:1&#125;))//[3,4,5]console.log([1,2,3,4,5].myFilter(function(current, index, arr) &#123; console.log(current, index, arr) return index &gt; this.a&#125;,&#123;a:1&#125;))//[3,4,5] Array.prototype.every123456789101112131415161718192021222324252627282930313233343536/** * Array.prototype.every(callback,context) * every() 方法测试数组的所有元素是否都通过了指定函数的测试。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback every 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.myEvery = function(callback)&#123; var every = true var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; if(!callback.call(context, this[index], index, this)) &#123; every = false break &#125; index++ &#125; return every&#125;console.log([1,2,3,4,5].every(function(current, index, arr) &#123; console.log(current, index, arr) return current &gt; this.a&#125;,&#123;a:0&#125;)) // trueconsole.log([1,2,3,4,5].myEvery(function(current, index, arr) &#123; console.log(current, index, arr) return current &gt; this.a&#125;,&#123;a:0&#125;)) // true Array.prototype.some123456789101112131415161718192021222324252627282930313233343536/** * Array.prototype.some(callback,context) * some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some * callback 生成新数组元素的函数，使用三个参数： * currentValue * callback 数组中正在处理的当前元素。 * index可选 * callback 数组中正在处理的当前元素的索引。 * array可选 * callback some 方法被调用的数组。 * thisArg可选 * 执行 callback 函数时使用的this 值。 */Array.prototype.mySome = function(callback)&#123; var every = false var len = this.length var index = 0 var context = arguments[1] || this while (index &lt; len) &#123; if(callback.call(context, this[index], index, this)) &#123; every = true break &#125; index++ &#125; return every&#125;console.log([1,2,3,4,5].some(function(current, index, arr) &#123; console.log(current, index, arr) return current &gt; this.a&#125;,&#123;a:10&#125;)) // falseconsole.log([1,2,3,4,5].mySome(function(current, index, arr) &#123; console.log(current, index, arr) return current &gt; this.a&#125;,&#123;a:10&#125;)) // false Array.prototype.find12345678910111213141516171819202122232425262728293031/** * arr.find(callback[, thisArg]) 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find * callback * 在数组每一项上执行的函数，接收 3 个参数： * element * 当前遍历到的元素。 * index可选 * 当前遍历到的索引。 * array可选 * 数组本身。 * thisArg可选 * 执行回调时用作this 的对象。*/Array.prototype.myFind = function(callback,context) &#123; context = context || window var len = this.length var i = 0 while (i &lt; len) &#123; if(callback.call(context,this[i],i,this)) return this[i] i++ &#125; return undefined&#125;console.log([4, 6, 8, 12].myFind(function(item) &#123; return item + this.a &gt; 10&#125;,&#123;a:5&#125;)); // 6console.log([4, 6, 8, 12].find(function(item) &#123; return item + this.a &gt; 10&#125;,&#123;a:5&#125;)); // 6 Array.prototype.findIndex12345678910111213141516171819202122232425262728293031/** * arr.findIndex(callback[, thisArg]) 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex * callback * 在数组每一项上执行的函数，接收 3 个参数： * element * 当前遍历到的元素。 * index可选 * 当前遍历到的索引。 * array可选 * 数组本身。 * thisArg可选 * 执行回调时用作this 的对象。*/Array.prototype.myFindIndex = function(callback,context) &#123; context = context || window var len = this.length var i = 0 while (i &lt; len) &#123; if(callback.call(context,this[i],i,this)) return i i++ &#125; return -1&#125;console.log([4, 6, 8, 12].myFindIndex(function(item) &#123; return item + this.a &gt; 10&#125;,&#123;a:5&#125;)); // 1console.log([4, 6, 8, 12].findIndex(function(item) &#123; return item + this.a &gt; 10&#125;,&#123;a:5&#125;)); // 1 Array.prototype.join1234567891011121314151617181920212223/** * Array.prototype.join(separator) * join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join * separator * 指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。 * 如果省略()，数组元素用逗号分隔。默认为 &quot;,&quot;。如果separator是空字符串(&quot;&quot;)，则所有元素之间都没有任何字符。 */Array.prototype.myJoin = function(separator)&#123; var separator = typeof separator === &#x27;string&#x27; ? separator : &#x27;,&#x27; var len = this.length var str = &#x27;&#x27; if(!len) return str var index = 1 str = this[0] ? this[0].toString() : &#x27;&#x27; while (index &lt; len) &#123; str += separator + (this[index] ? this[index].toString() : &#x27;&#x27;) index++ &#125; return str&#125;console.log([1,null,,&#123;&#125;,[],/2/].myJoin(&#x27;,&#x27;) === [1,null,,&#123;&#125;,[],/2/].join(&#x27;,&#x27;)) //true Array.prototype.reverse1234567891011121314151617181920212223242526272829303132333435363738/** * Array.prototype.reverse() * reverse() 方法将数组中元素的位置颠倒,并返回该数组。该方法会改变原数组。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse * 方法颠倒数组中元素的位置，并返回该数组的引用。 */Array.prototype.myReverse = function()&#123; if(!this.length) return this var len = this.length - 1 var index = 0 var mid = Math.floor(this.length / 2) while (index &lt; mid) &#123; var lastIndex = len-index var tem = this[index] var last = this[lastIndex] var indexEmpty = !(index in this) var lastIndexEmpty = !(lastIndex in this) if(lastIndexEmpty)&#123; delete this[index] &#125;else&#123; this[index] = last &#125; if(indexEmpty)&#123; delete this[lastIndex] &#125;else&#123; this[len-index] = tem &#125; index++ &#125; return this&#125;var arr1 = [1,2,,3,,4,,5]var arr2 = [1,2,,3,,4,,5]arr1.myReverse()console.log(arr1) //[5, empty, 4, empty, 3, empty, 2, 1]arr2.reverse()console.log(arr2) //[5, empty, 4, empty, 3, empty, 2, 1] Array.prototype.sort12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * sort() 方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort * compareFunction 可选 * 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 * firstEl * 第一个用于比较的元素。 * secondEl * 第二个用于比较的元素。 *//** * 快排 * @param &#123;*&#125; arr 待排序数组 * @param &#123;*&#125; low 起点 * @param &#123;*&#125; high 终点 * @param &#123;*&#125; cb 比较函数 */function quickSort(arr,low,high,cb) &#123; if(low&lt;high)&#123; var mid = partition(arr,low,high,cb) quickSort(arr,low,mid-1,cb) quickSort(arr,mid+1,high,cb) &#125; return arr&#125;/** * 划分函数 */function partition(arr,low,high,cb) &#123; var poivt = arr[low] while (low&lt;high) &#123; while (low&lt;high &amp;&amp; cb(arr[high],poivt) &gt;= 0 ) &#123; high-- &#125; arr[low] = arr[high] while (low&lt;high &amp;&amp; cb(arr[low],poivt) &lt;= 0 ) &#123; low++ &#125; arr[high] = arr[low] &#125; arr[low] = poivt return low&#125;Array.prototype.mySort = function(cb) &#123; return quickSort(this,0,this.length-1,cb)&#125;var arr1 = [3,5,5,-1,65,6,41,2,51,11,52,8]var arr2 = [3,5,5,-1,65,6,41,2,51,11,52,8]function fcb(a,b) &#123; return a - b&#125;console.log(arr1.mySort(fcb)) //[-1, 2, 3, 5, 5, 6, 8, 11, 41, 51, 52, 65]console.log(arr2.sort(fcb)) //[-1, 2, 3, 5, 5, 6, 8, 11, 41, 51, 52, 65] Array.prototype.indexOf1234567891011121314151617181920212223242526272829303132333435363738/** * indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf * searchElement * 要查找的元素 * fromIndex * 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。 * 如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消， * 即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 * 注意： * 如果参数中提供的索引值是一个负值，并不改变其查找顺序， * 查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. */Array.prototype.myIndexOf = function(search,fromIndex)&#123; fromIndex = fromIndex ? typeof fromIndex === &#x27;number&#x27; ? fromIndex : typeof fromIndex === &#x27;string&#x27; ? (fromIndex-=0) &amp;&amp; fromIndex === fromIndex ? fromIndex : 0 : 0 : 0 var index = -1 var len = this.length var i = fromIndex &lt; 0 ? len + fromIndex : fromIndex while (i &lt; len) &#123; if(search == this[i])&#123; index = i break &#125; i++ &#125; return index&#125;console.log(arr1.myIndexOf(5,&#123;&#125;) == arr1.indexOf(5,&#123;&#125;)) //trueconsole.log(arr1.myIndexOf(5,[]) == arr1.indexOf(5,[])) //trueconsole.log(arr1.myIndexOf(5,[1]) == arr1.indexOf(5,[1])) //trueconsole.log(arr1.myIndexOf(5,&#x27;1&#x27;) == arr1.indexOf(5,&#x27;1&#x27;)) //trueconsole.log(arr1.myIndexOf(5,&#x27;1e&#x27;) == arr1.indexOf(5,&#x27;1e&#x27;)) //trueconsole.log(arr1.myIndexOf(5,true) == arr1.indexOf(5,true)) //trueconsole.log(arr1.myIndexOf(5,NaN) == arr1.indexOf(5,NaN)) //trueconsole.log(arr1.myIndexOf(5,-1) == arr1.indexOf(5,-1)) //trueconsole.log(arr1.myIndexOf(5,-5) == arr1.indexOf(5,-5)) //true Array.prototype.lastIndexOf1234567891011121314151617181920212223242526272829303132333435363738/** * lastIndexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf * searchElement * 要查找的元素 * fromIndex * 从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。 * 如果该值大于或等于数组的长度，则整个数组会被查找。 * 如果为负值，将其视为从数组末尾向前的偏移。 * 即使该值为负，数组仍然会被从后向前查找。 * 如果该值为负时，其绝对值大于数组长度，则方法返回 -1， * 即数组不会被查找。 */Array.prototype.myLastIndexOf = function(search,fromIndex)&#123; fromIndex = fromIndex ? typeof fromIndex === &#x27;number&#x27; ? fromIndex : (fromIndex-=0) &amp;&amp; fromIndex === fromIndex ? fromIndex : 0 : 0 var index = -1 var i = fromIndex &lt; 0 ? fromIndex + this.length &gt; 0 ? fromIndex + this.length : 0 : fromIndex &gt; this.length ? this.length : fromIndex while (i &gt; 0) &#123; if(search == this[i])&#123; index = i break &#125; i-- &#125; return index&#125;console.log(arr1.myLastIndexOf(5,&#123;&#125;) == arr1.lastIndexOf(5,&#123;&#125;)) //trueconsole.log(arr1.myLastIndexOf(5,[]) == arr1.lastIndexOf(5,[])) //trueconsole.log(arr1.myLastIndexOf(5,[1]) == arr1.lastIndexOf(5,[1])) //trueconsole.log(arr1.myLastIndexOf(5,&#x27;1&#x27;) == arr1.lastIndexOf(5,&#x27;1&#x27;)) //trueconsole.log(arr1.myLastIndexOf(5,&#x27;1e&#x27;) == arr1.lastIndexOf(5,&#x27;1e&#x27;)) //trueconsole.log(arr1.myLastIndexOf(5,true) == arr1.lastIndexOf(5,true)) //trueconsole.log(arr1.myLastIndexOf(5,NaN) == arr1.lastIndexOf(5,NaN)) //trueconsole.log(arr1.myLastIndexOf(5,-1) == arr1.lastIndexOf(5,-1)) //trueconsole.log(arr1.myLastIndexOf(5,-5) == arr1.lastIndexOf(5,-5)) //true Array.prototype.from12345678910111213141516171819202122232425262728293031/** * Array.from(arrayLike[, mapFn[, thisArg]]) 从一个类似数组或可迭代对象中创建一个新的数组实例。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from * arrayLike * 想要转换成数组的伪数组对象或可迭代对象。 * mapFn (可选参数) * 如果指定了该参数，新数组中的每个元素会执行该回调函数。 * thisArg (可选参数) * 可选参数，执行回调函数 mapFn 时 this 对象。 */Array.prototype.myFrom = function(arrayLike,mapFn,context) &#123; context = context || window mapFn = mapFn || function(item)&#123;return item&#125; var arr = [] if(arrayLike.forEach)&#123; arrayLike.forEach((value)=&gt;&#123; arr.push(mapFn.call(context,value)) &#125;) &#125;else&#123; var length = arrayLike.length var i = 0 while (i&lt;length) &#123; arr.push(mapFn.call(context,arrayLike[i])) i++ &#125; &#125; return arr&#125;console.log(Array.prototype.myFrom(arrLike))console.log(Array.prototype.myFrom(set))console.log(Array.prototype.myFrom(map)) Array.prototype.of12345678910111213141516171819202122/** * Array.of(element0[, element1[, ...[, elementN]]]) 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of * elementN * 任意个参数，将按顺序成为返回数组中的元素。 */Array.prototype.myOf = function() &#123; var len = arguments.length var arr =[] arr.length = len var i = 0 while (i &lt; len) &#123; arr[i] = arguments[i] i++ &#125; return arr // return Array.prototype.mySlice.call(arguments) // return Array.prototype.myFrom.call(null,arguments)&#125;console.log(Array.prototype.myOf(1,2,3))console.log(Array.prototype.myOf(undefined))console.log(Array.prototype.myOf(1)) Array.prototype.copyWithin12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Array.copyWithin(target[, start[, end]]) 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin * target * 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。 * 如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 * start * 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。 * 如果 start 被忽略，copyWithin 将会从0开始复制。 * end * 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 * 如果 end 被忽略，copyWithin 方法将会一直复制至数组结尾（默认为 arr.length）。 */Array.prototype.myCopyWithin = function(target,start,end) &#123; var len = this.length target = target &lt; 0 ? Math.abs(target) &gt; len ? len : len + target : target &gt; len ? len : target start = typeof start === &#x27;number&#x27; ? start &lt; 0 ? Math.abs(start) &gt; len ? len : len + start : start &gt; len ? len : start : 0 end = typeof end === &#x27;number&#x27; ? end &lt; 0 ? Math.abs(end) &gt; len ? len : len + end : end &gt; len ? len : end : len var oTarget = target var offset = end - start var arr = Array.prototype.mySlice.call(this) while (target &lt; len &amp;&amp; (target-oTarget) &lt; offset &amp;&amp; start &lt; end) &#123; if(!this[start])break this[target] = arr[start] start++ target++ &#125; return this&#125;console.log([1, 2, 3, 4, 5].myCopyWithin(-2)); // [1, 2, 3, 1, 2]console.log([1, 2, 3, 4, 5].copyWithin(-2)); // [1, 2, 3, 1, 2]console.log([1, 2, 3, 4, 5].myCopyWithin(0, 3)); // [4, 5, 3, 4, 5]console.log([1, 2, 3, 4, 5].copyWithin(0, 3)); // [4, 5, 3, 4, 5]console.log([1, 2, 3, 4, 5].myCopyWithin(0, 3, 4));// [4, 2, 3, 4, 2]console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4));// [4, 5, 3, 4, 5]console.log([1, 2, 3, 4, 5].myCopyWithin(-2, -3, -1)); // [1, 2, 3, 3, 4]console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1)); // [1, 2, 3, 3, 4]console.log([1, 2, 3, 4, 5].myCopyWithin(3, 2, 4)); // [1, 2, 3, 3, 4]console.log([1, 2, 3, 4, 5].copyWithin(3, 2, 4)); // [1, 2, 3, 3, 4]console.log([].myCopyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)); // &#123;0: 1, 3: 1, length: 5&#125;console.log([].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)); // &#123;0: 1, 3: 1, length: 5&#125;console.log([].myCopyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4));// Int32Array [4, 2, 3, 4, 5]console.log([].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4));// Int32Array [4, 2, 3, 4, 5] Array.prototype.fill123456789101112131415161718192021222324252627282930/** * Array.fill(callback[, thisArg]) 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill * value * 用来填充数组元素的值。 * start 可选 * 起始索引，默认值为0。 * end 可选 * 终止索引，默认值为 this.length。*/Array.prototype.myFill = function(value,start,end) &#123; var len = this.length start = typeof start === &#x27;number&#x27; ? start &lt; 0 ? Math.abs(start) &gt; len ? len : len + start : start &gt; len ? len : start : 0 end = typeof end === &#x27;number&#x27; ? end &lt; 0 ? Math.abs(end) &gt; len ? len : len + end : end &gt; len ? len : end : len while (start &lt; end) &#123; this[start] = value start++ &#125; return this&#125;console.log([1, 2, 3].myFill(4)) // [4, 4, 4]console.log([1, 2, 3].myFill(4, 1)) // [1, 4, 4]console.log([1, 2, 3].myFill(4, 1, 2)) // [1, 4, 3]console.log([1, 2, 3].myFill(4, 1, 1)) // [1, 2, 3]console.log([1, 2, 3].myFill(4, 3, 3)) // [1, 2, 3]console.log([1, 2, 3].myFill(4, -3, -2)) // [4, 2, 3]console.log([1, 2, 3].myFill(4, NaN, NaN)) // [1, 2, 3]console.log([1, 2, 3].myFill(4, 3, 5)) // [1, 2, 3]console.log(Array(3).myFill(4)) // [4, 4, 4]console.log(Array.prototype.myFill.call(&#123; length: 3 &#125;, 4)) // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; Array.prototype.includes12345678910111213141516171819202122232425/** * Array.prototype.includes(valueToFind[, fromIndex])方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes * valueToFind * 需要查找的元素值。 * fromIndex 可选 * 从fromIndex 索引处开始查找 valueToFind。默认为 0。 * 如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。*/Array.prototype.myIncludes = function(valueToFind,findIndex) &#123; var len = this.length findIndex = typeof findIndex === &#x27;number&#x27; ? findIndex &lt; 0 ? Math.abs(findIndex) &gt; len ? len : len + findIndex : findIndex &gt; len ? len : findIndex : 0 while (findIndex &lt; len) &#123; var now = this[findIndex] if(valueToFind === now)return true if(valueToFind !== valueToFind &amp;&amp; now !== now)return true findIndex++ &#125; return false&#125;console.log([1, 2, 3].myIncludes(2)) // trueconsole.log([1, 2, 3].myIncludes(4)) // falseconsole.log([1, 2, 3].myIncludes(3, 3)) // falseconsole.log([1, 2, 3].myIncludes(3, -1)) // trueconsole.log([1, 2, NaN].myIncludes(NaN)) // true Array.prototype.keys1234567891011121314151617181920212223242526272829303132333435363738394041/** * Array.prototype.keys()方法返回一个包含数组中每个索引键的Array Iterator对象。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys*/Array.prototype.myKeys = function() &#123; if(!typeof this === &#x27;object&#x27;)return var arr = null var length = this.length if(!length)&#123; arr = [] for (const key in this) &#123; if (this.hasOwnProperty(key)) &#123; arr.push(key) &#125; &#125; &#125; var len = this.length || arr.length var nextIndex = 0 return &#123; //[Symbol.iterator]需要在对象添加此属性，才是一个可被 for...of 遍历的对象 [Symbol.iterator]: function()&#123; return &#123; next:function()&#123; return nextIndex &lt; len ? &#123;value: length ? nextIndex++ : arr[nextIndex++], done:false&#125; : &#123;done:true&#125; &#125; &#125; &#125; &#125;&#125;var a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].myKeys()var b = Array.prototype.myKeys.call(&#123;0:1,1:2,length:2&#125;)var c = Array.prototype.myKeys.call(&#123;a:1,b:2&#125;)for (const value of a) &#123; console.log(value) // 0 1 2&#125;for (const value of b) &#123; console.log(value) // 0 1&#125;for (const value of c) &#123; console.log(value) // a b&#125; Array.prototype.values12345678910111213141516171819202122232425262728293031323334353637383940/** * Array.prototype.values()方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values*/Array.prototype.myValues = function() &#123; if(!typeof this === &#x27;object&#x27;)return var arr = this if(!this.length)&#123; arr = [] for (const key in this) &#123; if (this.hasOwnProperty(key)) &#123; arr.push(this[key]) &#125; &#125; &#125; var len = this.length || arr.length var nextIndex = 0 return &#123; //[Symbol.iterator]需要在对象添加此属性，才是一个可被 for...of 遍历的对象 [Symbol.iterator]: function()&#123; return &#123; next:function()&#123; return nextIndex &lt; len ? &#123;value: arr[nextIndex++], done:false&#125; : &#123;done:true&#125; &#125; &#125; &#125; &#125;&#125;var a = [&quot;a&quot;, &#x27;b&#x27;, &quot;c&quot;].myValues()var b = Array.prototype.myValues.call(&#123;0:1,1:2,length:2&#125;)var c = Array.prototype.myValues.call(&#123;a:1,b:2&#125;)for (const value of a) &#123; console.log(value) // a b c&#125;for (const value of b) &#123; console.log(value) // 1 2&#125;for (const value of c) &#123; console.log(value) // 1 2&#125; Array.prototype.entries12345678910111213141516171819202122232425262728/** * Array.prototype.entries()方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries*/Array.prototype.myEntries = function() &#123; if(!typeof this === &#x27;object&#x27;)return var arr = this var len = this.length || arr.length var nextIndex = 0 return &#123; //[Symbol.iterator]需要在对象添加此属性，才是一个可被 for...of 遍历的对象 [Symbol.iterator]: function()&#123; return &#123; next:function()&#123; return nextIndex &lt; len ? &#123;value:[nextIndex,arr[nextIndex++]], done:false&#125; : &#123;done:true&#125; &#125; &#125; &#125; &#125;&#125;var a = [&quot;a&quot;, &#x27;b&#x27;, &quot;c&quot;].myEntries()var b = Array.prototype.myEntries.call(&#123;0:1,1:2,length:2&#125;)for (const value of a) &#123; console.log(value) // [0,&quot;a&quot;] [0, &quot;b&quot;] [0, &quot;c&quot;]&#125;for (const value of b) &#123; console.log(value) // [0, 1] [0, 2]&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://luoyuda.github.io/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"}]},{"title":"从零开始的 webpack4","slug":"webpack/webpack-02","date":"2019-03-18T16:00:00.000Z","updated":"2019-03-18T16:00:00.000Z","comments":true,"path":"2019/03/18/webpack/webpack-02/","link":"","permalink":"https://luoyuda.github.io/2019/03/18/webpack/webpack-02/","excerpt":"","text":"鉴于自己 webpack 知识一过久了就忘记的尿性，今天闲来无事又敲一遍，顺便做个记录 github 链接先放！众所周知，webpack 以配置麻烦闻名于世，像我这种记忆力越来越差的人想起他就觉得头皮发麻 先连接好水管 创建文件夹 npm init -y 这个没啥好说… npm i -D webpack webpack-cli webpack-dev-server webpack4 之后需要单独安装多一个 webpack-cli webpack-dev-server 这个大佬是起一个本地服务器的，你懂我意思吧 创建一个 webpack.config.js 文件，用来写配置(对的，用来写你写完，一个月不写就会全部忘光光的配置！所以你到底零配置了什么…) 好了，我们的文件开写，先把几个神仙请出来 12345678module.exports = &#123; entry:&#x27;&#x27;, //入口 output:&#123;&#125;, //出口 module:&#123;&#125;, //处理对应模块 plugins:[], //对应插件 devServer:&#123;&#125;, //开发服务器设置 mode:&#x27;development&#x27; //模式配置&#125; entry 就是入口，它霸道的掌握了整个 webpack 的门口，什么神仙都是从这里进去的，你可以使用字符串语法或者对象语法来定义入口 123456789module.exports = &#123;//一般这么写 entry:&#x27;./src/index.js&#x27;, //单页面入口 entry:&#123; //多页面应用入口 index:&#x27;./src/index.js&#x27;, main:&#x27;./src/main.js&#x27; &#125;, ...&#125; output 则是 webpack 出口，对应入口来说，整个 webpack 过程你可以理解成人体消化系统，而入口进去的食物，总将会变成 X 输出，从 entry 通向 output module 是指 webpack 所处理的模块，比如 ES6、LESS\\SASS\\CSS、图片等在项目中的种种东西，需要对应的 loader 来对正则匹配的文件进行处理，如 转换 ES6 要用到 babel-loader 来处理 /\\.js$/ 的文件 loader 则是用于对模块的源代码进行转换的小工具。 plugin 插件存在的目的在于解决 loader 无法实现的其他事，比如可以用一些插件来对代码进行压缩 devServer 这个则是配置一个静态的服务器，它默认自动刷新。 mode 告知 webpack 使用相应环境的内置优化，一般是 development 或 production 5. 配一下执行文件先… 找到你的 package.json 然后写进去，写完你就可以快乐的在 cmd 里面快乐的 npm run xxx 然后我们创建一个 src 文件夹，创建个 index.js。就随便写句话吧 12//index.jsconsole.log(&#x27;webpack 配置简单&#x27;) 然后我们回到 webpack.config.js 将入口，出口配置好，然后 npm run build 一下，你就能看到文件夹中出现 dist 文件夹，里面有个 index.js 辣。就这样我们完成了第一次 webpack 之旅 123456789101112131415161718//webpack.config.jsconst path = require(&#x27;path&#x27;)module.exports = &#123; // entry:&#x27;&#x27;, //入口 entry:&#x27;./src/index.js&#x27;, //单页面入口 // entry:&#123; //多页面应用入口 // index:&#x27;./src/index.js&#x27;, // main:&#x27;./src/main.js&#x27; // &#125;, output:&#123; filename: &#x27;index.js&#x27;, // 打包后文件名 path: path.resolve(&#x27;dist&#x27;) // 打包后目录，需为绝对路径 &#125;, //出口 // module:&#123;&#125;, //处理对应模块 // plugins:[], //对应插件 // devServer:&#123;&#125;, //开发服务器设置 // mode:&#x27;development&#x27; //模式配置&#125; 到这里大家应该对webpack有了个小的了解，其实他就是条 ‘管道’ 我们将各种文件都交给他，最后他输出我们配置好的输出文件。 其实比较类似人体的消化系统…你给他吃各种食物，最后输出…你懂我意思吧 给管道添加各类处理程序webpack 的魅力在于它能处理开发项目中的一切你需要它处理的模块，只要你给他装了相应的模块配置，它就能给你干一切脏活累活。 html在打包 html 的时候，一般我们在实际开发中都会用一个 html 文件来做一切页面的入口，我们要来实现 html 的打包功能， 需要一个模板来实现，各种引用好路径的 html 。 这里就需要一个很常用的插件 html-webpack-plugin 来帮我们把 html 搞出来 装插件，先 npm 装一下 1npm i html-webpack-plugin -D 创建一个index.html 作为模板使用(当然你也可以不用模板) 接下来要往 webpack.config.js 管子里装设备了 123456789101112131415161718192021const path = require(&#x27;path&#x27;)//首先引入插件,插件是一个类,使用的时候需要先 new const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) module.exports = &#123; entry:&#x27;./src/index.js&#x27;, //单页面入口 output:&#123; filename: &#x27;index.js&#x27;, // 打包后文件名 path: path.resolve(&#x27;dist&#x27;) // 打包后目录，需为绝对路径 &#125;, //出口 // module:&#123;&#125;, //处理对应模块 plugins:[ new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 // title:&#x27;我被打包了&#x27;,// 不用 template 时候生效 // filename:&#x27;bundle.html&#x27;, // 换个文件名 &#125;) ], //对应插件 // devServer:&#123;&#125;, //开发服务器设置 // mode:&#x27;development&#x27; //模式配置&#125; 写完，打包，一气呵成。不出意外你会得到一个这样的文件 多页面开发配置123456789101112131415161718192021222324252627282930// webpack.config.jsconst path = require(&#x27;path&#x27;)//首先引入插件,插件是一个类,使用的时候需要先 new const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) module.exports = &#123; entry:&#123; index:&#x27;./src/index.js&#x27;, main:&#x27;./src/main.js&#x27;, &#125;, //多页面入口 output:&#123; filename: &#x27;[name].js&#x27;, // 打包后文件名 path: path.resolve(&#x27;dist&#x27;) // 打包后目录，需为绝对路径 &#125;, //出口 // module:&#123;&#125;, //处理对应模块 plugins:[ new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 filename:&#x27;index.html&#x27;, chunks:[&#x27;index&#x27;], //块 表示 你注入的 js &#125;), new HtmlWebpackPlugin(&#123; template:&#x27;./src/main.html&#x27;, // 打包目标模板 filename:&#x27;main.html&#x27;, chunks:[&#x27;main&#x27;], //块 表示 你注入的 js &#125;) ], //对应插件 // devServer:&#123;&#125;, //开发服务器设置 // mode:&#x27;development&#x27; //模式配置&#125; css处理完 html 我们接着来处理 css，处理 css 文件，则需要在配置文件中配置 module ，当然需要指定的 loader 来搭配一起辅助。 一般处理 css 模块的 loader 是这两个大佬 css-loader ： 很单纯的处理 css 的 loader style-loader ：将处理好的 css-loader 的样式代码 插入文件中 东西说完，我们开搞 装东西 1npm i css-loader style-loader -D 创建对应文件，写东西，代码引入 123//index.jsimport &#x27;./css/style-css.css&#x27;;console.log(&#x27;webpack 配置简单&#x27;) 1234/* style-css.css */body&#123; background-color: #000;&#125; 写配置 123456789101112131415161718// webpack.config.js...//首先引入插件,插件是一个类,使用的时候需要先 new const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; ... module:&#123; rules:[ &#123; test: /\\.css$/, //匹配查找 css 文件 use:[&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] //从右往左解析 style-loader ← css-loader &#125; ] &#125;, //处理对应模块 ...&#125; 打包查看效果这样子css就被打包进去js文件了，品如跟洪世贤在一起了，这显然不是我们想要的鸭。这时候就需要人来帮我们来挖墙脚。 分手大师我们现在要用一个插件来实现我们棒打鸳鸯的目的，这个插件可以是 mini-css-extract-plugin 或者 extract-text-webpack-plugin。 先说 mini-css-extract-pluginmini-css-extract-plugin这个插件据说是为了 webpack4 而生的，那我们就来跟跟潮流~ 先装 1npm i -D mini-css-extract-plugin 再写，这里的原理跟 html-webpack-plugin 是差不多的。将 style-loader 替换成 MiniCssExtractPlugin.loader ，然后在用插件生成文件。 1234567891011121314151617181920212223// webpack.config.js...const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)module.exports = &#123; ... module:&#123; rules:[ &#123; test: /\\.css$/, //匹配查找 css 文件 // use:[&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] //从右往左解析 style-loader ← css-loader use:[MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;] //从右往左解析 style-loader ← css-loader &#125; ] &#125;, //处理对应模块 plugins:[ ... new MiniCssExtractPlugin(&#123; filename:&#x27;css/[name].css&#x27; &#125;) ], //对应插件 ...&#125; 然后得到 extract-text-webpack-plugin extract-text-webpack-plugin 则是一直以来 webpack 分拆 js 喝 css 的一个插件 装 12//@next 版本支持 webpack4npm i -D extract-text-webpack-plugin@next 写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// webpack.config.js...const ExtractTextWebpackPlugin = require(&#x27;extract-text-webpack-plugin&#x27;)const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;)//需要装 cross-env 来做跨平台的兼容 // 将package.json 中的 scripts &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; // 这样代码就能知道我们是处于什么环境打包的const devMode = process.env.NODE_ENV !== &#x27;production&#x27; //判断是否生产环境const cssLoaders = [ &#x27;css-loader&#x27;]module.exports = &#123; ... module:&#123; rules:[ &#123; test: /\\.css$/, //匹配查找 css 文件 // use:[&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] //从右往左解析 style-loader ← css-loader // use:[ // // 这个插件暂时不支持 HMR ，开发环境中还是使用 style-loader // devMode ? &#x27;style-loader&#x27; : &#123; // loader:MiniCssExtractPlugin.loader, // options:&#123; // // 这里可以指定一个 publicPath // // 默认使用 webpackOptions.output中的publicPath // // publicPath:&#x27;&#x27; // &#125; // &#125;, // &#x27;css-loader&#x27; // ] //从右往左解析 MiniCssExtractPlugin.loader ← css-loader use: devMode ? [&#x27;style-loader&#x27;,...cssLoaders] : ExtractTextWebpackPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use:cssLoaders &#125;) &#125; ] &#125;, //处理对应模块 plugins:[ ... // 将所有的CSS提取到一个文件中 // new MiniCssExtractPlugin(&#123; // filename:&#x27;css/[name].css&#x27; // &#125;), new ExtractTextWebpackPlugin(&#123; filename:&#x27;css/[name].css&#x27; &#125;) ], //对应插件 ...&#125; 得到 其实两者用着感觉差别并不大，如果有需要分开打包 css 文件的话则后者更好用点，毕竟前者还未支持;前者用着更加简单舒服点 LESS 、SASS 、 postCss 这群小婊砸们怎么融入进来呢？LESS处理 LESS 文件，那必须是要使用 less 跟 less-loader 模块啦。什么，你难道觉得不需要咩 装 1npm i -D less less-loader 写，这里其实已经万变不离其宗了，需要注意的是 loader 解析方向 1234567891011121314151617181920212223242526272829// webpack.config.js...const cssLoaders = [ &#x27;css-loader&#x27;, &#x27;less-loader&#x27;]module.exports = &#123; ... module:&#123; rules:[ ... &#123; test: /\\.less$/, //匹配查找 css 文件 // use:[&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;] //从右往左解析 style-loader ← css-loader use:[ devMode ? &#x27;style-loader&#x27; : &#123; loader:MiniCssExtractPlugin.loader, options:&#123; &#125; &#125;, ...cssLoaders ] //从右往左解析 MiniCssExtractPlugin.loader ← css-loader ← less-loader &#125; ] &#125;, //处理对应模块 ...&#125; 得到 SASSSASS 文件的处理其实跟 LESS 差不太多，需要装 sass-loader 和 node-sass 来帮忙解析 装 1npm i -D sass-loader node-sass 写，其实跟 LESS 一个套路辣 1234567891011121314151617181920212223242526272829// webpack.config.js...const sassLoaders = [ &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;]module.exports = &#123; ... module:&#123; rules:[ ... &#123; test: /\\.scss$/, //匹配查找 scss 文件 // use:[&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] //从右往左解析 style-loader ← css-loader ← sass-loader use:[ devMode ? &#x27;style-loader&#x27; : &#123; loader:MiniCssExtractPlugin.loader, options:&#123; &#125; &#125;, ...sassLoaders ] //从右往左解析 MiniCssExtractPlugin.loader ← css-loader ← sass-loader &#125; ] &#125;, //处理对应模块 ...&#125; 得到 PostCSSPostCSS 是 一款使用插件转换 CSS 的工具，里面有很多实用的插件，比如 Autoprefixer 装 1npm i -D postcss-loader autoprefixer 写，先添加一个postcss.config.js，用来写 postcss-loader 的配置，也可以在 webpack.config.js 里面用对象方式写，不过一般是单独一个文件写，之后的配置需要注意的问题是 postcss-loader ，需要插在 css-loader 之前。 12345678//postcss.config.jsmodule.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;)(&#123; browsers: [&#x27;last 10 Chrome versions&#x27;, &#x27;last 5 Firefox versions&#x27;, &#x27;Safari &gt;= 6&#x27;, &#x27;ie&gt; 8&#x27;] &#125;) ] &#125; 123456789101112131415161718192021222324252627// webpack.config.jsconst sassLoaders = [ &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;,//需要插在css-loader之前 &#x27;sass-loader&#x27;]module.exports = &#123; ... module:&#123; rules:[ ... &#123; test: /\\.scss$/, //匹配查找 scss 文件 use:[ devMode ? &#x27;style-loader&#x27; : &#123; loader:MiniCssExtractPlugin.loader, options:&#123; &#125; &#125;, ...sassLoaders ] //从右往左解析 MiniCssExtractPlugin.loader ← css-loader ← postcss-loader ← sass-loader &#125; ] &#125;, ...&#125; 得到 到这里 CSS 模块的处理的差不多了，整理一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// webpack.config.jsconst path = require(&#x27;path&#x27;)//首先引入插件,插件是一个类,使用的时候需要先 new const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const ExtractTextWebpackPlugin = require(&#x27;extract-text-webpack-plugin&#x27;)const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;)//需要装 cross-env 来做跨平台的兼容 // 将package.json 中的 scripts &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; // 这样代码就能知道我们是处于什么环境打包的const devMode = process.env.NODE_ENV !== &#x27;production&#x27; //判断是否生产环境const styleLoader = &#x27;style-loader&#x27;const miniLoader = &#123; loader:MiniCssExtractPlugin.loader, options:&#123;&#125;&#125;// 这个插件暂时不支持 HMR ，开发环境中还是使用 style-loaderconst extractLoader = devMode ? styleLoader : miniLoaderconst cssLoader = &#x27;css-loader&#x27;const postcssLoader = &#x27;postcss-loader&#x27;const lessLoader = &#x27;less-loader&#x27;const sassLoader = &#x27;sass-loader&#x27;const cssLoaders = [ extractLoader, cssLoader, postcssLoader,]const lessLoaders = [ ...cssLoaders, lessLoader,]const sassLoaders = [ ...cssLoaders, sassLoader,]module.exports = &#123; entry:&#x27;./src/index.js&#x27;, //单页面入口 output:&#123; filename: &#x27;[name].js&#x27;, // 打包后文件名 path: path.resolve(&#x27;dist&#x27;) // 打包后目录，需为绝对路径 &#125;, //出口 module:&#123; rules:[ &#123; test: /\\.css$/, //匹配查找 css 文件 // style-loader/miniCss-loader ← css-loader ← postcss-loader use: cssLoaders &#125;, &#123; test: /\\.less$/, //匹配查找 less 文件 // style-loader/miniCss-loader ← css-loader ← postcss-loader ← less-loader use: lessLoaders &#125;, &#123; test: /\\.scss$/, //匹配查找 scss 文件 // style-loader/miniCss-loader ← css-loader ← postcss-loader ← sass-loader use:sassLoaders &#125; ] &#125;, //处理对应模块 plugins:[ new CleanWebpackPlugin(), //清理文件夹 new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 // title:&#x27;我被打包了&#x27;,// 不用 template 时候生效 // filename:&#x27;bundle.html&#x27;, // 换个文件名 &#125;), // 将所有的CSS提取到一个文件中 new MiniCssExtractPlugin(&#123; filename:&#x27;css/[name].css&#x27; &#125;), // new ExtractTextWebpackPlugin(&#123; // filename:&#x27;css/[name].css&#x27; // &#125;) ], //对应插件 // devServer:&#123;&#125;, //开发服务器设置 // mode:&#x27;development&#x27; //模式配置&#125; js现在来处理 js 辣，都 2019 年了，现在谁还不认识个 ES6 是的，低版本浏览器就不认识，所以这就需要一个很牛逼的东西来转义我们的ES6 成 ES5 那就是babel(爸爸)！ 装 1npm i babel-core babel-loader babel-preset-env babel-preset-stage-0 -D 写，这里我们需要写一个配置文件 .babelrc ，然后写下处理的对象 1234// .babelrc&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;] // 从右向左解析&#125; 1234567891011121314151617// webpack.config.js...module.exports = &#123; ... module:&#123; rules:[ ... &#123; test:/\\.js$/, use: &#x27;babel-loader&#x27;, include: /src/, // 只转化src目录下的js exclude: /node_modules/ // 排除掉node_modules，优化打包速度 &#125; ] &#125;, ...&#125; 这样配置完，我们就可以在项目里面写 ES6 代码了，webpack 会帮我们转义成 ES5 图片文件上面那些大佬已经被我们安排的明明白白的，目前还有个图片文件处理需要我们来肝。 处理图片需要用到 file-loader、url-loader 和 html-withimg-loader 装 1npm i file-loader url-loader html-withimg-loader -D 写，这里需要注意的是路径问题，需要在打包成文件的时候指定一下路径 12345678910111213141516171819202122232425262728293031323334353637// webpack.config.jsconst miniLoader = &#123; loader:MiniCssExtractPlugin.loader, options:&#123; publicPath: &#x27;../&#x27; &#125;&#125;...module.exports = &#123; ... module:&#123; rules:[ ... &#123; test:/\\.(jpe?g|png|gif)$/, use:[ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 8192, // 小于8k的图片自动转成base64格式，并且不会存在实体图片 outputPath: &#x27;images/&#x27; // 图片打包后存放的目录 &#125; &#125; ] &#125;, &#123; test: /\\.(htm|html)$/, use: &#x27;html-withimg-loader&#x27; // html里面所有的img链接 &#125;, &#123; test: /\\.(eot|ttf|woff|svg)$/, use: &#x27;file-loader&#x27; &#125; ] &#125;, ...&#125; 效果 雪碧图处理雪碧图用的 postcss-sprites 是基于 postcss-loader 的插件 装 1npm i -D postcss-sprites 写，这里需要一个 postcss-sprites-config.js 文件来写 postcss-sprites 的配置，也可以写在 postcss-config.js 里面。然后在 postcss-config.js 补上我们的配置，这样就能去合成雪碧图了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** postcss-sprites-config.js * 这里的项目结构是 * —src * ——icons * ———icons-@1x * ———— *.png * ———icons-@2x * ———— *.png * */ var postcss = require(&#x27;postcss&#x27;);// 合法的散列图path 查找 /src/icons/*/*.pngconst REG_SPRITES_PATH = /\\/icons\\/(.*?)\\/.*/i// 合法的retina标识 @*xconst REG_SPRITES_RETINA = /@(\\d+)x\\./i// splitconst SPLIT = trueconst SPLIT_REG = /\\?/igconst RETINA = trueconst OUTPUT_PATH = &quot;./dist/sptite&quot;module.exports = &#123; spritePath: OUTPUT_PATH, //过滤 除了 icons 以外 的图片链接 //需返回一个Promise对象 filterBy: (image)=&gt; &#123; return REG_SPRITES_PATH.test(image.url) ? Promise.resolve() : Promise.reject() &#125;, //分组 分出 1 / 2 / 3 / n倍 图 groupBy: (image) =&gt; &#123; let groups = null; let groupName = &#x27;&#x27;; let module = image.originalUrl.split(/\\?/) image.url = module[0] if(module.length &gt; 1)&#123; //分模块 ? 跟模块名 groupName = module[1] + &#x27;-&#x27; &#125; if (SPLIT) &#123; groups = REG_SPRITES_PATH.exec(image.url); groupName += groups ? groups[1] : &#x27;icons&#x27;; &#125; else &#123; groupName += &#x27;icons&#x27;; &#125; //处理多倍图的情况 if (RETINA) &#123; image.retina = RETINA; image.ratio = 1; let ratio = REG_SPRITES_RETINA.exec(image.url); if (ratio) &#123; ratio = ratio[1]; while (ratio &gt; 10) &#123; ratio = ratio / 10; &#125; image.ratio = ratio; image.groups = image.groups.filter((group) =&gt; &#123; return (&#x27;@&#x27; + ratio + &#x27;x&#x27;) !== group; &#125;); groupName += &#x27;@&#x27; + ratio + &#x27;x&#x27;; &#125; &#125; return Promise.resolve(groupName); &#125;, // 转换百分比定位 hooks: &#123; onUpdateRule: function(rule, token, image) &#123; var backgroundSizeX = (image.spriteWidth / image.coords.width) * 100; var backgroundSizeY = (image.spriteHeight / image.coords.height) * 100; var backgroundPositionX = (image.coords.x / (image.spriteWidth - image.coords.width)) * 100; var backgroundPositionY = (image.coords.y / (image.spriteHeight - image.coords.height)) * 100; backgroundSizeX = isNaN(backgroundSizeX) ? 0 : backgroundSizeX; backgroundSizeY = isNaN(backgroundSizeY) ? 0 : backgroundSizeY; backgroundPositionX = isNaN(backgroundPositionX) ? 0 : backgroundPositionX; backgroundPositionY = isNaN(backgroundPositionY) ? 0 : backgroundPositionY; var backgroundImage = postcss.decl(&#123; prop: &#x27;background-image&#x27;, value: &#x27;url(&#x27; + image.spriteUrl + &#x27;)&#x27; &#125;); var backgroundSize = postcss.decl(&#123; prop: &#x27;background-size&#x27;, value: backgroundSizeX + &#x27;% &#x27; + backgroundSizeY + &#x27;%&#x27; &#125;); var backgroundPosition = postcss.decl(&#123; prop: &#x27;background-position&#x27;, value: backgroundPositionX + &#x27;% &#x27; + backgroundPositionY + &#x27;%&#x27; &#125;); rule.insertAfter(token, backgroundImage); rule.insertAfter(backgroundImage, backgroundPosition); rule.insertAfter(backgroundPosition, backgroundSize); &#125; &#125;&#125; 1234567891011 //postcss-config.js module.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;)(&#123;browsers: [&#x27;last 10 Chrome versions&#x27;, &#x27;last 5 Firefox versions&#x27;, &#x27;Safari &gt;= 6&#x27;, &#x27;ie&gt; 8&#x27;] &#125;), require(&#x27;postcss-sprites&#x27;)( require(&#x27;./postcss-sprites.config&#x27;) ) ] &#125; 效果 静态服务器的开启webpack4 提供了一个devServer 的选项配合我们的服务器配置我们只需要在配置中写入 12345678910...devServer: &#123; contentBase: &#x27;./dist&#x27;, host: &#x27;localhost&#x27;, // 默认是localhost port: 3000, // 端口 open: true, // 自动打开浏览器 hot: true // 开启热更新 overlay: true, // 如果代码出错，会在浏览器页面弹出“浮动层”&#125; //开发服务器设置... 需要注意的是：需要在指定文件插入这行代码才会进行热更新 1234if (module.hot) &#123; // 实现热更新 module.hot.accept();&#125; 跨域处理以前我们本地开发跨域需要配置什么apache 什么转发什么的，但是在 webpack4 里面我们可以直接在配置开发服务器这里配一个跨域代理转发，这样岂不是更爽 12345678910111213devServer: &#123; ... proxy: &#123; // 跨域代理转发 &#x27;/api&#x27;: &#123; target: &#x27;https://xxx.xxx.com/xxx&#x27;, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;/&#x27; &#125;, changeOrigin: true, logLevel:&quot;debug&quot;, &#125; &#125;, ...&#125; 解析 resolvewebpack 提供了 resolve 选项供我们配置模块如何被解析。比如我们最常使用到的别名、省略后缀名 12345678910...resolve: &#123; // 别名 alias:&#123; main: path.join(__dirname, &#x27;src/main.js&#x27;) &#125;, //省略后缀名 extensions:[&#x27;.js&#x27;,&#x27;.json&#x27;,&#x27;.less&#x27;,&#x27;.scss&#x27;,&#x27;.css&#x27;]&#125;... 设置之后引入就可以变成这样子，简单来说就是更加快活了，不然你要陷入 ../../../../../ 的无限地狱 1234567891011//index.js//beforeimport &#x27;./css/style-css.css&#x27;;import &#x27;./less/style-less.less&#x27;;import &#x27;./scss/style-scss.scss&#x27;;import &#x27;main.js&#x27;//afterimport &#x27;./css/style-css&#x27;;import &#x27;./less/style-less&#x27;;import &#x27;./scss/style-scss&#x27;;import &#x27;main&#x27;; 多页面应用的提取公共代码和单页面应用懒加载提取公共代码在开发多页面应用的时候，难免要提取公共代码，在 webpack4 中可以通过配置 optimization 选项中的 splitChunks 来实现公共代码的提取。 我们先来准备一些文件。 123456789101112131415161718192021222324252627//utils.jsexport default &#x27;utils&#x27;//pageA-main.jsimport util from &#x27;./utils&#x27;export default &#x27;pageA-main-&#x27; + util//pageB-main.jsimport util from &#x27;./utils&#x27;export default &#x27;pageB-main-&#x27; + util//入口文件 pageA import pageA from &#x27;./pageA-main&#x27;import utils from &#x27;./utils&#x27;import * as _ from &#x27;lodash&#x27;;console.log(&#x27;pageA&#x27;)console.log(_.uniq([1,1,2,3,3]))console.log(pageA,utils)//入口文件 pageBimport pageA from &#x27;./pageA-main&#x27;import pageB from &#x27;./pageB-main&#x27;import * as _ from &#x27;lodash&#x27;;console.log(&#x27;pageB&#x27;)console.log(_.uniq([3,3,3,3,3]))console.log(pageA,pageB) 先写一个多页面的入口和出口 1234567891011... entry:&#123; pageA:&#x27;./src/pageA.js&#x27;, pageB:&#x27;./src/pageB.js&#x27; &#125;, //单页面入口 output:&#123; filename: &#x27;[name].js&#x27;, // 打包后文件名 path: path.resolve(&#x27;dist&#x27;), // 打包后目录，需为绝对路径 chunkFilename: &quot;[name].chunk.js&quot; &#125;, ... 然后我们配置 optimization 1234567891011121314151617181920212223... optimization:&#123; splitChunks:&#123; cacheGroups:&#123; vendor:&#123; // 抽离第三方插件 打包node_modules下的第三方包 test: /node_modules/, chunks:&#x27;initial&#x27;, // 打包后的文件名，任意命名 name:&#x27;vendor&#x27;, // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority:10 &#125;, utils:&#123; // 抽离自己写的公共代码 chunks:&#x27;initial&#x27;, name:&#x27;utils&#x27;, minSize:0 &#125; &#125; &#125; &#125;,... 这样配置完成之后其实就已经可以打包出分包的 js 文件了，当你需要输出的 html 中引用它们的时候，则需要在插件 html-webpack-plugin 中指定引用的块 1234567891011121314plugins:[ ... new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 filename:&#x27;pageA.html&#x27;, chunks:[&#x27;vendor&#x27;,&#x27;utils&#x27;,&#x27;pageA&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 filename:&#x27;pageB.html&#x27;, chunks:[&#x27;vendor&#x27;,&#x27;utils&#x27;,&#x27;pageB&#x27;] &#125;), ... ], 提取公共代码之前打包：提取公共代码之后打包： 懒加载在 webpack 中除了静态导入还有动态导入模块的方式，可以使用内置的 import()，写起来大概是这样子的。 12345import( /* webpackChunkName: &quot;lodash&quot; */ `lodash`).then((_) =&gt;&#123; console.log(_.uniq([1,1,2,3,3]))&#125;) 这里需要装一个 @babel/plugin-syntax-dynamic-import 来帮助我们解析 12345// .babelrc&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], // 从右向左解析 &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;]&#125; 在 output 选项中加入 chunkFilename 12345678// webpack.config.js...output:&#123;, path: path.resolve(&#x27;dist&#x27;), // 打包后目录，需为绝对路径 filename: &#x27;[name].[hash:8].js&#x27;, // 打包后文件名 chunkFilename: &#x27;[name].[hash:8].js&#x27;&#125;, ... 这里其实最核心的一点应用其实在于 js懒加载 ，例如我找个元素，然后让它点击之后才会加载，这样子就能把整个 文件瘦身成很多个小块 12345678910window.onload = () =&gt; &#123; document.getElementById(&#x27;webpack&#x27;).onclick = e =&gt;&#123; //只有该元素点击的时候才会去拉取这个块 import( /* webpackChunkName: &quot;lodash&quot; */ `lodash`).then((_) =&gt;&#123; console.log(_.uniq([1,1,2,3,3])) &#125;) &#125;&#125; 懒加载不仅可以用在 js 模块上，css 文件也可以懒加载，只要你想，一切都可以懒 123456...import( /* webpackChunkName: &quot;style&quot; */ `./scss/style-scss.scss`).then((_) =&gt;&#123; console.log(&#x27;style-load&#x27;)&#125;) 生产环境跟开发环境如果你从上面写到这里的话你会发现，整个文件越来越长，越来越大的难以忍受难以看懂，这里为了方便我们开发我们需要把 webpack.config.js 拆分成 webpack.common.js webpack.dev.js 和 webpack.prod.js ，然后引用个插件来 复合产生两个文件来供我们两个环境使用 1cnpm i -D webpack-merge 这里提取文件的思路是，把公共的代码提取到 webpack.common.js 中，这里一般配置一些常用的东西，比如 entry ，output，module，resolve 这些配置，因为这些配置开发环境跟生产环境通用的东西 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// webpack.common.jsconst path = require(&#x27;path&#x27;)//首先引入插件,插件是一个类,使用的时候需要先 new const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)//需要装 cross-env 来做跨平台的兼容 // 将package.json 中的 scripts &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; // 这样代码就能知道我们是处于什么环境打包的const devMode = process.env.NODE_ENV !== &#x27;production&#x27; //判断是否生产环境const styleLoader = &#x27;style-loader&#x27;const miniLoader = &#123; loader:MiniCssExtractPlugin.loader, options:&#123; publicPath: &#x27;../&#x27; &#125;&#125;// 这个插件暂时不支持 HMR ，开发环境中还是使用 style-loaderconst extractLoader = devMode ? styleLoader : miniLoaderconst cssLoader = &#x27;css-loader&#x27;const postcssLoader = &#x27;postcss-loader&#x27;const lessLoader = &#x27;less-loader&#x27;const sassLoader = &#x27;sass-loader&#x27;const cssLoaders = [ extractLoader, cssLoader, postcssLoader,]const lessLoaders = [ ...cssLoaders, lessLoader,]const sassLoaders = [ ...cssLoaders, sassLoader,]module.exports = &#123; entry:&#123; index:&#x27;./src/index.js&#x27; &#125;, //单页面入口 output:&#123; path: path.resolve(&#x27;dist&#x27;), // 打包后目录，需为绝对路径 filename: &#x27;[name].[hash:8].js&#x27;, // 打包后文件名 chunkFilename: &#x27;[name].[hash:8].js&#x27; &#125;, //出口 module:&#123; rules:[ &#123; test: /\\.css$/, //匹配查找 css 文件 include: path.resolve(__dirname, &#x27;src&#x27;), use: cssLoaders &#125;, &#123; test: /\\.less$/, //匹配查找 less 文件 include: path.resolve(__dirname, &#x27;src&#x27;), use: lessLoaders &#125;, &#123; test: /\\.scss$/, //匹配查找 scss 文件 include: path.resolve(__dirname, &#x27;src&#x27;), use:sassLoaders &#125;, &#123; test:/\\.js$/, use: &#x27;babel-loader&#x27;, include: /src/, // 只转化src目录下的js exclude: /node_modules/ // 排除掉node_modules，优化打包速度 &#125;, &#123; test:/\\.(jpe?g|png|gif)$/, exclude: /src\\//, // 排除掉node_modules，优化打包速度 use:[ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 1000, // 小于8k的图片自动转成base64格式，并且不会存在实体图片 outputPath: &#x27;images/&#x27; // 图片打包后存放的目录 &#125; &#125; ] &#125;, &#123; test: /\\.(htm|html)$/, include: path.resolve(__dirname, &#x27;src&#x27;), use: &#x27;html-withimg-loader&#x27; // html里面所有的img链接 &#125;, &#123; test: /\\.(eot|ttf|woff|svg)$/, include: path.resolve(__dirname, &#x27;src&#x27;), use: &#x27;file-loader&#x27; &#125; ] &#125;, //处理对应模块 resolve: &#123; // 别名 alias:&#123; main: path.join(__dirname, &#x27;src/main.js&#x27;) &#125;, //省略后缀名 extensions:[&#x27;.js&#x27;,&#x27;.json&#x27;,&#x27;.less&#x27;,&#x27;.scss&#x27;,&#x27;.css&#x27;] &#125;&#125; 提取出 webpack.common.js 之后我们来接着写另外两个 123456789101112131415// webpack.dev.jsconst common = require(&#x27;./webpack.common&#x27;)const merge = require(&#x27;webpack-merge&#x27;)//配置开发服务器，开发工具等module.exports = merge(common,&#123; mode:&#x27;development&#x27;, //模式配置 devtool: &#x27;inline-source-map&#x27;, devServer: &#123; contentBase: &#x27;./dist&#x27;, host: &#x27;localhost&#x27;, // 默认是localhost port: 3000, // 端口 open: true, // 自动打开浏览器 hot: true // 开启热更新 &#125;&#125;) 12345678910111213141516171819202122232425262728293031323334// webpack.prod.js//首先引入插件,插件是一个类,使用的时候需要先 new const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);const common = require(&#x27;./webpack.common&#x27;)const merge = require(&#x27;webpack-merge&#x27;)//配置打包文件，压缩文件，提取文件等操作module.exports = merge(common, &#123; mode:&#x27;production&#x27;, //模式配置 optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: true // set to true if you want JS source maps &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins:[ new CleanWebpackPlugin(), //清理文件夹 new HtmlWebpackPlugin(&#123; template:&#x27;./src/index.html&#x27;, // 打包目标模板 // title:&#x27;我被打包了&#x27;,// 不用 template 时候生效 filename:&#x27;index.html&#x27;, // 换个文件名 &#125;), new MiniCssExtractPlugin(&#123; filename:&#x27;css/[name].css&#x27; &#125;), ], //对应插件&#125;) 提取出来后去 package.json 中配置脚本参数 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.prod.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;&#125; 这样你就把所有的东西都干完啦。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://luoyuda.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://luoyuda.github.io/tags/CSS/"},{"name":"Webpack","slug":"Webpack","permalink":"https://luoyuda.github.io/tags/Webpack/"}]},{"title":"canvas 实践","slug":"Canvas/canvas-02","date":"2018-11-22T11:23:00.000Z","updated":"2018-11-22T11:23:00.000Z","comments":true,"path":"2018/11/22/Canvas/canvas-02/","link":"","permalink":"https://luoyuda.github.io/2018/11/22/Canvas/canvas-02/","excerpt":"","text":"canvas 实践粒子效果首先确定开发的步骤 准备基础的 html 跟 css 当背景 初始化 canvas 准备一个粒子类 Particle 编写粒子连线的函数 drawLine 编写动画函数 animate 添加鼠标和触摸移动事件、resize事件 离屏渲染优化、手机端的模糊处理 准备基础的 html 跟 css 当背景来这个网址随便找个你喜欢的渐变色 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Amaze UI&quot;/&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot;/&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot;/&gt; &lt;title&gt;canvas-粒子效果&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; html,body &#123; margin:0; overflow:hidden; width:100%; height:100%; background: #B993D6; background: -webkit-linear-gradient(to left, #8CA6DB, #B993D6); background: linear-gradient(to left, #8CA6DB, #B993D6); &#125; &lt;/style&gt; &lt;!--高清屏兼容的hidpi.js--&gt; &lt;script src=&quot;hidpi-canvas.min.js&quot;&gt;&lt;/script&gt; &lt;!--业务代码--&gt; &lt;script src=&quot;canvas-particle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样之后你就得到了一个纯净的背景 初始化 canvas首先准备一个可以将 context 变成链式调用的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 链式调用function Canvas2DContext(canvas) &#123; if (typeof canvas === &quot;string&quot;) &#123; canvas = document.getElementById(canvas) &#125; if (!(this instanceof Canvas2DContext)) &#123; return new Canvas2DContext(canvas) &#125; this.context = this.ctx = canvas.getContext(&quot;2d&quot;) if (!Canvas2DContext.prototype.arc) &#123; Canvas2DContext.setup.call(this, this.ctx) &#125;&#125;Canvas2DContext.setup = function() &#123; var methods = [&quot;arc&quot;, &quot;arcTo&quot;, &quot;beginPath&quot;, &quot;bezierCurveTo&quot;, &quot;clearRect&quot;, &quot;clip&quot;, &quot;closePath&quot;, &quot;drawImage&quot;, &quot;fill&quot;, &quot;fillRect&quot;, &quot;fillText&quot;, &quot;lineTo&quot;, &quot;moveTo&quot;, &quot;quadraticCurveTo&quot;, &quot;rect&quot;, &quot;restore&quot;, &quot;rotate&quot;, &quot;save&quot;, &quot;scale&quot;, &quot;setTransform&quot;, &quot;stroke&quot;, &quot;strokeRect&quot;, &quot;strokeText&quot;, &quot;transform&quot;, &quot;translate&quot;] var getterMethods = [&quot;createPattern&quot;, &quot;drawFocusRing&quot;, &quot;isPointInPath&quot;, &quot;measureText&quot;, // drawFocusRing not currently supported // The following might instead be wrapped to be able to chain their child objects &quot;createImageData&quot;, &quot;createLinearGradient&quot;, &quot;createRadialGradient&quot;, &quot;getImageData&quot;, &quot;putImageData&quot; ] var props = [&quot;canvas&quot;, &quot;fillStyle&quot;, &quot;font&quot;, &quot;globalAlpha&quot;, &quot;globalCompositeOperation&quot;, &quot;lineCap&quot;, &quot;lineJoin&quot;, &quot;lineWidth&quot;, &quot;miterLimit&quot;, &quot;shadowOffsetX&quot;, &quot;shadowOffsetY&quot;, &quot;shadowBlur&quot;, &quot;shadowColor&quot;, &quot;strokeStyle&quot;, &quot;textAlign&quot;, &quot;textBaseline&quot;] for (let m of methods) &#123; let method = m Canvas2DContext.prototype[method] = function() &#123; this.ctx[method].apply(this.ctx, arguments) return this &#125; &#125; for (let m of getterMethods) &#123; let method = m Canvas2DContext.prototype[method] = function() &#123; return this.ctx[method].apply(this.ctx, arguments) &#125; &#125; for (let p of props) &#123; let prop = p Canvas2DContext.prototype[prop] = function(value) &#123; if (value === undefined) &#123;return this.ctx[prop]&#125; this.ctx[prop] = value return this &#125; &#125;&#125; 接下来写一个 ParticleCanvas 函数 123456const ParticleCanvas = window.ParticleCanvas = function()&#123; const canvas return canvas&#125;const canvas = ParticleCanvas()console.log(canvas) ParticleCanvas 方法可能会接受很多参数 首先第一个参数必然是 id 啦，不然你怎么获取到 canvas。 还有宽高参数，我们把 canvas 处理一下宽高。 可以使用 ES6 的函数默认参数跟解构赋值的方法。 准备一个 init 方法初始化画布12345678910111213141516171819202122232425const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, width = 0, height = 0&#125;)&#123; //这里是获取到 canvas 对象，如果没获取到我们就自己创建一个插入进去 const canvas = document.getElementById(id) || document.createElement(&quot;canvas&quot;) if(canvas.id !== id)&#123; (canvas.id = id) &amp;&amp; document.body.appendChild(canvas)&#125; //通过调用上面的方法来获取到一个可以链式操作的上下文 const context = Canvas2DContext(canvas) //这里默认的是网页窗口大小，如果传入则取传入的值 width = width || document.documentElement.clientWidth height = height || document.documentElement.clientHeight //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; canvas.width = width canvas.height = height &#125; init() return canvas&#125;const canvas = ParticleCanvas(&#123;&#125;)console.log(canvas) 写完之后就变成这样了 准备一个粒子类 Particle接下来我们磨刀霍霍向粒子了，通过观察动画效果我们可以知道，首先这个核心就是粒子，且每次出现的随机的粒子，所以解决了粒子就可以解决了这个效果的 50% 啊。那我们就开始来写这个类 我们先来思考一下，这个粒子类，目前最需要哪些参数初始化它 第一个当然是，绘制上下文 context 然后，这个粒子实际上其实就是画个圆，画圆需要什么参数？ arc(x, y, radius, startAngle, endAngle, anticlockwise) 前三个怎么都要传进来吧，不然你怎么保证每个粒子实例 大小 和 位置 不一样呢 头脑风暴结束后我们目前确定了四个参数 context x y r 所谓 万丈高楼平地起 要画一百个粒子，首先先画第一个粒子123456789101112131415161718192021class Particle &#123; constructor(&#123;context, x, y, r&#125;)&#123; context.beginPath() .fillStyle(&quot;#fff&quot;) .arc(x, y, r, 0, Math.PI * 2) .fill() .closePath() &#125;&#125;//准备一个 init() 方法 初始化画布const init = () =&gt; &#123; canvas.width = width canvas.height = height const particle = new Particle(&#123; context, x: 100, y: 100, r: 10 &#125;)&#125;init() 好的，你成功迈出了第一步我们接下来思考 现在我们的需求是画 N 个随机位置随机大小的粒子，那要怎么做呢 首先，我们可以通过一个循环去绘制一堆粒子 只要传值是随机的，那，不就是，随机的粒子吗！ 随机的 x y 应该在屏幕内，而大小应该在一个数值以内 说写就写，用 Math.random 不就解决需求了吗12345678910111213const init = () =&gt; &#123; canvas.width = width canvas.height = height for (let i = 0; i &lt; 50; i++) &#123; new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (10 - 5) + 10) &#125;) &#125;&#125;init() 好的，随机粒子也被我们撸出来了接下来还有个问题，这样直接写虽然可以解决需求，但是其实不易于扩展。 每次我们调用 Particle 类的构造函数的时候，我们就去绘制，这就显得有些奇怪。 我们需要另外准备一个类的内部方法，让它去负责绘制，而构造函数存储这些参数值，各司其职 然后就是我们初始化的粒子，我们需要拿一个数组来装住这些粒子，方便我们的后续操作 然后机智的你又发现了，我们为什么不传个颜色，透明度进去让它更随机一点 我们确定了要传入 parColor ，那我们分析一波这个参数，你有可能想传入的是一个十六进制的颜色码，也可能传一个 rgb 或者 rgba 形式的，我们配合透明度再来做处理，那就需要另外一个转换的函数，让它统一转换一下。 既然你都能传颜色值了，那支持多种颜色不也是手到擒来的事情，不就是传个数组进去么？ 确定完需求就开写。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*16进制颜色转为RGB格式 传入颜色值和透明度 */ const color2Rgb = (str, op) =&gt; &#123; const reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/ let sColor = str.toLowerCase() // 如果不传，那就随机透明度 op = op || (Math.floor(Math.random() * 10) + 4) / 10 / 2 let opStr = `,$&#123;op&#125;)` // 这里使用 惰性返回，就是存储一下转换好的，万一遇到转换过的就直接取值 if (this[str]) &#123;return this[str] + opStr&#125; if (sColor &amp;&amp; reg.test(sColor)) &#123; // 如果是十六进制颜色码 if (sColor.length === 4) &#123; let sColorNew = &quot;#&quot; for (let i = 1; i &lt; 4; i += 1) &#123; sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1)) &#125; sColor = sColorNew &#125; //处理六位的颜色值 let sColorChange = [] for (let i = 1; i &lt; 7; i += 2) &#123; sColorChange.push(parseInt(&quot;0x&quot; + sColor.slice(i, i + 2))) &#125; let result = `rgba($&#123;sColorChange.join(&quot;,&quot;)&#125;` this[str] = result return result + opStr &#125; // 不是我就不想管了 return sColor&#125;// 获取数组中随机一个值const getArrRandomItem = (arr) =&gt; arr[Math.round(Math.random() * (arr.length - 1 - 0) + 0)]//函数添加传入的参数const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, width = 0, height = 0, parColor = [&quot;#fff&quot;,&quot;#000&quot;], parOpacity, maxParR = 10, //粒子最大的尺寸 minParR = 5, //粒子最小的尺寸&#125;)&#123; ... let particles = [] class Particle &#123; constructor(&#123;context, x, y, r, parColor, parOpacity&#125;)&#123; this.context = context this.x = x this.y = y this.r = r this.color = color2Rgb(typeof parColor === &quot;string&quot; ? parColor : getArrRandomItem(parColor), parOpacity) // 颜色 this.draw() &#125; draw()&#123; this.context.beginPath() .fillStyle(this.color) .arc(this.x, this.y, this.r, 0, Math.PI * 2) .fill() .closePath() &#125;&#125;//准备一个 init() 方法 初始化画布const init = () =&gt; &#123; canvas.width = width canvas.height = height for (let i = 0; i &lt; 50; i++) &#123; particles.push(new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (maxParR - minParR) + minParR), parColor, parOpacity &#125;)) &#125;&#125;init() return canvas&#125; 接下来你的页面就会长成这样子啦，基础的粒子类已经写好了，接下来我们先把连线函数编写一下 drawLine两个点要如何连成线？我们查一下就知道，要通过调用 moveTo(x, y) 和 lineTo(x,y) 观察效果，思考一下连线的条件，我们发现在一定的距离两个粒子会连成线 首先线的参数就跟粒子的是差不多的，需要线宽 lineWidth, 颜色 lineColor, 透明度 lineOpacity 那其实是不是再通过双层循环来调用 drawLine 就可以让他们彼此连线 drawLine 其实就需要传入另一个粒子进去，开搞12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, width = 0, height = 0, parColor = [&quot;#fff&quot;,&quot;#000&quot;], parOpacity, maxParR = 10, //粒子最大的尺寸 minParR = 5, //粒子最小的尺寸 lineColor = &quot;#fff&quot;, lineOpacity, lineWidth = 1&#125;)&#123; ... class Particle &#123; constructor(&#123;context, x, y, r, parColor, parOpacity, lineWidth, lineColor, lineOpacity&#125;)&#123; this.context = context this.x = x this.y = y this.r = r this.color = color2Rgb(typeof parColor === &quot;string&quot; ? parColor : getArrRandomItem(parColor), parOpacity) // 颜色 this.lineColor = color2Rgb(typeof lineColor === &quot;string&quot; ? lineColor : getArrRandomItem(lineColor), lineOpacity) //这个判断是为了让线段颜色跟粒子颜色保持一致使用的，不影响整个逻辑 if(lineColor != &quot;#fff&quot;)&#123; this.color = this.lineColor &#125;else&#123; this.lineColor = this.color &#125; this.lineWidth = lineWidth this.draw() &#125; draw()&#123; ... &#125; drawLine(_round) &#123; let dx = this.x - _round.x, dy = this.y - _round.y if (Math.sqrt(dx * dx + dy * dy) &lt; 150) &#123; let x = this.x, y = this.y, lx = _round.x, ly = _round.y this.context.beginPath() .moveTo(x, y) .lineTo(lx, ly) .closePath() .lineWidth(this.lineWidth) .strokeStyle(this.lineColor) .stroke() &#125; &#125; &#125; //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; canvas.width = width canvas.height = height for (let i = 0; i &lt; 50; i++) &#123; particles.push(new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (maxParR - minParR) + minParR), parColor, parOpacity, lineWidth, lineColor, lineOpacity &#125;)) &#125; for (let i = 0; i &lt; particles.length; i++) &#123; for (let j = i + 1; j &lt; particles.length; j++) &#123; particles[i].drawLine(particles[j]) &#125; &#125; &#125; ...&#125; 现在我们就得到一个连线的粒子了，接下来我们就要让我们的页面动起来了 animate首先我们要认识到，canvas是通过我们编写的那些绘制函数绘制上去的，那么，我们如果使用一个定时器，定时的去绘制，不就是动画的基本原理了么 首先我们要写一个 animate 函数，把我们的逻辑写进去，然后让定时器 requestAnimationFrame 去执行它 requestAnimationFrame是浏览器用于定时循环操作的一个接口，类似于setTimeout，主要用途是按帧对网页进行重绘。 设置这个API的目的是为了让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。代码中使用这个API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘。 看不明白的话，那你就把他当成一个不用你去设置时间的 setInterval 那我们要通过动画去执行绘制，粒子要动起来，我们必须要再粒子类上再扩展一个方法 move ,既然要移动了，那上下移动的偏移量必不可少 moveX 和 moveY 逻辑分析完毕，开炮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, width = 0, height = 0, parColor = [&quot;#fff&quot;,&quot;#000&quot;], parOpacity, maxParR = 10, //粒子最大的尺寸 minParR = 5, //粒子最小的尺寸 lineColor = &quot;#fff&quot;, lineOpacity, lineWidth = 1, moveX = 0, moveY = 0,&#125;)&#123; ... class Particle &#123; constructor(&#123;context, x, y, r, parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY&#125;)&#123; this.context = context this.x = x this.y = y this.r = r this.color = color2Rgb(typeof parColor === &quot;string&quot; ? parColor : getArrRandomItem(parColor), parOpacity) // 颜色 this.lineColor = color2Rgb(typeof lineColor === &quot;string&quot; ? lineColor : getArrRandomItem(lineColor), lineOpacity) this.lineWidth = lineWidth //初始化最开始的速度 this.moveX = Math.random() + moveX this.moveY = Math.random() + moveY this.draw() &#125; draw()&#123; this.context.beginPath() .fillStyle(this.color) .arc(this.x, this.y, this.r, 0, Math.PI * 2) .fill() .closePath() &#125; drawLine(_round) &#123; let dx = this.x - _round.x, dy = this.y - _round.y if (Math.sqrt(dx * dx + dy * dy) &lt; 150) &#123; let x = this.x, y = this.y, lx = _round.x, ly = _round.y if(this.userCache)&#123; x = this.x + this.r / this._ratio y = this.y + this.r / this._ratio lx = _round.x + _round.r / this._ratio ly = _round.y + _round.r / this._ratio &#125; this.context.beginPath() .moveTo(x, y) .lineTo(lx, ly) .closePath() .lineWidth(this.lineWidth) .strokeStyle(this.lineColor) .stroke() &#125; &#125; move() &#123; //边界判断 this.moveX = this.x + this.r * 2 &lt; width &amp;&amp; this.x &gt; 0 ? this.moveX : -this.moveX this.moveY = this.y + this.r * 2 &lt; height &amp;&amp; this.y &gt; 0 ? this.moveY : -this.moveY //通过偏移量，改变x y的值，绘制 this.x += this.moveX this.y += this.moveY this.draw() &#125; &#125; //动画函数 const animate = () =&gt; &#123; //每次调用要首先清除画布，不然你懂的 context.clearRect(0, 0, width, height) for (let i = 0; i &lt; particles.length; i++) &#123; //粒子移动 particles[i].move() for (let j = i + 1; j &lt; particles.length; j++) &#123; //粒子连线 particles[i].drawLine(particles[j]) &#125; &#125; requestAnimationFrame(animate) &#125; //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; canvas.width = width canvas.height = height for (let i = 0; i &lt; 50; i++) &#123; particles.push(new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (maxParR - minParR) + minParR), parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY, &#125;)) &#125; //执行动画 animate() &#125; init() return canvas&#125; 如果没有意外，你的页面应该动起来啦，是不是感觉很简单呢添加鼠标和触摸移动事件接下来我们要来添加鼠标和触摸移动的效果了 首先鼠标移动会有一个粒子跟随，我们单独初始化一个孤单的粒子出来 currentParticle，这个粒子跟上来自己动的妖艳贱货不一样的点在于，currentParticle 的位置，我们需要通过监听事件返回的鼠标位置赋值给它，是的，这个需要你让他动。 既然是个独特的粒子，那么样式也要支持自定义啦 isMove(是否开启跟随) targetColor targetPpacity targetR 看你也知道是什么意思啦， 不解释了。 resize 事件是监听浏览器窗口尺寸变化，这样子在用户变化尺寸的时候，我们的背景就不会变得不和谐 实现的思路主要是通过监听 resize 事件，重新调用一波 init 方法，来重新渲染画布，由于 resize 这个在事件在变化的时候回调非常的频繁，频繁的计算会影响性能，严重可能会卡死，所以我们通过防抖 debounce 或者节流 throttle 的方式来限制其调用。 了解完思路，那就继续写啦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/* 保留小数 */const toFixed = (a, n) =&gt; parseFloat(a.toFixed(n || 1))//节流，避免resize占用过多资源const throttle = function (func,wait,options) &#123; var context,args,timeout var previous = 0 options = options || &#123;&#125; // leading：false 表示禁用第一次执行 // trailing: false 表示禁用停止触发的回调 var later = function()&#123; previous = options.leading === false ? 0 : new Date().getTime() timeout = null func.apply(context, args) &#125; var throttled = function()&#123; var now = +new Date() if (!previous &amp;&amp; options.leading === false) &#123;previous = now&#125; // 下次触发 func 的剩余时间 var remaining = wait - (now - previous) context = this args = arguments // 如果没有剩余的时间了或者你改了系统时间 if(remaining &gt; wait || remaining &lt;= 0)&#123; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; previous = now func.apply(context, args) &#125;else if(!timeout &amp;&amp; options.trailing !== false)&#123; timeout = setTimeout(later, remaining) &#125; &#125; throttled.cancel = function() &#123; clearTimeout(timeout) previous = 0 timeout = null &#125; return throttled&#125;//防抖，避免resize占用过多资源const debounce = function(func,wait,immediate)&#123; //防抖 //定义一个定时器。 var timeout,result var debounced = function() &#123; //获取 this var context = this //获取参数 var args = arguments //清空定时器 if(timeout)&#123;clearTimeout(timeout)&#125; if(immediate)&#123; //立即触发，但是需要等待 n 秒后才可以重新触发执行 var callNow = !timeout console.log(callNow) timeout = setTimeout(function()&#123; timeout = null &#125;, wait) if (callNow) &#123;result = func.apply(context, args)&#125; &#125;else&#123; //触发后开始定时， timeout = setTimeout(function()&#123; func.apply(context,args) &#125;, wait) &#125; return result &#125; debounced.cancel = function()&#123; // 当immediate 为 true，上一次执行后立即，取消定时器，下一次可以实现立即触发 if(timeout) &#123;clearTimeout(timeout)&#125; timeout = null &#125; return debounced&#125;const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, width = 0, height = 0, parColor = [&quot;#fff&quot;], parOpacity, maxParR = 10, //粒子最大的尺寸 minParR = 5, //粒子最小的尺寸 lineColor = &quot;#fff&quot;, lineOpacity, lineWidth = 1, moveX = 0, moveY = 0, isMove = true, targetColor = [&quot;#000&quot;], targetPpacity = 0.6, targetR = 10,&#125;)&#123; let currentParticle, isWResize = width, isHResize = height, myReq = null class Particle &#123; ... &#125; //动画函数 const animate = () =&gt; &#123; //每次调用要首先清除画布，不然你懂的 context.clearRect(0, 0, width, height) for (let i = 0; i &lt; particles.length; i++) &#123; //粒子移动 particles[i].move() for (let j = i + 1; j &lt; particles.length; j++) &#123; //粒子连线 particles[i].drawLine(particles[j]) &#125; &#125; /** * 这个放在外面的原因 * 我不开启isMove的时候，或者currentParticle.x 没有值的情况 * 放在上面的循环需要每次走循环都判断一次 * 而放在下面的话只需要执行一次就知道有没有必要再执行 N 次 * 当然你也可以放里面，问题也不大 */ if (isMove &amp;&amp; currentParticle.x) &#123; for (let i = 0; i &lt; particles.length; i++) &#123; currentParticle.drawLine(particles[i]) &#125; currentParticle.draw() &#125; myReq = requestAnimationFrame(animate) &#125; //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; canvas.width = width canvas.height = height //独立粒子 if (isMove &amp;&amp; !currentParticle) &#123; currentParticle = new Particle(&#123; x: 0, y: 0, r: targetR, parColor: targetColor, parOpacity: targetPpacity, lineColor, lineOpacity, lineWidth, context &#125;) //独立粒子 const moveEvent = (e = window.event) =&gt; &#123; //改变 currentParticle 的 x y currentParticle.x = e.clientX || e.touches[0].clientX currentParticle.y = e.clientY || e.touches[0].clientY &#125; const outEvent = () =&gt; &#123;currentParticle.x = currentParticle.y = null&#125; const eventObject = &#123; &quot;pc&quot;: &#123; move: &quot;mousemove&quot;, out: &quot;mouseout&quot; &#125;, &quot;phone&quot;: &#123; move: &quot;touchmove&quot;, out: &quot;touchend&quot; &#125; &#125; const event = eventObject[/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? &quot;phone&quot; : &quot;pc&quot;] canvas.removeEventListener(event.move,moveEvent) canvas.removeEventListener(event.out, outEvent) canvas.addEventListener(event.move,moveEvent) canvas.addEventListener(event.out, outEvent) &#125; //自由粒子 for (let i = 0; i &lt; 50; i++) &#123; particles.push(new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (maxParR - minParR) + minParR), parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY, &#125;)) &#125; //执行动画 animate() /* 这个判断在于，假设用户只需要一个 500*500 的画布的时候。其实是不需要 resize 的 而用户如果只是输入其中一个值，另一个值自适应，则认为其需要 resize。 如果全部都自适应，那则肯定是需要 resize 的 此逻辑是我自己瞎想的，其实不用也行，只是我觉得这样更符合我自己的需求。 全部 resize 也是可以的。 */ if(!isWResize || !isHResize)&#123;window.addEventListener(&quot;resize&quot;,debounce(resize, 100))&#125; &#125; const resize = () =&gt; &#123; //清除 定时器 if(this.timeout)&#123;clearTimeout(this.timeout)&#125; //清除 AnimationFrame if(myReq)&#123;window.cancelAnimationFrame(myReq)&#125; //清空 粒子数组 particles = [] //设置新的 宽高 width = isWResize ? width : document.documentElement.clientWidth height = isHResize ? height : document.documentElement.clientHeight this.timeout = setTimeout(init, 20) &#125; init() return canvas&#125; 写到这里，这个东西差不多啦，接下来就是优化的问题了离屏渲染优化和手机端的模糊处理离屏渲染其实是指用离屏canvas上预渲染相似的图形或重复的对象，简单点说就是，你现在其他canvas对象上画好，然后再通过 drawImage() 放进去目标画布里面 我们需要提供一个方法，用于离屏渲染粒子，用于生成一个看不见的 canvas 然后在上面画画画 最好能够提供一下缓存用过的 canvas 用于节省空间性能，提高复用率 画的时候要注意，提供一个倍数，然后再缩小，看上去就比较清晰 这里的注意点是，理解这种渲染方式，以及倍数之间的关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//离屏缓存const getCachePoint = (r,color,cacheRatio) =&gt; &#123; let key = r + &quot;cache&quot; + color //缓存一个 canvas 如果遇到相同的，直接从缓存取 if(this[key])&#123;return this[key]&#125; //离屏渲染 const _ratio = 2 * cacheRatio, width = r * _ratio, cacheCanvas = document.createElement(&quot;canvas&quot;), cacheContext = Canvas2DContext(cacheCanvas) cacheCanvas.width = cacheCanvas.height = width cacheContext.save() .fillStyle(color) .arc(r * cacheRatio, r * cacheRatio, r, 0, 360) .closePath() .fill() .restore() this[key] = cacheCanvas return cacheCanvas&#125;const ParticleCanvas = window.ParticleCanvas = function(&#123; ... useCache = true //新增一个useCache表示是否开启离屏渲染&#125;)&#123; ... class Particle &#123; constructor(&#123;context, x, y, r, parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY, useCache&#125;)&#123; ... this.ratio = 3 this.useCache = useCache &#125; draw()&#123; if(this.useCache)&#123; this.context.drawImage( getCachePoint(this.r,this.color,this.ratio), this.x - this.r * this.ratio, this.y - this.r * this.ratio ) &#125;else&#123; this.context.beginPath() .fillStyle(this.color) .arc(toFixed(this.x), toFixed(this.y), toFixed(this.r), 0, Math.PI * 2) .fill() .closePath() &#125; &#125; ... &#125; ... //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; ... if (isMove &amp;&amp; !currentParticle) &#123; currentParticle = new Particle(&#123; ... useCache &#125;) //独立粒子 ... &#125; //自由粒子 for (let i = 0; i &lt; 50; i++) &#123; particles.push(new Particle(&#123; ... useCache &#125;)) &#125; ... &#125; ...&#125; 高清屏的模糊处理因为 canvas 绘制的图像并不是矢量图，而是跟图片一样的位图，所以在高 dpi 的屏幕上看的时候，就会显得比较模糊，比如 苹果的 Retina 屏幕，它会用两个或者三个像素来合成一个像素，相当于图被放大了两倍或者三倍，所以自然就模糊了 我们可以通过引入 hidpi-canvas.min.js 来处理在手机端高清屏绘制变得模糊的问题 这个插件的原理是通过这个方法来获取 dpi 123456789getPixelRatio = (context) =&gt; &#123; var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1 return (window.devicePixelRatio || 1) / backingStore&#125; 然后通过放大画布，再通过CSS的宽高缩小画布 1234567891011121314//兼容 Retina 屏幕const setRetina = (canvas,context,width,height) =&gt; &#123; var ratio = getPixelRatio(context) ratio = 2 if(context._retinaRatio &amp;&amp; context._retinaRatio !== ratio)&#123;window.location.reload()&#125; canvas.style.width = width * ratio + &quot;px&quot; canvas.style.height = height * ratio + &quot;px&quot; // 缩放绘图 context.setTransform(ratio, 0, 0, ratio, 0, 0) canvas.width = width * ratio canvas.height = height * ratio context._retinaRatio = ratio return ratio&#125; 这个方法通过处理是可以兼容好手机模糊的问题，但是在屏幕比较好的电脑屏幕感觉还是有点模糊，所以我就改造了一下… 如果是手机端，放大三倍，电脑端则放大两倍，再缩小到指定大小 需要注意的是，drawImage 的倍数关系 如果有更好更优雅的办法，希望能交流一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551const PIXEL_RATIO = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? 3 : 2//hidpi-canvas.min.js 核心代码;(function(prototype) &#123; var forEach = function(obj, func) &#123; for (var p in obj) &#123; if (obj.hasOwnProperty(p)) &#123; func(obj[p], p) &#125; &#125; &#125;, ratioArgs = &#123; &quot;fillRect&quot;: &quot;all&quot;, &quot;clearRect&quot;: &quot;all&quot;, &quot;strokeRect&quot;: &quot;all&quot;, &quot;moveTo&quot;: &quot;all&quot;, &quot;lineTo&quot;: &quot;all&quot;, &quot;arc&quot;: [0,1,2], &quot;arcTo&quot;: &quot;all&quot;, &quot;bezierCurveTo&quot;: &quot;all&quot;, &quot;isPointinPath&quot;: &quot;all&quot;, &quot;isPointinStroke&quot;: &quot;all&quot;, &quot;quadraticCurveTo&quot;: &quot;all&quot;, &quot;rect&quot;: &quot;all&quot;, &quot;translate&quot;: &quot;all&quot;, &quot;createRadialGradient&quot;: &quot;all&quot;, &quot;createLinearGradient&quot;: &quot;all&quot; &#125; forEach(ratioArgs, function(value, key) &#123; prototype[key] = (function(_super) &#123; return function() &#123; var i, len, args = Array.prototype.slice.call(arguments) if (value === &quot;all&quot;) &#123; args = args.map(function(a) &#123; return a * PIXEL_RATIO &#125;) &#125; else if (Array.isArray(value)) &#123; for (i = 0, len = value.length; i &lt; len; i++) &#123; args[value[i]] *= PIXEL_RATIO &#125; &#125; return _super.apply(this, args) &#125; &#125;)(prototype[key]) &#125;) // Stroke lineWidth adjustment prototype.stroke = (function(_super) &#123; return function() &#123; this.lineWidth *= PIXEL_RATIO _super.apply(this, arguments) this.lineWidth /= PIXEL_RATIO &#125; &#125;)(prototype.stroke) // Text // prototype.fillText = (function(_super) &#123; return function() &#123; var args = Array.prototype.slice.call(arguments) args[1] *= PIXEL_RATIO // x args[2] *= PIXEL_RATIO // y this.font = this.font.replace( /(\\d+)(px|em|rem|pt)/g, function(w, m, u) &#123; return m * PIXEL_RATIO + u &#125; ) _super.apply(this, args) this.font = this.font.replace( /(\\d+)(px|em|rem|pt)/g, function(w, m, u) &#123; return m / PIXEL_RATIO + u &#125; ) &#125; &#125;)(prototype.fillText) prototype.strokeText = (function(_super) &#123; return function() &#123; var args = Array.prototype.slice.call(arguments) args[1] *= PIXEL_RATIO // x args[2] *= PIXEL_RATIO // y this.font = this.font.replace( /(\\d+)(px|em|rem|pt)/g, function(w, m, u) &#123; return m * PIXEL_RATIO + u &#125; ) _super.apply(this, args) this.font = this.font.replace( /(\\d+)(px|em|rem|pt)/g, function(w, m, u) &#123; return m / PIXEL_RATIO + u &#125; ) &#125; &#125;)(prototype.strokeText)&#125;)(CanvasRenderingContext2D.prototype)//兼容 Retina 屏幕const setRetina = (canvas,context,width,height) =&gt; &#123; var ratio = PIXEL_RATIO canvas.style.width = width + &quot;px&quot; canvas.style.height = height + &quot;px&quot; // 缩放绘图 context.setTransform(ratio, 0, 0, ratio, 0, 0) canvas.width = width * ratio canvas.height = height * ratio context._retinaRatio = ratio return ratio&#125;// 链式调用function Canvas2DContext(canvas) &#123; if (typeof canvas === &quot;string&quot;) &#123; canvas = document.getElementById(canvas) &#125; if (!(this instanceof Canvas2DContext)) &#123; return new Canvas2DContext(canvas) &#125; this.context = this.ctx = canvas.getContext(&quot;2d&quot;) if (!Canvas2DContext.prototype.arc) &#123; Canvas2DContext.setup.call(this, this.ctx) &#125;&#125;Canvas2DContext.setup = function() &#123; var methods = [&quot;arc&quot;, &quot;arcTo&quot;, &quot;beginPath&quot;, &quot;bezierCurveTo&quot;, &quot;clearRect&quot;, &quot;clip&quot;, &quot;closePath&quot;, &quot;drawImage&quot;, &quot;fill&quot;, &quot;fillRect&quot;, &quot;fillText&quot;, &quot;lineTo&quot;, &quot;moveTo&quot;, &quot;quadraticCurveTo&quot;, &quot;rect&quot;, &quot;restore&quot;, &quot;rotate&quot;, &quot;save&quot;, &quot;scale&quot;, &quot;setTransform&quot;, &quot;stroke&quot;, &quot;strokeRect&quot;, &quot;strokeText&quot;, &quot;transform&quot;, &quot;translate&quot;] var getterMethods = [&quot;createPattern&quot;, &quot;drawFocusRing&quot;, &quot;isPointInPath&quot;, &quot;measureText&quot;, // drawFocusRing not currently supported // The following might instead be wrapped to be able to chain their child objects &quot;createImageData&quot;, &quot;createLinearGradient&quot;, &quot;createRadialGradient&quot;, &quot;getImageData&quot;, &quot;putImageData&quot; ] var props = [&quot;canvas&quot;, &quot;fillStyle&quot;, &quot;font&quot;, &quot;globalAlpha&quot;, &quot;globalCompositeOperation&quot;, &quot;lineCap&quot;, &quot;lineJoin&quot;, &quot;lineWidth&quot;, &quot;miterLimit&quot;, &quot;shadowOffsetX&quot;, &quot;shadowOffsetY&quot;, &quot;shadowBlur&quot;, &quot;shadowColor&quot;, &quot;strokeStyle&quot;, &quot;textAlign&quot;, &quot;textBaseline&quot;] for (let m of methods) &#123; let method = m Canvas2DContext.prototype[method] = function() &#123; this.ctx[method].apply(this.ctx, arguments) return this &#125; &#125; for (let m of getterMethods) &#123; let method = m Canvas2DContext.prototype[method] = function() &#123; return this.ctx[method].apply(this.ctx, arguments) &#125; &#125; for (let p of props) &#123; let prop = p Canvas2DContext.prototype[prop] = function(value) &#123; if (value === undefined) &#123;return this.ctx[prop]&#125; this.ctx[prop] = value return this &#125; &#125;&#125;/*16进制颜色转为RGB格式 传入颜色值和透明度 */ const color2Rgb = (str, op) =&gt; &#123; const reg = /^#([0-9a-fA-f]&#123;3&#125;|[0-9a-fA-f]&#123;6&#125;)$/ let sColor = str.toLowerCase() // 如果不传，那就随机透明度 op = op || (Math.floor(Math.random() * 10) + 4) / 10 / 2 let opStr = `,$&#123;op&#125;)` // 这里使用 惰性返回，就是存储一下转换好的，万一遇到转换过的就直接取值 if (this[str]) &#123;return this[str] + opStr&#125; if (sColor &amp;&amp; reg.test(sColor)) &#123; // 如果是十六进制颜色码 if (sColor.length === 4) &#123; let sColorNew = &quot;#&quot; for (let i = 1; i &lt; 4; i += 1) &#123; sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1)) &#125; sColor = sColorNew &#125; //处理六位的颜色值 let sColorChange = [] for (let i = 1; i &lt; 7; i += 2) &#123; sColorChange.push(parseInt(&quot;0x&quot; + sColor.slice(i, i + 2))) &#125; let result = `rgba($&#123;sColorChange.join(&quot;,&quot;)&#125;` this[str] = result return result + opStr &#125; // 不是我就不想管了 return sColor&#125;// 获取数组中随机一个值const getArrRandomItem = (arr) =&gt; arr[Math.round(Math.random() * (arr.length - 1 - 0) + 0)]/* 保留小数 */const toFixed = (a, n) =&gt; parseFloat(a.toFixed(n || 1))//节流，避免resize占用过多资源const throttle = function (func,wait,options) &#123; var context,args,timeout var previous = 0 options = options || &#123;&#125; // leading：false 表示禁用第一次执行 // trailing: false 表示禁用停止触发的回调 var later = function()&#123; previous = options.leading === false ? 0 : new Date().getTime() timeout = null func.apply(context, args) &#125; var throttled = function()&#123; var now = +new Date() if (!previous &amp;&amp; options.leading === false) &#123;previous = now&#125; // 下次触发 func 的剩余时间 var remaining = wait - (now - previous) context = this args = arguments // 如果没有剩余的时间了或者你改了系统时间 if(remaining &gt; wait || remaining &lt;= 0)&#123; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; previous = now func.apply(context, args) &#125;else if(!timeout &amp;&amp; options.trailing !== false)&#123; timeout = setTimeout(later, remaining) &#125; &#125; throttled.cancel = function() &#123; clearTimeout(timeout) previous = 0 timeout = null &#125; return throttled&#125;//防抖，避免resize占用过多资源const debounce = function(func,wait,immediate)&#123; //防抖 //定义一个定时器。 var timeout,result var debounced = function() &#123; //获取 this var context = this //获取参数 var args = arguments //清空定时器 if(timeout)&#123;clearTimeout(timeout)&#125; if(immediate)&#123; //立即触发，但是需要等待 n 秒后才可以重新触发执行 var callNow = !timeout console.log(callNow) timeout = setTimeout(function()&#123; timeout = null &#125;, wait) if (callNow) &#123;result = func.apply(context, args)&#125; &#125;else&#123; //触发后开始定时， timeout = setTimeout(function()&#123; func.apply(context,args) &#125;, wait) &#125; return result &#125; debounced.cancel = function()&#123; // 当immediate 为 true，上一次执行后立即，取消定时器，下一次可以实现立即触发 if(timeout) &#123;clearTimeout(timeout)&#125; timeout = null &#125; return debounced&#125;//离屏缓存const getCachePoint = (r,color,cacheRatio) =&gt; &#123; let key = r + &quot;cache&quot; + color if(this[key])&#123;return this[key]&#125; //离屏渲染 const _ratio = 2 * cacheRatio, width = r * _ratio, cR = toFixed(r * cacheRatio), cacheCanvas = document.createElement(&quot;canvas&quot;), cacheContext = Canvas2DContext(cacheCanvas) setRetina(cacheCanvas,cacheContext,width,width) // cacheCanvas.width = cacheCanvas.height = width cacheContext.save() .fillStyle(color) .arc(cR, cR, cR, 0, 360) .closePath() .fill() .restore() this[key] = cacheCanvas return cacheCanvas&#125;const ParticleCanvas = window.ParticleCanvas = function(&#123; id = &quot;p-canvas&quot;, num = 30, width = 0, height = 0, parColor = [&quot;#fff&quot;], parOpacity, maxParR = 4, //粒子最大的尺寸 minParR = 8, //粒子最小的尺寸 lineColor = [&quot;#fff&quot;], lineOpacity = 0.3, lineWidth = 1, moveX = 0, moveY = 0, isMove = true, targetColor = [&quot;#fff&quot;], targetPpacity = 0.6, targetR = 6, useCache = false&#125;)&#123; //这里是获取到 canvas 对象，如果没获取到我们就自己创建一个插入进去 const canvas = document.getElementById(id) || document.createElement(&quot;canvas&quot;) if(canvas.id !== id)&#123; (canvas.id = id) &amp;&amp; document.body.appendChild(canvas)&#125; //通过调用上面的方法来获取到一个可以链式操作的上下文 const context = Canvas2DContext(canvas) let currentParticle, isWResize = width, isHResize = height, myReq = null let particles = [] //这里默认的是网页窗口大小，如果传入则取传入的值 width = width || document.documentElement.clientWidth height = height || document.documentElement.clientHeight class Particle &#123; constructor(&#123;context, x, y, r, parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY, useCache&#125;)&#123; this.context = context this.x = x this.y = y this.r = toFixed(r) this.ratio = 3 this.color = color2Rgb(typeof parColor === &quot;string&quot; ? parColor : getArrRandomItem(parColor), parOpacity) // 颜色 this.lineColor = color2Rgb(typeof lineColor === &quot;string&quot; ? lineColor : getArrRandomItem(lineColor), lineOpacity) if(lineColor === &quot;#fff&quot;)&#123; this.color = this.lineColor &#125;else&#123; this.lineColor = this.color &#125; this.lineWidth = lineWidth //防止初始化越界 this.x = x &gt; this.r ? x - this.r : x this.y = y &gt; this.r ? y - this.r : y //初始化最开始的速度 this.moveX = Math.random() + moveX this.moveY = Math.random() + moveY this.useCache = useCache this.draw() &#125; draw()&#123; if(this.x &gt;= 0 &amp;&amp; this.y &gt;= 0)&#123; if(this.useCache)&#123; this.context.drawImage( getCachePoint(this.r,this.color,this.ratio), toFixed(this.x - this.r) * this.context._retinaRatio, toFixed(this.y - this.r) * this.context._retinaRatio, this.r * 2 * this.context._retinaRatio, this.r * 2 * this.context._retinaRatio ) &#125;else&#123; this.context.beginPath() .fillStyle(this.color) .arc(toFixed(this.x), toFixed(this.y), toFixed(this.r), 0, Math.PI * 2) .fill() .closePath() &#125; &#125; &#125; drawLine(_round) &#123; let dx = this.x - _round.x, dy = this.y - _round.y if (Math.sqrt(dx * dx + dy * dy) &lt; 150) &#123; let x = this.x, y = this.y, lx = _round.x, ly = _round.y if(this.userCache)&#123; x = this.x + this.r / this._ratio y = this.y + this.r / this._ratio lx = _round.x + _round.r / this._ratio ly = _round.y + _round.r / this._ratio &#125; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; lx &gt;= 0 &amp;&amp; ly &gt;= 0)&#123; this.context.beginPath() .moveTo(toFixed(x), toFixed(y)) .lineTo(toFixed(lx), toFixed(ly)) .closePath() .lineWidth(this.lineWidth) .strokeStyle(this.lineColor) .stroke() &#125; &#125; &#125; move() &#123; //边界判断 this.moveX = this.x + this.r * 2 &lt; width &amp;&amp; this.x &gt; 0 ? this.moveX : -this.moveX this.moveY = this.y + this.r * 2 &lt; height &amp;&amp; this.y &gt; 0 ? this.moveY : -this.moveY //通过偏移量，改变x y的值，绘制 this.x += this.moveX this.y += this.moveY this.draw() &#125; &#125; //动画函数 const animate = () =&gt; &#123; //每次调用要首先清除画布，不然你懂的 context.clearRect(0, 0, width, height) for (let i = 0; i &lt; particles.length; i++) &#123; //粒子移动 particles[i].move() for (let j = i + 1; j &lt; particles.length; j++) &#123; //粒子连线 particles[i].drawLine(particles[j]) &#125; &#125; /** * 这个放在外面的原因 * 我不开启isMove的时候，或者currentParticle.x 没有值的情况 * 放在上面的循环需要每次走循环都判断一次 * 而放在下面的话只需要执行一次就知道有没有必要再执行 N 次 * 当然你也可以放里面，问题也不大 */ if (isMove &amp;&amp; currentParticle.x) &#123; for (let i = 0; i &lt; particles.length; i++) &#123; currentParticle.drawLine(particles[i]) &#125; currentParticle.draw() &#125; myReq = requestAnimationFrame(animate) &#125; //准备一个 init() 方法 初始化画布 const init = () =&gt; &#123; // canvas.width = width // canvas.height = height setRetina(canvas, context, width, height) //独立粒子 if (isMove &amp;&amp; !currentParticle) &#123; currentParticle = new Particle(&#123; x: 0, y: 0, r: targetR, parColor: targetColor, parOpacity: targetPpacity, lineColor, lineOpacity, lineWidth, context, useCache &#125;) //独立粒子 const moveEvent = (e = window.event) =&gt; &#123; //改变 currentParticle 的 x y currentParticle.x = e.clientX || e.touches[0].clientX currentParticle.y = e.clientY || e.touches[0].clientY &#125; const outEvent = () =&gt; &#123;currentParticle.x = currentParticle.y = null&#125; const eventObject = &#123; &quot;pc&quot;: &#123; move: &quot;mousemove&quot;, out: &quot;mouseout&quot; &#125;, &quot;phone&quot;: &#123; move: &quot;touchmove&quot;, out: &quot;touchend&quot; &#125; &#125; const event = eventObject[/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? &quot;phone&quot; : &quot;pc&quot;] canvas.removeEventListener(event.move,moveEvent) canvas.removeEventListener(event.out, outEvent) canvas.addEventListener(event.move,moveEvent) canvas.addEventListener(event.out, outEvent) &#125; //自由粒子 for (let i = 0; i &lt; num; i++) &#123; particles.push(new Particle(&#123; context, x: Math.random() * width, y: Math.random() * height, r: Math.round(Math.random() * (maxParR - minParR) + minParR), parColor, parOpacity, lineWidth, lineColor, lineOpacity, moveX, moveY, useCache &#125;)) &#125; //执行动画 animate() /* 这个判断在于，假设用户只需要一个 500*500 的画布的时候。其实是不需要 resize 的 而用户如果只是输入其中一个值，另一个值自适应，则认为其需要 resize。 如果全部都自适应，那则肯定是需要 resize 的 此逻辑是我自己瞎想的，其实不用也行，只是我觉得这样更符合我自己的需求。 全部 resize 也是可以的。 */ if(!isWResize || !isHResize)&#123;window.addEventListener(&quot;resize&quot;,debounce(resize, 100))&#125; &#125; const resize = () =&gt; &#123; //清除 定时器 if(this.timeout)&#123;clearTimeout(this.timeout)&#125; //清除 AnimationFrame if(myReq)&#123;window.cancelAnimationFrame(myReq)&#125; //清空 粒子数组 particles = [] //设置新的 宽高 width = isWResize ? width : document.documentElement.clientWidth height = isHResize ? height : document.documentElement.clientHeight this.timeout = setTimeout(init, 20) &#125; init() return canvas&#125;const canvas = ParticleCanvas(&#123;&#125;)console.log(canvas) 写到这里基本也就写完了… 溜了溜了","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://luoyuda.github.io/tags/canvas/"},{"name":"HTML5","slug":"HTML5","permalink":"https://luoyuda.github.io/tags/HTML5/"}]},{"title":"canvas-api 学习笔记","slug":"Canvas/canvas-01","date":"2018-11-21T11:23:00.000Z","updated":"2018-11-21T11:23:00.000Z","comments":true,"path":"2018/11/21/Canvas/canvas-01/","link":"","permalink":"https://luoyuda.github.io/2018/11/21/Canvas/canvas-01/","excerpt":"","text":"canvascanvas-api-demo-github canvas 是 HTML5 新增的组件，它就像一块幕布，可以用 JavaScript 在上面绘制各种图表、动画。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&#x27;canvas&#x27;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; canvas-api通过获取节点获取到 canvas 元素，调用 getContext(&#39;2d&#39;) 方法让我们拿到一个 CanvasRenderingContext2D 对象，所有的绘图操作都需要通过这个对象完成。 12const canvas = document.getElementById(&quot;canvas&quot;)const context = canvas.getContext(&quot;2d&quot;) 矩形 fillRect(x,y,width,height)：绘制一个填充的矩形 strokeRect(x,y,width,height)：绘制一个矩形的边框 clearRect(x, y, width, height)：清除指定矩形区域，让清除部分完全透明。 rect(x, y, width, height)：绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。将一个矩形路径增加到当前路径上！123456789/* #region */context.lineWidth = 1context.fillStyle = &quot;#000&quot;context.fillRect(0, 0, 50, 50)context.strokeStyle = &quot;#000&quot;context.strokeRect(60, 0, 50, 50)context.rect(0, 60, 50, 50)context.stroke()/* #endregion */ 路径 落笔 线段 beginPath()：新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath()：闭合路径之后图形绘制命令又重新指向到上下文中。 stroke()：通过线条来绘制图形轮廓。 fill()：通过填充路径的内容区域生成实心的图形 moveTo(x,y)：将笔移动到指定的坐标x以及y上。 lineTo(x,y)：绘制一条从当前位置到指定x以及y位置的直线。12345678910111213context.beginPath()context.moveTo(130, 0) // 从(130, 0) 开始context.lineTo(180, 0) // 到(180, 0)context.lineTo(180, 50)context.lineTo(130, 50)context.lineTo(130, 0)context.lineWidth = 4context.lineCap = &quot;round&quot; // 线条末端线帽为圆角context.lineJoin = &quot;round&quot; // 拐角时候为圆角context.strokeStyle = &quot;green&quot; // 描边颜色为绿色context.fill()context.stroke()context.closePath() 圆 圆弧 arc(x, y, radius, startAngle, endAngle, anticlockwise)：画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 x：圆心的 x 坐标 y：圆心的 y 坐标 r：圆的半径 sAngle：起始角，以弧度计（弧的圆形的三点钟位置是 0 度） eAngle：结束角，以弧度计 counterclockwise：可选。规定应该逆时针还是顺时针绘图。false 为顺时针，true 为逆时针 arcTo(x1, y1, x2, y2, radius)：根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点 x1：第一个控制点的 x 轴坐标。 y1：第一个控制点的 y 轴坐标。 x2：第二个控制点的 x 轴坐标。 y2：第二个控制点的 y 轴坐标。 radius：圆弧的半径。1234567891011121314/* #region */context.beginPath()context.arc(230, 30, 25, 0, Math.PI * 1.5, false)context.closePath()context.lineWidth = 1context.strokeStyle = &quot;#000&quot;context.stroke()context.fillStyle = &quot;red&quot;context.fill()context.beginPath()context.moveTo(300, 10)context.arcTo(300,100,350,30,30)context.stroke()/* #endregion */ 贝塞尔曲线 quadraticCurveTo(cp1x, cp1y, x, y)：绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。1234567891011121314151617181920212223/* #region 贝塞尔曲线 *///二次贝塞尔曲线context.beginPath()context.moveTo(400, 10)context.quadraticCurveTo(380, 20, 400, 30)context.quadraticCurveTo(380, 40, 400, 50)context.quadraticCurveTo(400, 50, 400, 50)context.quadraticCurveTo(420, 40, 400, 30)context.quadraticCurveTo(420, 20, 400, 10)context.lineTo(400,10)context.stroke()context.closePath()// 三次贝塞尔曲线context.beginPath()context.moveTo(450, 10)context.bezierCurveTo(450, 10, 430, 20, 450, 30)context.bezierCurveTo(450, 30, 430, 40, 450, 50)context.bezierCurveTo(450, 50, 470, 40, 450, 30)context.bezierCurveTo(450, 30, 470, 20, 450, 10)context.lineTo(450,10)context.stroke()context.closePath()/* #endregion */ 绘图 drawImage(image, x, y) image：规定要使用的图像、画布或视频 x、y：起始的 x 、y 坐标位置 drawImage(image, x, y, width, height) image, x, y 参数同上 width、height：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小 drawImage(img, sx, sy, swidth, sheight, x, y, width, height) image, x, y, width, height 参数同上 sx：在图像的 x 坐标位置 sy：在图像的 y 坐标位置 swidth：要使用的图像的宽度（伸展或缩小图像） sheight：要使用的图像的高度（伸展或缩小图像）12345678/* #region 绘图代码 */let testImg = document.getElementById(&quot;testImg&quot;)testImg.onload = () =&gt; &#123; context.drawImage(testImg, 0, 240, 100, 100) // 从图片的 (20, 20)开始，裁切一个宽高 30 的图片 ，从 画布 上 (10, 350) 开始绘制一个 宽高 50 的图像 context.drawImage(testImg, 20, 20, 30, 30, 10, 350, 50, 50)&#125;/* #endregion */ 颜色、阴影、样式、渐变 fillStyle：设置图形的填充颜色。 strokeStyle：设置图形轮廓的颜色。 shadowColor：用于设定阴影颜色效果，默认是全透明的黑色 shadowBlur：用于设定阴影的模糊程度 shadowOffsetX：设定阴影在 X 轴的延伸距离 shadowOffsetY：设定阴影在 Y 轴的延伸距离 createLinearGradient(x1, y1, x2, y2)：接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 createRadialGradient(x1, y1, r1, x2, y2, r2)：接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 gradient.addColorStop(position, color)：接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。 createPattern(image, type)：该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* #region */context.beginPath()context.fillStyle = &quot;#ed2&quot;context.shadowColor = &quot;#ed2&quot;context.strokeStyle = &quot;#fff&quot;context.shadowBlur = 20context.arc(85, 85, 20, 0, Math.PI * 2, true)context.fill()context.stroke()context.shadowBlur = 0context.closePath()//渐变context.beginPath()let lingrad = context.createLinearGradient(130, 60, 180, 110)lingrad.addColorStop(0, &quot;#00ABEB&quot;)lingrad.addColorStop(1, &quot;#eee&quot;)context.fillStyle = lingradcontext.fillRect(130, 60, 50, 50)let lingrad2 = context.createLinearGradient(205, 65, 245, 105)context.strokeStyle = lingrad2lingrad2.addColorStop(0, &quot;#00ABEB&quot;)lingrad2.addColorStop(1, &quot;#000&quot;)context.arc(225, 85, 20, 0, Math.PI * 2, true)context.stroke()let lingrad3 = context.createLinearGradient(205, 65, 245, 105)lingrad3.addColorStop(0, &quot;#fff&quot;)lingrad3.addColorStop(1, &quot;#00ABEB&quot;)context.fillStyle = lingrad3context.fill()let radgrad = context.createRadialGradient(305, 85, 5, 305, 85, 30)radgrad.addColorStop(0, &quot;#A7D30C&quot;)radgrad.addColorStop(0.5, &quot;#019F62&quot;)radgrad.addColorStop(1, &quot;#A7D30C&quot;)context.fillStyle = radgradcontext.fillRect(280, 60, 50, 50)context.strokeRect(280, 60, 50, 50)let testImg = document.getElementById(&quot;testImg&quot;)testImg.onload = ()=&gt;&#123; console.log(testImg) let ptrn = context.createPattern(testImg, &quot;repeat&quot;) context.fillStyle = ptrn context.strokeStyle = ptrn context.fillRect(350, 60, 100, 100) context.fillStyle = &quot;#fff&quot; context.shadowOffsetX = 2 context.shadowOffsetY = 2 context.shadowBlur = 20 context.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot; context.fillRect(470, 60, 100, 100) context.strokeRect(470, 60, 100, 100) context.shadowBlur = 0&#125; 文本 fillText(text, x, y [, maxWidth])：在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth])：在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. font = value：当前我们用来绘制文本的样式. 默认的字体是 10px sans-serif。 textAlign = value：文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value：基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 direction = value：文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 measureText() 将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。123456789context.font = &quot;30px serif&quot;context.strokeStyle = &quot;#000&quot;context.fillStyle = &quot;#000&quot;context.textAlign = &quot;left&quot;context.direction = &quot;ltr&quot;context.textBaseline = &quot;top&quot;let text = context.measureText(&quot;落雨Ly&quot;)context.fillText(&quot;落雨Ly&quot;, 0, 150, text.width)context.strokeText(&quot;落雨Ly&quot;, 0, 190, text.width) 图像变形 save()：保存 canvas 状态 restore()：恢复 canvas 状态 scale(x,y)：缩放当前绘图至更大或更小 rotate(angle)：它用于以原点为中心旋转 canvas ，以弧度为单位的值 x = r*Math.cos(a); y = r * Math.sin(a) translate(x, y)：移动 canvas 和它的原点到一个不同的位置 x、y 是偏移量 transform(m11, m12, m21, m22, dx, dy)：当前的变形矩阵乘上一个基于自身参数的矩阵 m11：水平方向的缩放 m12：水平方向的倾斜偏移 m21：竖直方向的倾斜偏移 m22：竖直方向的缩放 dx：水平方向的移动 dy：竖直方向的移动 setTransform(m11, m12, m21, m22, dx, dy)：将当前转换重置为单位矩阵，然后运行 transform() resetTransform()：重置当前变形为单位矩阵12345678910111213141516/* #region 转换代码 */context.strokeStyle = &quot;#000&quot;context.save()context.scale(1.5, 1.5)context.rotate(Math.PI * 2 / 25)context.strokeRect(100, 100, 30, 30) context.translate(30, 30)context.strokeRect(100, 100, 30, 30) context.restore()context.save()context.setTransform(1.1, 0, 0, 1, 20, 20)context.strokeStyle = &quot;red&quot;context.strokeRect(200, 130, 30, 30) context.restore()/* #endregion */ 感谢MDN的Canvas的基本用法 下一篇再写个 canvas 粒子背景实践","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://luoyuda.github.io/tags/canvas/"},{"name":"HTML5","slug":"HTML5","permalink":"https://luoyuda.github.io/tags/HTML5/"}]},{"title":"小程序发送请求的异步操作探索","slug":"Async/01","date":"2018-11-12T11:23:00.000Z","updated":"2018-11-12T11:23:00.000Z","comments":true,"path":"2018/11/12/Async/01/","link":"","permalink":"https://luoyuda.github.io/2018/11/12/Async/01/","excerpt":"","text":"回调一开始的时候使用回调的方式写统一调用小程序发送请求的接口。 准备数据 &#x3D;&gt; 发送请求 &#x3D;&gt; 执行回调1234567891011121314151617181920212223242526272829303132333435363738function CGI(yurl, type, data, success, err) &#123; var version = getVersion(); var uoAuth = getUoAuth(); var uoSign = getUoSign(); var url = getTrueUrl(yurl); if (uoAuth &amp;&amp; uoSign) &#123; data.uoAuth = uoAuth; data.uoSign = uoSign; &#125; //上面获取登陆状态，和参数的东西，无视 type = type.toUpperCase(); var contentType = &#x27;application/json&#x27;; if (type == &quot;POST&quot;) &#123; contentType = &#x27;application/x-www-form-urlencoded&#x27;; &#125; wx.request(&#123; url: url, data: data, method: type, header: &#123; &#x27;content-type&#x27;: contentType &#125;, success: function (res) &#123; if(res.data.errCode == 1) &#123; login(); return ; &#125; typeof success == &quot;function&quot; &amp;&amp; success(res.data); &#125;, fail: function (res) &#123; wx.showToast(&#123; title: res.msg || &#x27;网络访问失败&#x27;, duration: 1500 &#125;); typeof err == &quot;function&quot; &amp;&amp; err(res.data); &#125; &#125;)&#125; Promise将回调改写成 Promise 的方式调用 准备数据 &#x3D;&gt; 发送请求 &#x3D;&gt; 返回 Promise 对象 &#x3D;&gt; then1234567891011121314151617181920212223242526272829303132333435363738394041424344/* Promise 接口调用函数*/function PCGI(yurl, type, data, success, err) &#123; console.log(&#x27;PCGI&#x27;) var version = getVersion(); var uoAuth = getUoAuth(); var uoSign = getUoSign(); var url = getTrueUrl(yurl); if (uoAuth &amp;&amp; uoSign) &#123; data.uoAuth = uoAuth; data.uoSign = uoSign; &#125; type = type.toUpperCase(); var contentType = &#x27;application/json&#x27;; if (type == &quot;POST&quot;) &#123; contentType = &#x27;application/x-www-form-urlencoded&#x27;; &#125; return new Promise((resolve,reject)=&gt;&#123; wx.request(&#123; url: url, data: data, method: type, header: &#123; &#x27;content-type&#x27;: contentType &#125;, success: function (res) &#123; if (res.data.errCode == 1) &#123; login(); return; &#125; resolve(res.data) &#125;, fail: function (res) &#123; wx.showToast(&#123; title: res.msg || &#x27;网络访问失败&#x27;, duration: 1500 &#125;); reject(res.data); &#125; &#125;) &#125;)&#125; generator + co在 PCGI 的基础上改造，支持并发请求 准备数据 &#x3D;&gt; 发送请求 &#x3D;&gt; 返回 Promise 对象 &#x3D;&gt; then12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const HEADER = &#123; &#x27;GET&#x27;:&#123; &#x27;content-type&#x27;: &#x27;application/json&#x27; &#125;, &#x27;POST&#x27;: &#123; &#x27;content-type&#x27;:&#x27;application/x-www-form-urlencoded&#x27; &#125;&#125;function getTrueUrl(url)&#123; //...&#125;function promiseReq(item)&#123; let method = &#x27;GET&#x27;; var uoAuth = getUoAuth() || &#x27;&#x27;; var uoSign = getUoSign() || &#x27;&#x27;; let config = &#123; url: &#x27;&#x27;, data: &#123;uoAuth, uoSign&#125;, method, &#125; return new Promise((resolve,reject)=&gt;&#123; if (isString(item))&#123; config.url = getTrueUrl(item); &#125;else&#123; let &#123; url, type=&#x27;GET&#x27;, data &#125; = item; config.url = getTrueUrl(url); config.data = data ? Object.assign(config.data, data) : config.data; config.method = type &amp;&amp; type.toUpperCase() || method; &#125; config.header = HEADER[config.method]; config.success = (res) =&gt; resolve(res.data) config.fail = (err) =&gt; reject(err) wx.request(config); &#125;)&#125;function requestFn(request) &#123; console.log(&#x27;requestFn&#x27;) function* task() &#123; try &#123; var result; if(isArray(request))&#123; result = yield Promise.all(request.map((item, index, arr) =&gt; promiseReq(item))) &#125;else&#123; result = yield promiseReq(request) &#125; console.log(result) return result; &#125; catch (e) &#123; console.log(e) &#125; &#125; return co(task)&#125; async &#x2F; await在 generator + co 的基础上使用 async &#x2F; await 改造 准备数据 &#x3D;&gt; 发送请求 &#x3D;&gt; 返回 Promise 对象 &#x3D;&gt; then12345678910111213141516171819202122232425262728293031323334353637function promiseReq(item)&#123; let method = &#x27;GET&#x27;; var uoAuth = getUoAuth() || &#x27;&#x27;; var uoSign = getUoSign() || &#x27;&#x27;; let config = &#123; url: &#x27;&#x27;, data: &#123;uoAuth, uoSign&#125;, method, &#125; return new Promise((resolve,reject)=&gt;&#123; if (isString(item))&#123; config.url = getTrueUrl(item); &#125;else&#123; let &#123; url, type=&#x27;GET&#x27;, data &#125; = item; config.url = getTrueUrl(url); config.data = data ? Object.assign(config.data, data) : config.data; config.method = type &amp;&amp; type.toUpperCase() || method; &#125; config.header = HEADER[config.method]; config.success = (res) =&gt; resolve(res.data) config.fail = (err) =&gt; reject(err) wx.request(config); &#125;)&#125;function asyncRequest(request) &#123; console.log(&#x27;asyncRequest&#x27;) return (async () =&gt; &#123; try &#123; return isArray(request) ? await Promise.all(request.map((item, index, arr) =&gt; promiseReq(item))) : await promiseReq(request); &#125; catch (e) &#123; console.log(e) &#125; &#125;)()&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://luoyuda.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"设计模式","slug":"设计模式","permalink":"https://luoyuda.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://luoyuda.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"工程化","slug":"工程化","permalink":"https://luoyuda.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"部署","slug":"部署","permalink":"https://luoyuda.github.io/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luoyuda.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://luoyuda.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LFU","slug":"LFU","permalink":"https://luoyuda.github.io/tags/LFU/"},{"name":"LRU","slug":"LRU","permalink":"https://luoyuda.github.io/tags/LRU/"},{"name":"懒加载图片","slug":"懒加载图片","permalink":"https://luoyuda.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"name":"插件开发","slug":"插件开发","permalink":"https://luoyuda.github.io/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"性能优化","slug":"性能优化","permalink":"https://luoyuda.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://luoyuda.github.io/tags/EventLoop/"},{"name":"队列","slug":"队列","permalink":"https://luoyuda.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"算法","slug":"算法","permalink":"https://luoyuda.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"https://luoyuda.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"堆排序","slug":"堆排序","permalink":"https://luoyuda.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"作用域","slug":"作用域","permalink":"https://luoyuda.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"执行上下文","slug":"执行上下文","permalink":"https://luoyuda.github.io/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"作用域链","slug":"作用域链","permalink":"https://luoyuda.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"name":"计数排序","slug":"计数排序","permalink":"https://luoyuda.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"快排","slug":"快排","permalink":"https://luoyuda.github.io/tags/%E5%BF%AB%E6%8E%92/"},{"name":"希尔","slug":"希尔","permalink":"https://luoyuda.github.io/tags/%E5%B8%8C%E5%B0%94/"},{"name":"插入","slug":"插入","permalink":"https://luoyuda.github.io/tags/%E6%8F%92%E5%85%A5/"},{"name":"归并","slug":"归并","permalink":"https://luoyuda.github.io/tags/%E5%BD%92%E5%B9%B6/"},{"name":"选择","slug":"选择","permalink":"https://luoyuda.github.io/tags/%E9%80%89%E6%8B%A9/"},{"name":"冒泡","slug":"冒泡","permalink":"https://luoyuda.github.io/tags/%E5%86%92%E6%B3%A1/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://luoyuda.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://luoyuda.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"this","slug":"this","permalink":"https://luoyuda.github.io/tags/this/"},{"name":"call / apply","slug":"call-apply","permalink":"https://luoyuda.github.io/tags/call-apply/"},{"name":"bind","slug":"bind","permalink":"https://luoyuda.github.io/tags/bind/"},{"name":"new","slug":"new","permalink":"https://luoyuda.github.io/tags/new/"},{"name":"全等","slug":"全等","permalink":"https://luoyuda.github.io/tags/%E5%85%A8%E7%AD%89/"},{"name":"ES6","slug":"ES6","permalink":"https://luoyuda.github.io/tags/ES6/"},{"name":"去重","slug":"去重","permalink":"https://luoyuda.github.io/tags/%E5%8E%BB%E9%87%8D/"},{"name":"原型链","slug":"原型链","permalink":"https://luoyuda.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"继承","slug":"继承","permalink":"https://luoyuda.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"创造型设计模式","slug":"创造型设计模式","permalink":"https://luoyuda.github.io/tags/%E5%88%9B%E9%80%A0%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"结构型设计模式","slug":"结构型设计模式","permalink":"https://luoyuda.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"行为型设计模式","slug":"行为型设计模式","permalink":"https://luoyuda.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Promise","slug":"Promise","permalink":"https://luoyuda.github.io/tags/Promise/"},{"name":"Symbol","slug":"Symbol","permalink":"https://luoyuda.github.io/tags/Symbol/"},{"name":"Map","slug":"Map","permalink":"https://luoyuda.github.io/tags/Map/"},{"name":"Set","slug":"Set","permalink":"https://luoyuda.github.io/tags/Set/"},{"name":"二分查找","slug":"二分查找","permalink":"https://luoyuda.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"异步处理","slug":"异步处理","permalink":"https://luoyuda.github.io/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"},{"name":"Vue","slug":"Vue","permalink":"https://luoyuda.github.io/tags/Vue/"},{"name":"重构","slug":"重构","permalink":"https://luoyuda.github.io/tags/%E9%87%8D%E6%9E%84/"},{"name":"React","slug":"React","permalink":"https://luoyuda.github.io/tags/React/"},{"name":"CSS","slug":"CSS","permalink":"https://luoyuda.github.io/tags/CSS/"},{"name":"Webpack","slug":"Webpack","permalink":"https://luoyuda.github.io/tags/Webpack/"},{"name":"二叉树","slug":"二叉树","permalink":"https://luoyuda.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"循环双向链表","slug":"循环双向链表","permalink":"https://luoyuda.github.io/tags/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"循环链表","slug":"循环链表","permalink":"https://luoyuda.github.io/tags/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"},{"name":"双向链表","slug":"双向链表","permalink":"https://luoyuda.github.io/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"堆","slug":"堆","permalink":"https://luoyuda.github.io/tags/%E5%A0%86/"},{"name":"链表","slug":"链表","permalink":"https://luoyuda.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"https://luoyuda.github.io/tags/%E6%A0%88/"},{"name":"静态链表","slug":"静态链表","permalink":"https://luoyuda.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"},{"name":"前缀树","slug":"前缀树","permalink":"https://luoyuda.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"效率工具","slug":"效率工具","permalink":"https://luoyuda.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"骨架屏","slug":"骨架屏","permalink":"https://luoyuda.github.io/tags/%E9%AA%A8%E6%9E%B6%E5%B1%8F/"},{"name":"Node","slug":"Node","permalink":"https://luoyuda.github.io/tags/Node/"},{"name":"提效工具","slug":"提效工具","permalink":"https://luoyuda.github.io/tags/%E6%8F%90%E6%95%88%E5%B7%A5%E5%85%B7/"},{"name":"docker","slug":"docker","permalink":"https://luoyuda.github.io/tags/docker/"},{"name":"Array","slug":"Array","permalink":"https://luoyuda.github.io/tags/Array/"},{"name":"canvas","slug":"canvas","permalink":"https://luoyuda.github.io/tags/canvas/"},{"name":"HTML5","slug":"HTML5","permalink":"https://luoyuda.github.io/tags/HTML5/"}]}